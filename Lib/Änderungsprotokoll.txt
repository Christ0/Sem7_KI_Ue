Änderungsprotokoll:

Legende: 
TB = Änderungen von Tobias Breiner
FS = Änderungen von Florian Schnell
KE = Änderungen von Klaus Enzensperger
MS = Änderungen von Matthias Sommer
KW = Änderungen von Kim Werner
BW = Änderungen von Benedikt Walser
PF = Änderungen von Patrick Fleischmann
MR = Änderungen von Michael Rücker
JB = Änderungen von Jonas Breiner
SB = Änderungen von Sina Breiner
NJ = Änderungen von Nicole Jansen

02.03.2005 TB: 
- erste Ideen
- UML-Diagramm
- Evaluation der Szenegrafen

02.02.2007 TB: 
- Erste Programierarbeiten
- Versuche mit DirectX 9

06.04.2009 TB: 
- Polygon sichtbar

20.04.2009 TB: 
- Klassen für Szenegrafen: 
	CRoot
	CScene
	CFrame
	CViewport
	CPlacement
	CMaterial
	CTexture
	CPixImage
	CGeo
	CCamera

28.04.2009 TB: 
- Einführung von Pluralklassen 
	CRoots
	CScenes
	CFrames
	CViewports
	CPlacements
	CMaterials
	CTextures
	CPixImages
	CGeos
	CCameras

02.05.2009 TB: 
 Homogene Mathematik:
	CHVector
	CHMat

09.05.2009 TB + FS: 
- TriangleStrips & TriangleStripLists

22.05.2009 TB
- Ellipsoidenklasse CGeoEllipsoid

12.03.2010 TB: 
- Versuche mit DirectX 11

27.06.2011 TB: 
- Transparente Texturen mit Alpha Blending möglich (allerdings noch keine Objektsortierung nach Transparenz und z-Wert)
- Kleinere optische Codeverbesserungen

29.06.2011 TB: 
- Bug bei Ellipsoidengenerierung beseitigt (Polygon in der Mitte des Ellipsoids taucht nicht mehr auf)  
- Kleinere optische Codeverbesserungen

30.06.2011 TB:
- 2. Constant-Buffer für die Texturparameterübergabe des Pixelshaders eingeführt
- Berechnungen im Pixelshader werden nur noch dann ausgeführt, wenn sie notwendig sind.
- Ladezeit verbessert durch Vermeidung redundanter Texturladungen
- Viele neue Material-Erzeugungsfunktionen, die ein schnelleres und effiziernteres Erzeugen von Texturen ermöglichen, u.A:
	void SetTextureGlowWhite();
	void SetTextureGlowBlack();
	void SetTextureGlowAsImage();
	void SetTextureGlowAsAmbient();
	void SetTextureSpecularWhite();
	void SetTextureSpecularBlack();
	void SetTextureSpecularAsImage();
- Viele neue Material-Erzeugungsfunktionen, die ein genaueres Erzeugen von Texturen mit Finetuning ermöglichen, u.A:
	void SetColorAmbient(CColor color);
	void SetBumpStrength(float fBumpStrength);
	void SetSpecularSharpness(float fSpecularSharpness);
	void SetDiffuseSharpness(float fDiffuseSharpness);
- Komplett neue Struktur von LoadTextures 
- Unnötige Normalenvektoren und Materialpointer bei der Klasse CFaces rausgeschmissen

01.07.2011 TB:
- Viele neue Material-Erzeugungsfunktionen, die ein ca. 3 Mal 
schnelleres und einfacheres Erzeugen von Texturen ermöglichen, 
durch Generierung einer gesamten Material-Texture-Image-Hierarchie auf einmal, u.A:
	CPixImage * MakeTextureDiffuse(char * acPath);
	CPixImage * MakeTextureGlow(char * acPath);
	CPixImage * MakeTextureSpecular(char * acPath);
	CPixImage * MakeTextureBump(char * acPath);

03.07.2011 TB:
- Unnutze und redundante Tick()-Aufrufe in der Szenengrafhierarchie entfernt => Beschleunigung
- Die Methode void CPlacement::Init() wurde nun einheitlich mit anderen Init-Prozeduren
- Herauswerfen von veralteten Kommentaren

04.07.2011 TB:
- Folgende Methoden in der Klasse CHMat implementiert und überprüft => funktionieren korrekt:
	float Det() // berechnet Determinante
	void Inverse(CHMat & m) // berechnet Inverse der homogenen 4*4-Matrix  m
	void Transpose(CHMat & m) // berechnet Transponierte der homogenen 4*4-Matrix  m
- Camera kann nun zu einem Placement hinzugefügt werden
- View-Matrix wird nun korrekt berechnet 
	=> Bei Positionierung der Camera verändert sich Bild entsprechend der Blickrichtung
- Placement kann nun zu einem Placement hinzugefügt werden 
	=> Komplexe Szenengrafhierarchie möglich

05.07.2011 TB:
- Zwei neue Material-Funktionen, um Shading an- und auszuschalten:
	void SetShadingOn();
	void SetShadingOff();
- Herauswerfen von veralteten Kommentaren
- "Zitterbug" entfernt (Wenn unter Cameraplacements weitere Placements gestzt wurden, 
	so wurden diese mit dem letzten Frameinfos gerendert, was zum "Zittern" von Objekten bei Camerabewegungen führte 
	=> komplett andere Aufrufstruktur notwendig) :
- Herauswerfen von ungenutzten Parametern in den Tick-Methoden von CGeo,  SScene, CPlacement incl. Pluralformen => Beschleunigung 

04.07.2011 TB:
- Unnötige prenderapi-Parameteraufrufe in Tick()-Funktionen von CGeoTriangleStrip und CTriangleStripIndexed entfernt 
=> Beschleunigung
- Klasse CInputX eingefügt, für Tastatureingaben
- Testprogramm erweitert, Kamera kann jetzt mit Pfeiltasten oder WASD-Tasten und der Leertaste gesteuert werden.

15.07.2011 TB:
- Level of Details möglich
- Dafür Methode SetLoD in Klasse CPlacement (schon getestet):
	void SetLoD(float fDistNear, float fDistFar);
- Möglichkeit, Placement-Branches komplett an- und auszuschalten, dafür folgende Methoden in CPlacement:
	void SwitchOn();
	void SwitchOff();
- Neue Methode in CHMat, um Translationssubmatrix als Vektor auszuspucken (sehr pratisch, um Position der Placements schnell zu ermitteln):
	CHVector CHMat::GetTranslation()  
- Herauswerfen von veralteten Kommentaren

16.07.2011 TB:
- Billboards nun möglich (getestet, zumindest für eine einzige Kamera, bei mehreren Kameras gibts noch Probleme), 
dafür folgende neue Methode in CPlacement:
	void SetBillboard();
und in CHMat:
	void CopyRotation(CHMat & hmat);
- Klassen CHMat und CGeo von ungenutzten Membervariablen und Parametern gesäubert => leichte Beschleunigung

23.07.2011 TB:
- Objekte werden der GPU jetzt automatisch in der richtigen Reihenfolge (abhängig von der Distanz zur Kamera übergeben) 
=> Manko der Änderung vom 27.06.2011 wurde behoben, Achtung, noch ungetestet!
=> Benutzer des Vektoria SDKs müssen bei transparenten Objekten nun nicht mehr auf die Reihenfolge achten
=> Komplett andere Aufrufstruktur von Renderapi und DirectX notwendig & Sortierung der transparenten Objekte nach z-Buffer notwendig
- Update der Schnittstellenbesschreibung
- BackfaceCulling, Antialiasing und Wirframe-Modus kann nun per Setter-Methoden in der Klasse 
  CViewport an- und Ausgeschaltet werden:
	void SetBackfaceCullingOn();
	void SetBackfaceCullingOff();
	void SetAntialiasingOn();
	void SetAntialiasingOff();
	void SetWireframeOff();
	void SetWireframeOn();

23.07.2011 TB:
- Ein Placement kann nun an mehrere verschiedene andere Placements angehängt werden 
	(vorher galt n Sohnplacements auf 1 Vaterplacement, nun n Sohnplacements auf m Vaterplacements) 
- Komplett neue Struktur der Pluralklasse CPlacements
- Beschleunigung der Placement-Hierarchie durch Arrays statt verkettete Listen 
	und intelligente blockweise Allokierung & Deallokierung nach Bedarf 
- Neue Funktion Sub in CPlacements, um ein Placement wieder abzuhängen:
	bool Sub(CPlacement *pplacement);
- Bug in Methode Mergesort der Klasse CDirectX ausgebessert (Alphaobjekte wurden nicht richtig sortiert)
- Alphasortierung getestet => positiv, funktioniert 
- Variablennamen in VektoriaTest-Programm aussagekräftiger gemacht (z.B. nicht mehr m_materialTest3 sondern m_materialMoon, etc.) 

26.07.2011 TB:
- Neue Methoden in CPlacement, um Billboards um die Sichtachse mit einem Winkel fa herumzu drehen (getestet und funktioniert): 	
	void SetBillboardAngle(float fa);
	float GetBillboardAngle();
- Neue Methoden in CMaterial, um ChromaKeying zu erlauben:
	void SetChromaKeyingOn();
	void SetChromaKeyingOff();
- Shader verändert, um ChromaKeying anzuzeigen, da allerdings das bilineare Filtering 
aus irgendeinem Grund nicht ausgeschaltet werden konnte, funktioniert ChromaKeying nicht richtig, 
damit trotzdem ein nützlicher Effekt, wurde gesagt Schwarztöne = Transparent (führt allerdings zu Artefakten an den Rändern)
- 100 verschidene Billboard-Nebel und 500 verschiedene ChromaKeying-Asteroiden in die Test-Szene integriert, 
um Geschwindigkeit und Funktion von vielen transparenten und halbtransparenten Objekten zu testen.

27.07.2011 TB:
- Vereinfachung und Beschleunigung der Initialisierung für den SDK-Anwender, 
	da Init-Routinen ohne Parametrisierung in den Konstruktor verlagert wurden 
		=> keine doppelten Initialisierungen mehr
		=> User braucht nicht explizit Init-Methoden aufrufen 
		=> weniger Fehleranfälligkeit des Codes
- Frame Rate Messungs-Anzeige in Testprogramm integriert (unter Menü->Messungen->Frame Rate)
- Konsequente Verwendung von Call by Reference statt Call by Value bei der Parameterübergabe von Matrizen 
	=> Erhöhung der Frame Rate in der Testumgebung um satte 83%!

28.07.2011 TB:
- Bugfix in Schnelloperator Matrix *= Vektor in CHMat => getestet, funktioniert nun korrekt
- Schnelloperator Vektor *= Matrix aus CHMat herausgenommen (ist in CHMat sinnlos) 
- Klassen CBillboard und CBillboards aus Projekt herausgenommen (Billboards wurden ja nun innerhalb von CPlacement eleganter gelöst) 
- Konsequente Verwendung von Call by Reference statt Call by Value bei der Parameterübergabe von Placements 
	=> Erhöhung der Frame Rate in der Testumgebung um 1%
- Konsequente Verwendung von Call by Reference statt Call by Value bei der Parameterübergabe bei allen Tick-Methoden 
	=> Erhöhung der Frame Rate in der Testumgebung um 19%
- Herauswerfen veralteter Komentare

31.07.2011 TB:
- Umbenennung von CGeoTriangleStrip in CGeoTriangleList (Name war missverständlich)
- Bugfix in Plus und Minusoperator von CHVector (Addition und Subtraktion veränderte vorher auch Operanten)
- Bugfix in CGeo (Memberpointer wurden nicht auf NULL gesetzt => Absturz)
- Bugfix in CGeoTriangleList (Normalen- und Binormalen- und Tangentenvektoren wurden nicht richtig übergeben)
- Neue Klasse CGeoIcosahedron, um eine Icosahedron-Primitivengeometrie zu erzeugen (getestet, funktioniert)

01.08.2011 TB:
- Verschiedene Methoden, um SkyBoxes, SkyDomes etc. zu erzeugen 
(nach reiflicher Überlegung habe ich mich für eine andere Vorgehensweise als bei allen herkömmlichen Szenegrafen entschieden: 
es gibt keine eigenen Sky-Klassen, sondern Sky ist eine optionale Eigenschaft der Klasse Placement: 
=> schneller und mehr Variationen möglich)
Die Methoden sind:
	void CopyTranslation(CHMat & hmat); // in CHMat
	void SetSky(); // in CPlacement


02.08.2011 TB:
- Bugfix in CGeoTriangleList und CTriangleStripIndexed (Bei Übergabe einer Geometrie ohne Material gab es einen Absturz)
- Arrays statt verkettete Listen in  CGeoTriangleList => Übergabe mehrerer gleicher Vertices möglich 
- Bugfix in CGeoCube => getestet, funktioniert nun
- Methode Flip in CGeo, um Vorderseite und Rückseiten zu vertauschen (funktioniert bisher nur bei TriangleLists)
- CGeoCube::Init-Methode um zwei optionale Paramerer erweitert (iTextureRepeat für das TextureClamping und bFlip zur
Vertauschung von Innen- und Außenseite) 
- Herauswerfen veralteter Komentare
- Bugfix in Methode void CopyTranslation(CHMat & hmat); => getestet, funktioniert nun
- SkyBox in das Testprogramm eingebaut   

03.08.2011 TB:
- Bugfixes in CGeoTetrahedron (UV-Mapping wird nun ausgeführt, Kanten scharf, Binormalen fürs Bumpmapping werden richtig ausgerechnet)
- CGeoTetrahedron::Init-Methode um optionalen Paramerer erweitert (bFlip zur Vertauschung von Innen- und Außenseite) 
- Testprogramm erkennt automatisch aktuelle Bildschirmgröße und wird maximiert gestartet
- Verbesserte WASD-Steuerung im Testprogramm (Pfeiltasten = Orientierung, R= hoch, D = runter)

05.08.2011 TB:
- ACHTUNG!!! Umstellung auf Visual Studio C++ 2010, da es bessere Möglichkeit für 64 bit-release + Library-Erzeugung bietet!!! 
=> Größere irreversible Änderungen in den Projektdateien

07.08.2011 TB:
- 3D Raumklang nun möglich, mit folgenden neuen Methoden in Klasse CAudio:
	bool Init(char *stringWavFile, HWND hwnd);  // Initialisiert einen Klang ohne 3D-Sound, dieser kann nicht in den Szenengraf eingebaut werden, die Funktion gibt true aus, falls die Initailisierung erfolgreich war, ansonsten false 
	bool Init3D(char *stringWavFile, HWND hwnd, float fRadius); // Initialisiert einen Klang mit 3D-Sound, die Funktion gibt true aus, falls die Initailisierung erfolgreich war, ansonsten false
	void Tick(CHMat & mSound, float fTimeDelta); //Updated einen Klang mit 3D-Sound, muss bei jeden Frame aufgerufen werden, mSound ist die globale Matrix der Klangquelle, fTimeDelta ist die verstrichene Zeit seit dem letzten Tick 
	void Fini(); // Finalisiert einen Klang, egal ob mit oder ohne 3D-Sound
	void Listen(CHMat & mListener); // Positioniert den Zuhörer beim 3D-Sound mittels der globalen Matrix mListener
	void Start();	// Startet einen Klang, spielt ihn einmal ab
	void Loop();	// Startet einen Klang, spielt ihn immer wieder ab
	void Stop();	// Beendet einen gestarten Klang 
	void SetVolume(float frVolume); // Modifiziert die Lautstärke (0.0F=aus 1.0F= volles Rohr) 
	void SetRadius(float fRadius); // Modifiziert den Wirkradius in Units eines 3D-Klanges 
	bool Is3D(); // Gibt true aus, wenn 3D-Sound, ansonsten false 
- Sinnfällige Komentare in allen Header-Dateien, die als SDK-Interface dienen
- Veraltete Klasse CGeoSphere gelöscht

08.08.2011 TB:
- Doppler-Effekt in 3D Raumklang implementiert, dafür folgende Methode:
	void SetDoppler(float fFactor); // fFactor=1.0: physikalisch richtiger Doppler-Effekt, fFactor=0.0: kein Doppler-Effekt; Default = 1.0F, 

10.08.2011 TB:
- in CMaterial ist die Transparenz nun getrennt vom Alpha-Kanal einstellbar, dafür folgende neue Methode:
	void SetTransparency(float frTransparency);
- Framerate des Testprpgrammes wurde leicht beschleunigt (ca. 0,3%) durch effizientere Materialübergabe zwischen CMaterial und CDirectX
- Texturenanzahl nicht mehr auf max. 1024 begrenzt, dank dynamischer Allokierung 

12.08.2011 TB:
- Bugfix in CPlacement: n zu m -Zuorddnung funktionierte nur für die ersten Placements => getetstet, funktioniert nun

15.08.2011 TB:
-Bugfix in CPlacement: LODs funktionierten nicht bei n zu m -Zuorddnung => getetstet, funktioniert nun

13.10.2011 TB:
- Folgende neue Pluralklassen mit Smart Allocation (Vorteile sind weniger Speicherplatzverbrauch, leichter Geschwindigkeitsvorteil und Mehrfachreferenzierung):
	CLights, 
	CPlacements,
	CHardwares,
	CCameras,
	CColors
- Einfachere Methode für automatische WASD-Steuerung in CInputX (PlaceWASD)
- Veraltete Faces und Vertices-Strukturen aus CGeo inklusive ihrer Methoden gelöscht 	  

15.10.2011 TB:
- CTriangleStripIndexed in CGeoTriangleStrip umbenannt (wegen Konsistenz)
- Folgende neue Pluralklassen mit Smart Allocation (Vorteile sind weniger Speicherplatzverbrauch, leichter Geschwindigkeitsvorteil und Mehrfachreferenzierung):
	CVertices
	CGeoTriangleStrips (neu)
	CGeoTriangleLists (neu)
- Material und Farbe aus Klasse CVertex gelöscht (inklusive entsprechende Parameteraufrufe) da mit CGeoTriangleStrip- und CGeoTriangleList-Strunktur nicht mehr gebraucht

16.10.2011 TB:
- Komplett neue Struktur der Geometrie-Klassen (eleganter und konsistenter):
	CGeoTriangleStrip
	CGeoTriangleList
	CGeo
	CGeoQuad
	CGeoEllipsoid
	CGeoCube
	CGeoTetrahedron
	CGeoIcosahedron
- CGeoTriangleStrip und CGeoTriangleList sind nun jeweils von CGeo abgeleitet 
- CGeoQuad, CGeoEllipsoid sind nun jeweils von CGeoTriangleStrip anggeleitet 
- CGeoCube, CGeoTetrahedron und CGeoIcosahedron sind nun jeweils von CGeoTriangleList abgeleitet

18.10.2011 TB:
- Vereinheitlichung der Parameter der Init-Methoden von CGeoEllipsoid, CGeoCube, CGeoTetrahedron und CGeoIcosahedron
 (nun immer erst:  void Init(CHVector vSize, CMaterial * pmaterial, CApiRender *prenderapi,  ...)
- 1. Nebeneffekt: Es sind mit CGeoCube::Init nicht nur Würfel, sondern auch Quader erzeugbar
- 2. Nebeneffekt: Es sind mitCGeoTetrader::Init  nun auch "verzerrte" Tetraeder erzeugbar 
- Viele veraltete Komentare herausgenommen
- Bug in CGeo beseitigt:  Programm stürzt nun nicht mehr ab, wenn überhaupt kein Material erzeugt wurde 
- Halb-Bug in Testprogramm beseitigt: Läuft nun auch auf Rechnern mit veralterter MFC-Version 
- Version VektoriaV3 erstellt 

20.10.2011 TB:
- Umstellung der Matrizen-Pluralklasse CHMats auf Smart Allocation 
- Beseitigung eines Bugs (TriangleStrips und TriangleLists mussten mit S_GEOELLIPSOID vorinitalisiert werden, um angezeigt zu werden) => behoben
- Fertigstellung VektoriaV3

20.10.2011 (rev. 109) MS:
- Util.h für "Helfermethoden" und "Helfermarcos" eingefuehrt.
    - Rad2Deg
    - Deg2Rad
        -> Um Grad in Bogenmaß und wieder zurück zu rechnen.
- CInputX um einfache Mauseingabe erweitert.                    (untested!!!!!!!!!)
    - Zusätzlicher Konstruktor mit HWND: void Init(HINSTANCE hinst, HWND hwnd);
    - Methode: void GetMouseLocation(int& r_mouseX, int& r_mouseY); sollte die aktuelle Position der Maus zurückgeben.
    - Methode: void Fini(); gibt Maus und Tastatur wieder frei.

21.10.2011 (rev. 110) MS:
- CInputX Maus-Input erweitert (Hinweis: untested!!! -> untested Code wird erst bei Verwendung des neuen Konstruktors verwendet.)
    - System-Maus mit bis zu 8 Tasten -> (DataFormat &c_dfDIMouse2)
    - Maus Invertierbar und die Sensitivity kann angepasst werden.
        - void SetAttributes(bool a_bInvert,float a_fSensitivity);
    - Relativ und Absolute X/Y Position kann abgefragt werden.
        - float GetRelativeX(void);
        - float GetRelativeY(void);
        - float GetRelativeZ(void);
        - float GetAbsoluteX(void);
        - float GetAbsoluteY(void);
    - Mausbutton kann abgefragt werden.
        - bool MouseButtonDown(int);

24.10.2011 TB:
- Konsistenz mit MS-Version hergestellt, uns beiden scheint zur gleichen Zeit der selbe Bug bei CInputX::Tick aufgefallen zu sein ;-)

24.10.2011 (rev. 112) MS:
- CInputX -> Mit Mausrad kann nun in der Testanwendung herraus- und hineingezoomt werden. (Trotzdem noch sehr experimentell)
    - m_fSensitivity = 0.0005f; für "fast" stufenloses Scrollen! -> kann mit CInputX::SetAttributes(bool a_bInvert,float a_fSensitivity) angepasst werden.
- TODO: 
    - Beim Wechseln des Fensters wird der Input verloren... und es kann nichtsmehr eingegeben werden.
    - Manchmal fährt beim Start das Bild einfach weg!

Hinweis: Wenn Probleme auftreten einfach den alten Konstruktor (CInputX::Init(HINSTANCE hinst)) verwenden.

24.10.2011 (rev. 113) MS:
- CInputX 
    - CInputX grob getestet.
        - Mausrad = Zoom
        - Mit gedrückter Maustaste = Camera verschieben

            m_fTransZ += m_inputx.GetRelativeZ();
            if(m_inputx.MouseButtonDown(DIMOUSE_LEFTBUTTON))
            {
                m_fTransX += m_inputx.GetRelativeX();
                m_fTransY += m_inputx.GetRelativeY();
            }
            mTranslateCamera.Translate(CHVector( m_fTransX, m_fTransY, m_fTransZ,0));
            m_placementCamera.SetMat(m_placementCamera.m_mLocal * mTranslateCamera);
        
    - Bugfix Fensterwechsel fängt nun Maus und Tastatur ein.
        - if((DIERR_NOTACQUIRED == hr) || (DIERR_INPUTLOST == hr)) { m_lpDIMouseDevice->Acquire(); } hat problem gelöst.
    - Startproblem wurde auch behoben.
        - Initialisierung der DIMOUSESTATE2 Struktur hat Problem gelöst.
- VektoriaTestView.cpp
    - Debug-Console mit umgeleitetem stdout -> Mit printf kann für Testzecke auf Console geschrieben werden.
        - Falls die Console stört einfach #define DEBUG_CONSOLE oben auskommentieren.
  Hinweis: Console blockiert beim Fensterwechsel das Main-Fenster beim Maus und Tastatur einfangen.

26.10.2011 TB:
- Neue Getter und Setter-Methoden in Klasse CCamera, gestestet und funktionieren:
	void SetFov(float faMat);
	void SetNearClipping(float fNearClipping);
	void SetFarClipping(float fFarClipping);
	float GetFov();
	float GetNearClipping();
	float GetFarClipping();
- Bugfix bei der Copy-Methode von CCamera (Cameras wurden nicht vollständig kopiert)
- Vernünftige Defaultwerte bei CCamera::Init und im Konstruktor eingesetzt => Kamera funktioniert nun notfalls auch ohne expliziten Init-Aufruf
- Durch Smart Allocation sinnlos gewordene Pointer in CCamera (m_pcameraNext, m_pcameraPrev) gelöscht
- Komentare für die Intellisense hinter jede wichtige Methode von CCamera eingesetzt
- Neue Methode in CHMat:
	void Rotate(CHVector & v, float fa); // Generiert beliebige Rotationsmatrix um die Drehachse v mit Winkel fa

27.10.2011 TB:
- Neue Methode Normal() in Klasse CHVector, die einen Normalenvektor aus den aktuellen Werten erzeugt, getestet und funktioniert
- Neue Getter- und Setter-Methoden in Klasse CHVector:
	void SetX(float f); // setzt X-Wert
	void SetY(float f); // setzt Y-Wert
	void SetZ(float f); // setzt Z-Wert
	void SetW(float f); // setzt homogenen Wert
	float GetX(); // gibt aktuellen X-Wert aus
	float GetY(); // gibt aktuellen Y-Wert aus
	float GetZ(); // gibt aktuellen Z-Wert aus
	float GetW(); // gibt homogenen Wert aus
- Umstellung der Pluralklasse CHVectors auf Smart Allocation
- Durch Smart Allocation sinnlos gewordene Pointer in CHVector (m_phvectorNext, m_phvectorPrev) gelöscht
- Beschleunigung der Tetraedererzeugung durch Verwendung von Normal()-Methode
Löschen der durch die CGeoTriangleStrip und CGeoTriangleList-Klassen sinnlos gewordenen Klassen CMesh und CMeshes
- Neue Methode in Klasse CInputX:
	bool KeyPressed(int iKey); // true, falls Taste iKey (Tastaturnummer gemäß DirectX-Tastencode) gedrückt wurde, ansonsten false
- Nicht mehr benötigte Methoden in CInputX gelöscht
- Zoom in Testprogram eingebaut (Plus-Taste für hereinzoomen, Minus für  herauszoomen), sieht ziemlich warpig und spacy aus ;-)
- Neue Methode in CHMat:
	void Rotate(CHVector & vTo, CHVector & vFrom); // erzeugt eine Rotationsmatrix, die Richtungsvektor vFrom genau in die Richtung des Richtungsvektors vTo rotiert
- Directionale Placements eingebaut, dafür folgende neue Methoden:
	void SetPointing(CHVector * pvPointing); // macht, dass das Placement automatisch sich in Richtung des Raumpunkts orientiert, der durch pvPointing gegeben ist (u.a. wichitig für Kameras, die auf ein Punkt schauen sollen)
	void SetPointing(CPlacement * pplacementPointing); // macht, dass das Placement automatisch sich in Richtung des Placements orientiert, der durch pplacement gegeben ist (ua.a. wichitig für Kameras, die auf ein objekt schauen sollen)
	void SetPointingOff();
- Directionale Placements im Testprogramm anhand Kamersteuerung getestet: 
	M-Taste (M=Moon) => Kamera zeigt auf Mond
	B-Taste (B=Base) => Kamera zeigt auf Erde
	N-Taste (N=No Fixation) => Kamera ist wieder frei steuerbar
- Da Direktionalität nun wesentlich effizienter in Placements eingebaut ist, wurde alle diesbezüglichen Variablen und Parameter in CCamera und CCameras gelöscht

27.10.2011 (rev. 119 + 120 + 121) MS:
- Klasse CInputX:
    - Init Methoden public
        void Init(HINSTANCE a_hinst, HWND a_hwnd, DWORD a_dwWidth, DWORD a_dwHeight); // Initalisiert Maus und Tastatur
        void InitKeyboard(HINSTANCE a_hinst, HWND a_hwnd); // Initialisiert nur die Tastatur
        void InitMouse(HINSTANCE a_hinst, HWND a_hwnd, DWORD a_dwWidth, DWORD a_dwHeight); // Initialisiert nur die Maus
    - Init Methoden private
        bool InitDirectInput(void);                 /* initialize the main direct input interface */
        bool InitKeyboard(void);                    /* initialize the direct input interface; Set the data format; Set the cooperative level to share with other programs; Acquire the keyboard */
        bool InitMouse(void);                       /* initialize the direct input interface; Set the data format; Set the cooperative level to share with other programs; Acquire the mouse */
    - Getter und Setter für Sensitivity und Invert:
        void SetSensitivity(float a_fSensitivity=0.0005f);
        float GetSensitivity(void);
        void InvertMouse(bool a_bInvert);
    - Methoden entfernt:
        void SetAttributes(float a_fSensitivity, bool a_bInvert);
    - Destruktor ruft nun Fini() auf und gibt alle direct inputs devices wieder frei
    - Komentare für die Intellisense hinter jede wichtige Methode von CInputX eingesetzt

    - Bugfix Keyborad->Aquire() hat i-wie wieder gefehlt!


28.10.2011 TB:
- Neue (nicht unbedingt notwendige aber praktische) Methoden in CHMatimplementiert, damit lassen sich inkrementelle Änderungen von Matrizen mit nur einem Befehl beschreiben:
	void RotateXDelta(float fa);		// Generiert eine neue Rotationsmatrix um die X-Achse mit dem Winkel fa und multipliziert diese mit der aktuellen Rotationsmatrix auf 
	void RotateYDelta(float fa);		// Generiert eine neue Rotationsmatrix um die Y-Achse mit dem Winkel fa und multipliziert diese mit der aktuellen Rotationsmatrix auf 
	void RotateZDelta(float fa);		// Generiert eine neue Rotationsmatrix um die Z-Achse mit dem Winkel fa und multipliziert diese mit der aktuellen Rotationsmatrix auf
	void RotateDelta(float fx, float fy, float fz, float fa); // Generiert beliebige Rotationsmatrix um die Drehachse fx, fy, fz mit Winkel fa und multipliziert diese mit der Rotationsmatrix 
	void RotateDelta(CHVector & v, float fa); // Generiert beliebige Rotationsmatrix um die Drehachse v mit Winkel fa und multipliziert diese mit der Rotationsmatrix 
	void ScaleDelta(float fx, float fy, float fz);// Generiert Skalierungsmatrix mit drei verschiedenen Skalierungswerten und multipliziert diese mit der Rotationsmatrix 
	void ScaleDelta(float f);		// Generiert uniforme Skalierungsmatrix und multipliziert diese mit der Rotationsmatrix 
	void TranslateDelta(CHVector & v); // Generiert Verschiebungsmatrix und multipliziert diese mit der Rotationsmatrix 
- Läschen unsinniger oder nicht mehr benötigter Membervariablen in CHMat 
- Neue (nicht unbedingt notwendige aber praktische) Methoden in CPlacement implementiert, dadurch lässt sich direkt die Bewegung, Position, Rotation oder Skalierung eines Placements ändern, ohne vorher eine Matrix zu generieren und diese mit SetMat dem Placement zuweisen:
	void Unit();				// Generiert Einheitsmatrix für das Placement => Placement wird wieder auf Ursprungsposition transformiert 
	void RotateX(float fa);		// Generiert Rotationsmatrix um x-Achse mit Winkel fa für das Placement
	void RotateY(float fa);		// Generiert Rotationsmatrix um y-Achse mit Winkel fa für das Placement
	void RotateZ(float fa);		// Generiert Rotationsmatrix um z-Achse mit Winkel fa für das Placement
	void Rotate(float fx, float fy, float fz, float fa); // Generiert beliebige Rotationsmatrix um die Drehachse fx, fy, fz mit Winkel fa für das Placement
	void Rotate(CHVector & v, float fa); // Generiert beliebige Rotationsmatrix um die Drehachse v mit Winkel fa für das Placement
	void Rotate(CHVector & vTo, CHVector & vFrom); // erzeugt eine Rotationsmatrix, die Richtungsvektor vFrom genau in die Richtung des Richtungsvektors vTo rotiert für das Placement
	void Scale(float fx, float fy, float fz);// Generiert Skalierungsmatrix mit drei verschiedenen Skalierungswerten für das Placement
	void Scale(float f);		// Generiert uniforme Skalierungsmatrix für das Placement
	void Translate(CHVector & v); // Generiert Verschiebungsmatrix für das Placement
	void RotateXDelta(float fa);		// Generiert Rotationsmatrix um x-Achse mit Winkel fa und multipliziert diese mit der Rotationsmatrix des Placements => Placement wird um Winkel fa um die X-Achse weitergedreht 
	void RotateYDelta(float fa);		// Generiert Rotationsmatrix um y-Achse mit Winkel fa und multipliziert diese mit der Rotationsmatrix des Placements => Placement wird um Winkel fa um die Y-Achse weitergedreht 
	void RotateZDelta(float fa);		// Generiert Rotationsmatrix um z-Achse mit Winkel fa und multipliziert diese mit der Rotationsmatrix des Placements => Placement wird um Winkel fa um die Z-Achse weitergedreht 
	void RotateDelta(float fx, float fy, float fz, float fa); // Generiert beliebige Rotationsmatrix um die Drehachse fx, fy, fz mit Winkel fa und multipliziert diese mit der Rotationsmatrix des Placements => Placement wird um Winkel fa um die DrehachseAchse weitergedreht 
	void RotateDelta(CHVector & v, float fa); // Generiert beliebige Rotationsmatrix um die Drehachse v mit Winkel fa und multipliziert diese mit der Rotationsmatrix des Placements => Placement wird um Winkel fa um die DrehachseAchse weitergedreht 
	void ScaleDelta(float fx, float fy, float fz);// Generiert Skalierungsmatrix mit drei verschiedenen Skalierungswerten und multipliziert diese mit der Rotationsmatrix des Placements => Placement wird um fx,fy un fz größer
	void ScaleDelta(float f);		// Generiert uniforme Skalierungsmatrix und multipliziert diese mit der Rotationsmatrix des Placements => Placement wird um Fakto f größer
	void TranslateDelta(CHVector & v); // Generiert Verschiebungsmatrix für das Placement => Placement wandert um v weiter
- Viele nicht notwendige Warnmeldungen beim Compilieren eliminiert

30.10.2011 TB:
- Viele neue Utility-Makros in Utils.h eingefügt:
		// Einfache Matehemakros:
		#define UMAbs(f)(f<0? -(f):(f))
		#define UMHeavyside(f) (f<0? 0:1)
		#define UMSign(f) (f<0? -1:1)
		#define UMThreshold01(f,fThreshold) (f<fThreshold? 0:1)
		#define UMThresholdLinear(f,fThreshold) (f<fThreshold? 0:(f-Threshold))
		#define UMBlob(f) ((f)<1.0F? (1.0F-((f)*(f))*((0.444444444F*(f)*(f)-1.888888888F)*(f)*(f)+2.444444444F)): 0.0F)	// See An Efficient and Controllable Blob Function (Baranoski,Gladimir + Rokne,Jon)
		#define UMTunableBlob(r,f,d) {if(f<1.0F) {float ff=f*f;float ff1=ff-1.0F;r=(ff1*ff1)/(1.0F+d*ff);}else{r=0.0F;};};	// See An Efficient and Controllable Blob Function (Baranoski,Gladimir + Rokne,Jon)
		#define UMQuickBlob(r,f) {if(f<1.0F) {float ff1=f*f-1.0F;r=ff1*ff1;}else{r=0.0F;};};	// See An Efficient and Controllable Blob Function (Baranoski,Gladimir + Rokne,Jon)
		#define UMSquareBlob(r,ff) {if(ff<1.0F) {float ff1=ff-1.0F;r=ff1*ff1;}else{r=0.0F;};};	// See An Efficient and Controllable Blob Function (Baranoski,Gladimir + Rokne,Jon)

		// Vergleichsmakros:
		#define	UMIsZero(f)	((f>= -QUASI_ZERO)&&(f<= QUASI_ZERO))
		#define	UMIsNotZero(f) ((f< -QUASI_ZERO)||(f> QUASI_ZERO))
		#define	UMIsSimilar(f1,f2) ((f2-f1>= -QUASI_ZERO)&&(f2-f1<= QUASI_ZERO))
		#define	UMIsInOrb(f1,f2,fOrb) ((f2-f1>= -fOrb)&&(f2-f1<= fOrb))

		// Wertebereichsmakros:   Range = [Min .. Max] 
		#define	UMSetRange(f,fMin,fMax) {if(*f<fMin){*f = fMin;}; if(*f >fMax){*f = fMax;};}
		#define UMIsRange(f,fMin,fMax) ((f>=fMin)&&(f<=fMax))
		#define UMIsNotRange(f,fMin,fMax) ((f<fMin)||(f>fMax))
		#define	UMSetRangeFr(fr) {if(fr<0.0F){fr = 0.0F;}; if(fr >1.0F){fr = 1.0F;};}

		// Makris für zyklische Wertebereiche:   Span = [Min .. Max) 
		#define	UMRotSpan(pi,iMin,iMax)	{while(*pi < iMin){*pi += (iMax-iMin);}; while(*pi >= iMax){*pi -= (iMax-iMin);};}
		#define	UMSetSpan(pf,fMin,fMax) {if(*pf<fMin){*pf = fMin;}; if(*pf >=fMax){*pf = fMax-1;};}
		#define	UMSet0Span(pf,fMax) {if(*pf<0){*pf = 0;}; if(*pf >=fMax){*pf = fMax-1;};}
		#define UMIsSpan(f,fMin,fMax) ((f>=fMin)&&(f<fMax))
		#define UMIsNotSpan(f,fMin,fMax) ((f<fMin)||(f>=fMax))
		#define	UMPush0Span(pi,iMax)	{if(*pi<0){*pi += iMax;}; if(*pi>=iMax){*pi -= iMax;};}
		#define	UMRotSpanFa(fa)	{while(fa<0.0F){fa += ZWOPI;}; while(fa>=ZWOPI){fa -= ZWOPI;};}

		// Zufallsmakros: 
		#define	UMRandomContext(l1,l2,l3) UMAbs((float)(l1*UM_PRIM1*(3-l2)*(7-l3)+(11-l1) * UM_PRIM6 + l2*UM_PRIM4*(3-l1)*(7+l3)+(11+l2) * UM_PRIM7 + l3* UM_PRIM3*(17+l1)*(7-l2)) % UM_PRIM5)/UM_FPRIM5)
		#define	UMRandomize(iClock) {um_last = iClock%UM_PRIM4+UM_PRIM4}
		#define	UMRandomLinear(fRandom,iRandom) {iRandom = ((iRandom*UM_PRIM1+iRandom*UM_PRIM3+UM_PRIM5)%UM_PRIM4); fRandom = ((float)(iRandom)/(float)UM_FPRIM4);}
		#define	UMRandomLinearPN(fRandom,iRandom) {iRandom = ((iRandom*UM_PRIM1+iRandom*UM_PRIM3+UM_PRIM5)%UM_PRIM4); fRandom = ((float)(iRandom)/(float)UM_FPRIM4)*2.0F-1.0F;}
		#define	UMRandomRadial(fRandom,iRandom) {UMRandomLinear(fRandom,iRandom);fRandom *= fRandom;}
		#define	UMRandomRadialPN(fRandom,iRandom) {UMRandomLinearPN(fRandom,iRandom);fRandom<0? fRandom *= -fRandom:fRandom *= fRandom;}

01.11.2011 (rev. 125) MS:
- CInputX: Joystick/Gamepad vorläufig eingebaut und auch schon kurz getestet
    - EnumDevsCallback wird für jedes angesteckte Joystick-Device aufgerufen (auch Gamepad usw...)
        - Bis jetzt wird nur das zuletzt gefundene device verwendet. -> sollte noch weiter ausgebaut werden und eine Liste aller devices führen.
    - float GetRelativeJoystickX() bzw. float GetRelativeJoystickY() gibt die relative bewgung des joysticks zurück. (getestet und läuft, muss aber noch konfiguriert werden)

03.11.2011 (rev. 126, 127) MS:
- CDIDevice:            Als Basisklasse für alle Direct Input Devices
    - Vererbt wichtige Methoden wie:
        void SetHWND(HWND hwnd); // The the HWND to which the game controller will be attached
	    void SetHINSTANCE(HINSTANCE hinst);
	    void SetDirectInput(LPDIRECTINPUT8 lpDI);
        void SetDIDeviceInfo(LPCDIDEVICEINSTANCE lpDIDeviceInfo);
        bool IsDeviceInitialized(void);
- CDIKeyboard:          Klasse repräsentiert das System-Keyboard und erbt von CDIDevice
- CDIMouse:             Klasse repräsentiert die System-Maus und erbt von CDIDevice
- CDIGameController:    Klasse repräsentiert alle restlichen Game Controller mit und ohne Force Feedback (Joystick, Lenkrad, Gamepad, etc.) und erbt von CDIDevice
    - Bereits angelegt und teilweise implementiert, aber noch nicht fertig
- CInputX:              Auf neue Klassenstruktur umgerüstet
    - Aufruf der Keyboard- und Maus-Methoden über:
        inputx.GetKeyboard()->KeyPressed(DIK_M);
        inputx.GetMouse()->GetRelativeZ();

04.11.2011 (rev. 128) MS:
- Endlich das Absturtzproblem bei angestecktem Game-Controller behoben.

11.11.2011 (rev. 129) MS:
- BlenderImporter.h und BlenderImporter.cpp begonnen.
	- bool ReadFile(const char* acPath, char** acFileData); -> Zum Lesen des .blend files in den Speicher.
	- Diverse Strukturen fürs Parsen angelegt.

17.11.2011 TB:
		Chroma Keying funktioniert jetzt, Chroma Key ist linkes oberes Pixel
		Chroma Keying mit intelliegentem Rand-Antialiasing
		Einiger "Codemüll" in Klasse CThing gelöscht

23.11.2011 (rev. 130) MS:
- Util.h erweitert
	Rad2Deg(X) // converts radians to degrees, M_PI is the value of pi and is defined in math.h library
	Deg2Rad(X) // converts degrees to radians 

	IRAND(a, e) // get integer random number in range a <= x <= e
	PERCRAND(perc) // return true perc % of the time

01.12.2011 (rev. 133) MS:
- Util.h alles Macros groß geschrieben
- BlenderImporter.h, BlenderImporter.cpp
	- char* ReadFile(char* acPath, int* iLength); // Öffnet das .blend file und liest es.
	- int ParseFileHeader(char* acData, FILEHEADER* fileHeader); // Parse file header and returns pos of the fist file block
	- int ParseFileBlock(char* acData, FILEBLOCK* fileBlock, int pointerSize, int offset); // Parse file block and returns position of the next file block
	Implementiert und getestet!

01.12.2011 (rev. 134) MS:
- Util.h zwei neue Macros
	ALIGN_UP(addr, size) (((addr)+((size)-1))&(~((size)-1))) // align addr on a size boundary - adjust address up if needed
	ALIGN_DOWN(addr, size) ((addr)&(~((size)-1))) /// align addr on a size boundary - adjust address down if needed
- BlenderImporter.h, BlenderImporter.cpp
	- Parser soweit fertig und getestet!!! juhu!!! Neue Funktion:
		- int ParseDNAStructure(char* acData, DNA* dna); // Parse the 'DNA1' file-block containing all internal structures of the Blender release the file was created in. Structure DNA is stored in a file-block with code 'DNA1'. It can be just before the 'ENDB' file-block.>>>>>>> .r134

02.12.2011 TB:
		Erster rudimentärer Geometry-Importer für X3D ist integriert (funktioniert bis jetzt auch nur bei kleineren Geometrien, Hierarchien werden noch nicht richtig eingelesen)
		(Achtung! Blender hat einen Fehler, das Modellierungsprogramm übermittelt weder die Normalenvektoren noch das UV-Mapping beim Exportieren in das X3D-File 
		=> Prognoseprogramm für Normalenvektoren => Importierte Geometrien aus Blender sehen ziemlich daneben aus) 
		X3D-Testfile (Aus Blender importierter gebevelter Würfel wird in die Testszene geladen)
		Vektoria Logo-Icons in 9 verschiedenen Formaten erstellt, für die Verschönerung des Testprogramms und die Vektoria SDK Application

02.12.2011 (rev. 140, 141, 142) MS:
- Util.h aufgeräumt
- Klasse CFileBlender angeleget: soll später wie CFileX3D funktionieren
    - Parser für .blend files eingebaut und getestet
        - Freigabe des allocierten speichres im destruktor
        - Riesen Bugfix in ParseDNAStructure()
        - .blend file zum testen hinzugefügt
- dafür BlenderImporter.h und BlenderImporter.cpp gelöscht

03.12.2011 TB:
	Ein Bug in Geometry-Importer für X3D gefixt (erster Vertex wurde immer auf 0 gesetzt)
	Folgende Methoden in CViewport können jetzt auch nach der Initialisierung des Viewports aufgerufen werden => Dadurch Umschalten während der Laufzeit möglich (z.B. auf Wireframe):
		void SetBackfaceCullingOn();
		void SetBackfaceCullingOff();
		void SetAntialiasingOn();
		void SetAntialiasingOff();
		void SetWireframeOff();
		void SetWireframeOn();
	Testmethode für Wireframe in Testprogramm eingebaut (Taste X = Wireframe, Taste Y = Solid)

04.12.2011 TB:
	Geometry-Importer für X3D kann jetzt auch IndexedFaceSets laden
	Monkey.x3d als Beispiel für IndexedFaceSets geladen
	Bessere Prognose fürs UV-Mapping und Normalen (gibt ja Blender dummerweise nicht mit aus) 
	78 Warnings ausgemerzt
	Klasse CQuaternions auf Smart Allocation umgestellt => Bessere Speicherausnutzung bei gleichzeitiger Beschleunigung
	Durch Smart Allocation sinnlos gewordene Pointer in CQuaternion (m_pquaternionNext, m_pquaternionPrev) gelöscht

05.12.2011 (rev. 149, 150)  MS:
    Weiße Punkte vom Icon entfernt.
    Neues Projekt VektoriaApp angelegt. (Zum Ausprobieren einfach Rechtsklick auf das Projekt "VektoriaApp" und als "Startprojekt festlegen" auswählen)
        Was gibt's darin tolles:
        - Fullscreen mittels WINAPI realisiert. (Spart btw. auch die ganzen MFC View, Doc sachen)
        - Das Fenster kann momentan nur mittels Alt + Tab wieder verlassen werden.
        Demnächst werd ich noch einen Togglemodus für fullscreen/windowed einbauen.

07.12.2011 (rev. 154) MS:
	VektoriaApp -> ESC zum beenden des programms 
	-> testweise fullscreen/windowed toggle modus (ALT + ENTER)

07.12.2011 FS:
	- StructuredBuffer angelegt und mit ResourceView auf programmierbare Shader gemappt.
		- Dieser beinhaltet in Zukunft bis zu 100 dynamische und statische Lichtquellen.
		- Später werde ich einen zweiten Buffer anlegen und zwischen dynamischen und statischen Lichtquellen unterscheiden um Bus zu entlasten.
	- Pixelshader angepasst, Buffer aus register geladen und Berechnung für mehrere Lichter angepasst.
	- CLight, CLights, CLightRadial, CLightRadials, CLightParallel, CLightParallels implementiert.
	- Diverse Anpassungen der Architektur um mehrere Lichtquellen zu ermöglichen.

08.12.2011 FS:
	- LightParallel in den Szenengraph integriert.
	- Hinzufügen über Scene->AddLightParallel(...)
	- LightParallels: Add-Methode, zum Hinzufügen einzelnert Lichter, implementiert.
	- Verbesserte Arbeitsteilung von Pixel- und Vertexshader für die Berechnung des Lichts.
	- Punklichter erzeugen jetzt auch specular highlights.

09.12.2011 FS:
	- Objekte werden jetzt nur mit den Lichtquellen gerendert welche konfiguriert sind - dies soll später automatisch geschehen.
	- Mond wird jetzt (siehe Objekt-Konfiguration in VektoriaTestView) beispielsweise nur von dynamischen Licht beeinflusst.
	- Lichtquellen sind jetzt aus- und einschaltbar.
	- Shader überarbeitet.
	- Verantwortlichen für Performanceeinbußen gefunden, deaktivieren des Nebels gibt statt 15fps -> 32 fps.

10.12.2011 TB: 
	Quaternionenklasse jetzt fast fertig, folgende Methoden/Operanten implementiert:
		CQuaternion(float fx, float fy, float fz, float fw);
		CQuaternion operator=(CQuaternion quaternion);
		void Copy(CQuaternion quaternion);
		bool operator==(CHVector & hvector); // Vergleich zweier Quaternionen auf Gleichheit
		bool operator!=(CHVector & hvector); // Vergleich zweier Quaternionen auf Ungleichheit
		CQuaternion operator*(CQuaternion & q); // Quaternionenmultiplikation
		CQuaternion operator+(CQuaternion & q); // Quaternionenaddition
		CQuaternion operator-(CQuaternion & q); // Quaternionensubtraktion
		void Init(float fx, float fy, float fz, float fw);
		void Fini();
		void Norm(); // normiert Quaternion
		float Length(); // gibt den Betrag des Quaternions aus
		void RotateX(float fa);		// Generiert Rotationsquaternion um x-Achse mit Winkel fa
		void RotateY(float fa);		// Generiert Rotationsquaternion um y-Achse mit Winkel fa
		void RotateZ(float fa);		// Generiert Rotationsquaternion um z-Achse mit Winkel fa
		void Rotate(float fx, float fy, float fz, float fa); // Generiert beliebiges Rotationsquaternion um die Drehachse fx, fy, fz mit Winkel fa
		void Rotate(CHVector & v, float fa); // Generiert beliebiges Rotationsquaternion um die Drehachse v mit Winkel fa
		void Rotate(CHVector & vTo, CHVector & vFrom); // erzeugt ein Rotationsquaternion, die Richtungsvektor vFrom genau in die Richtung des Richtungsvektors vTo rotiert
		void Lerp(CQuaternion qFrom, CQuaternion qTo, float fr);
		void Slerp(CQuaternion qFrom, CQuaternion qTo, float fr);
		CHVector GetVector(); // holt XYZ und schreibt ihn in den Vektor, der homogene Faktor wird auf 0 gesetzt
		void SetVector(CHVector  & v); // Setzt XYZ des Quaternions auf die Werte des Vektors, w wird auf 0 gesetzt
		void SetX(float f); // setzt X-Wert
		void SetY(float f); // setzt Y-Wert
		void SetZ(float f); // setzt Z-Wert
		void SetW(float f); // setzt rationalen Wert
		float GetX(); // gibt aktuellen X-Wert aus
		float GetY(); // gibt aktuellen Y-Wert aus
		float GetZ(); // gibt aktuellen Z-Wert aus
		float GetW(); // gibt rationalen Wert aus
	Klasse HVector etwas aufgeräumt, vor allem alte unbenutzte Variablen in Klasse gelöscht
	Etwas herumprobiert wegen Geschwindigkeitsproblem von Flo, seltsam: Ausklammern von Billboard-Nebel bringt bei mir im Gegensatz zu Flo keine bzw. nur marginale Geschwindigkeitsbeschleunigung (101 fps auf 102 fps), seltsam
	Bug in shaders.hlsl gefixt

13.12.2011 FS:
	- Shader debuggt, ca 30% Leistungseinbußen durch Unterstützung mehrerer Lichtquellen.
	- Konnte keinen wirklichen Flaschenhals finden ... genaueres am Mittwoch.
	- Es werden jetzt Lichtquellen-Referenzen, anstatt Indexe, zu jedem Objekt gespeichert.
	- Implementierung eines Licht-Benchmarks.

13.12.2011 TB:
	- Zerschossene Icons wiederhergestellt und nachgemalt, hässliche weiße Punkte raus, Schatten verbessert
	- Precompiler_Flags in Testprogramm eingefügt, um ganze Codeabschnitte schnell herauszunehmen:
		- B_NEBULA	Hiermit kann man den Nebel ein- und ausschalten
		- B_SUNS	Hiermit kann man die Testlichter von Tobi ein- und ausschalten (Testlichter koennen spaeter komplett raus) 
		- B_X3D		Hiermit kann man die Einlese und die Anzeige des X3D-Affen ein- und ausschalten
	- Bug in CDIKeyboard gefixt (Beim ersten Tick  gaben Methoden fälschlicherweise an, dass alle Tasten gedrückt wären)
	- Kleinere Verbesserungen in  CDIKeyboard 
	- Halb-Fullscreen-Mode integriert (durch Drücken der Taste 'O' wird's Halbfullscreen, mit 'I' wird Fenster wieder klein)

15.12.2011 FS:
	- Für jedes Objekt werden jetzt Distanzen zu den Lichtquellen berechnet und diese in absteigender Reihenfolge sortiert.
	- Die ersten vier Lichter werden mit dem Objekt verknüpft und dann auf der Grafikkarte berechnet.
	- Derzeit recht hohe Leistungseinbußen, können allerdings durch Octrees verringert werden.
	TODO:	- Lichter werden derzeit nur nach Entfernung bzw ihrer Intensität bewertet.
			- Zusätzlich sollten sie auch noch danach bewertet werden, wie viel der Betrachter von ihnen sieht.

15.12.2011 TB:
	- Einige Bugs aus HQuaternions gefixt
	- Klasse Quaternionen hat folgende neue Methoden bzw. Operatoren:	 
		void Conjugate(); // Konjugiert Quaternion
		CQuaternion operator*=(CQuaternion & q); // Quaternionenmultiplikation -Schnelloperator
		CQuaternion operator+=(CQuaternion & q); // Quaternionenaddition -Schnelloperator
		CQuaternion operator-=(CQuaternion & q); // Quaternionensubtraktion -Schnelloperator
		CQuaternion operator*(float f); // Skalarprodukt (Quaternionenskalierung durch Multiplikation, rechts)
		CQuaternion operator/(float f); // Skalardivision (Quaternionenskalierung durch Division, rechts)
		CQuaternion operator*=(float f); // Quaternionenskalierung durch Multiplikation -Schnelloperator
		CQuaternion operator/=(float f); // Quaternionenskalierung durch Division -Schnelloperator
		CHMat GetMatrix(); // Generiert Rotationsmatrix aus Quaternion und gibt sie aus
		void SetMatrix(CHMat & m); // Generiert Quaternion aus der Raotationsmatrix m
	- Fullscreen-Modus verbessert (zumindest erscheinen jetzt nicht mehr die Ränder, Taskleiste bleibt aber noch dummerweise sichtbar, werde es weiter versuchen)

15.12.2011 TB:
	- Vollbild-Modus funzt jetzt. :-)
	- Bug in CHVector::Norm gefixt (Absturz bei Übergabe von HVector = 0,0,0,0)
	- Bug in CHVector::Rotate(vFrom, vTo) gefixt (keine seltsamen Werte mehr bei (vFrom == vTo) 
	- Bug in PlaceWASD (Kamerasteuerung) gefixt (Kamera rotiert jetzt überall richtig, auch hinter Erde)
	- PlaceWASD vereinfacht und beschleunigt
	- Neue Methoden in Klasse DIKeyboard:
		void SetTranslationSensitivityWASD(float fTranslationSensitivity); // Setzt die Empfindlichkeit (Schnelligkeit) bei den WASD-Tasten in Einheiten / Sekunde für PlaceWASD 
		void SetRotationSensitivityWASD(float fRotationSensitivity); // Setzt die Empfindlichkeit (Schnelligkeit) bei den Pfeil-Tasten in Bogenmaß / Sekunde für PlaceWASD
		float GetTranslationSensitivityWASD();
		float GetRotationSensitivityWASD();

19.12.2011 (rev. 179) MS:
	- VektoriaTest: Klasse CGame die nun die Vektoria-Objekte kapselt erstellt:
		Game 	Init(...)
			Tick(...)
			Fini(...)
			ResizeWindow(...)
		Solle mehr Übersicht verschaffen und kann nun auch in anderen Anwendungen verwendet werden.

	- TODO's
		-> Mauseingabe will nicht mehr so richtig -> hängt vllt mit einer Änderung in Keyborad oder PlaceWASD zusammen??? (TODO)
		-> Funktioniert CalcFR() noch richtig??? (TODO)

	(Zum Vollbildmodus: Das Fentser einfach so zu vergrößern könnte evtl. noch Probleme verursachen, 
		da bei meinem System (mehrere Monitore) auf dem zweiten Monitor der Rand des Fensters zu sehen ist)

22.12.2011 TB:
	- Makronamen in Util.h gemäß unserem vorletzten Mittwochabendgespäch vereinheitlicht und groß gemacht
	- Lange ausgetestet, ob esoterischer Mörderbug (Erde-weg) tatsächlich verschwunden ist, schein so zu sein. Danke Matthias! :-)
	- Angefangen, Game.h, Game.cpp, VektoriaTestView.h, VektoriaTestView.cpp, MainFrame.h und MainFrame.cpp aufzuräumen, wird aber noch länger dauern
	- Aussehen der Asteroiden verbessert

22.12.2011 FS:
	- Astereoiden werden komisch beleuchtet, rührt daher, dass nur fünf Geometrien erstellt werden.
	  Lichter werden allerdings zu den Geometrien gespeichert -> Konzept überdenken?!
	- Warnungen aus der Bibliothek entfernt sowie die Connection-Klasse, diese liegt selbstverständlich noch im SVN.
	- Compiler Einstellungen korrigiert und stdafx aktualisiert.

05.01.2011 FS:
	- Shader werden jetzt auf Shader Model v4.1 kompiliert. 4.0 Unterstützt nur 16 Output-Parameter, während .1 bis zu 32 benutzt.
	  Musste ich aufgrund der Weitergabe der Lichtquellen (von VS zu PS) erhöhen.
	  TODO: Alternative finden.
	- Lichter können jetzt in verschiedenen Farben leuchten.
	- Testprogramm mit Compilerflag geschrieben um die korrekte Funktionsweise der Lichter zu untersuchen.

06.01.2012 TB:
	- Klasse Game weiter aufgeräumt (unbenutzte Variablen gelöscht, bessere Benennung der verbliebenen Variablen, Schnelloperatoren beim Erdplacement)
	- Neue Methode in Klasse CQuaternion:
		CHVector ApplyRotation(CHVector & v); // Rotiert Punkt v mit Hilfe des Rotationsquaterions v und gibt Ergebnis als Returnwert aus

09.01.2012 MS:
    - CFileBlender kann nun die Vertieces richtig auslesen. Die Erzeugung der Geometrie fehlt noch.
    - Probleme beim Lesen von 64-Bit Files: Bis jetzt können nur 32-Bit Files gelesen werden.
    - Precompiler-Flag B_BLENDER: mit diesem Flag kann man den Blender-Würfel komplett ein- und ausschalten. (Wichtig nicht zusammen mit Affen verwenden!)

10.01.2012 TB:
	- Vektoria-Logo im Testprogramm erscheint jetzt auch in linker oberer Ecke
	- Bug nach Vollbild-Modus entfernt (Fenster war nicht mehr resizeable)
	- Neue SDK-Version etrstellt (VektoriaV4)
	- Neues Template erstellt (VektoriaV4App)

12.01.2012 (rev. 200, 201, 202, 203) MS:
    - CFileBlender funktioniert nun testweise: 
        - Import von einzelnen Meshes möglich!
            - Keine unterstützung von 64-Bit files
            - UV Mapping wird noch nicht richtig unterstützt (TODO)
            - Tangentenvektoren für evtl. Bumpmapping werden noch nicht berechnet
    - Neuen Ordner "imports" für files zum importieren angelegt
    - .blend Testfiles hinzugefügt: monkey_x86.blend, cube_x86.blend, untitled.blend (32- / 64-Bit version), cube_uv.blend

13.01.2012 FS:
	- Precompiler-Flags für Directx Debugging.
	- Lichter werden jetzt auch für mehrfach im Szenengraph verlinkte Geometrien richtig berechnet.
	TODO:	- Im Shader muss die Eye-direction noch berechnet werden.
			- Szenengraph prepass um Shadow-Map zu berechnen.
			- Performanceeinbruch durch neuen Shader untersuchen.
	- Shader überarbeitet:
		- Vertexshader verwendet weniger output-register.
		- Licht verwendet jetzt gängige Berechnung für Reichweite (konstante-, lineare- und quadratische Schwächung).
	- Lichttest überarbeitet, es werden keine Lichter mehr in die Erde gesetzt.
	  Farbe und Position werden korrekt und zufällig bestimmt.

22.02.2012 FS:
	- Beginne mit dem Erstellen des Lichttyps "Spotlight" und der Pluralklassen.

23.02.2012 FS:
	- Erste Programmieransätze des Shadowmappings.
	  Erstellen des Depth Stencil, schreiben eines einfachen Shaders (für Punktlichter).
	  Diverse Anpassungen.
	- Vollständige Integrierung des Lichttyps "Spotlight".
	- Testfall B_SPOT_LIGHTS kann benutzt werden um die Implementierung zu testen.
	TODO:	- Shader auf Performance optimieren.
			- Decay Exponent des Spotlights verwenden.
			- Shadowmapping für Spotlights ermöglichen.

23.03.2012 TB:
	- Eye-Vektor wird jetzt korrekt berechnet => Highlights funktionieren nun korrekt
	- Licht funktioniert nun auch im Testprogramm 
	- Spotlichter funktionieren nun auch für variable Viewport-Auflösungen

24.03.2012 TB:
	- Schatten funktionieren nun auch im Testprogramm
	- Variable Auflösungen funktionieren jetzt auch mit Schatten

25.03.2012 TB:
	- Einige kleine Änderungen zur Polnischen Datentypennotation in CLight, CLightRadial, 

29.03.2012 TB:
- Folgende neue Pluralklassen mit Smart Allocation (Vorteile sind weniger Speicherplatzverbrauch, leichter Geschwindigkeitsvorteil und Mehrfachreferenzierung):
	CViewports, 
	CScenes
- Veraltete Kommentare in Klasse CDirect gelöscht 
- Neue Struktur der Klasse CViewport (Viewport kann jetzt innerhalb eines Fensters positioniert werden
- Unnötige Initialisierungsaufrufe im Testprogramm gelöscht
- Resizing funktioniert nun (auch für Schatten)
- Einige Variablen in CDirectX gemäß polnischer Datentypennotation umbenannt
- Description-Variablen als Membervariablen gemacht => müssen nicht mehr neu gesetzt werden => leichte Beschleunigung 
- Maus-Bug im Testprogramm ausgesetzt

30.03.2012 TB:
- Anfang von großem Komplettumbau der Klasse CDirectX (bisherige Struktur ist nicht geeignet, mehrere Viewports gleichzeitig zu betreiben)

31.03.2012 TB:
- Mehrere Viewports in einem Fenster nun möglich (z.B. für SplitScreen, In-Screens o.ä.)
  dafür ist Komplettumbau der Klasse CDirectX im vollen Gange (bisherige Struktur war nicht geeignet, mehere Viewports gleichzeitig zu betreiben)
	Halbwegs lauffähige Zwischenversion hochgeladen (Frame Rate lässt noch zu wünschen übrig)
- Neue Klassen:
	CFrame
	CFrames (mit Smart Allocation)
- Neue Methoden in CViewport:
	void InitFull(CCamera * pcamera); // Initialisiert Viewport, so dass er das gaze Frame ausfüllt
	void Init(CCamera * pcamera, float frx, float fry, float frWidth, float frHeight); // Initialisiert Viewport mit relativen Maßen zum Frame
	void ReSize(float frx, float fry, float frWidth, float frHeight); // Verändert relative Größe des Viewports zum Frame
	void ReSize(); // Verändert Größe des Viewports bei Veränderung der Größe des Frames
	void CalcSize(); // Berechnet absolute Ausmaße des Viewports
- Bug beim Windows-Resizing gefixt (bei einer Fensterhöhe von Null schmierte Programm ab)
	 

03.04.2012 TB:
- Klasse DirectX aufgeräumt 
	- sinnfälligere Methodennamen gegeben, 
	- Variablen konsequent in polnische Notation umgewandelt 
	- unbenutzte Variablen gelöscht
	- Veraltete Komentare gelöscht 
	- einige redundante Aufrufe gelöscht => leichte Beschleunigung
- Bugfix: SetBackfaceCulling() hatte sich nicht mehr aufs Rendering ausgewirkt
- Dynamische Allokierung der Viewports => beliebig viele Viewports möglich  
- Folgende neue Methoden in Klasse CViewport eingefügt (getestet, funktioniert):
	void SetShadowRenderingOn(); // Schaltet Schatten für den Viewport an (Default: an) 
	void SetShadowRenderingOff(); // Schaltet Schatten für den Viewport aus (Default: an) 
	void SetLightRadialRenderingOn(); // Schaltet Punktlichter für den Viewport an (Default: an) 
	void SetLightRadialRenderingOff(); // Schaltet Punktlichter für den Viewport aus (Default: an) 
	void SetLightParallelRenderingOn(); // Schaltet Parallellichter für den Viewport an (Default: an) 
	void SetLightParallelRenderingOff(); // Schaltet Parallellichter für den Viewport aus (Default: an) 
	void SetLightSpotRenderingOn(); // Schaltet Schweinwerferlichter für den Viewport an (Default: an) 
	void SetLightSpotRenderingOff(); // Schaltet Scheinwerferlichter für den Viewport aus (Default: an) 

04.04.2012 TB:
- Stereoskopische Kameras einfach möglich durch neue Methode in CPlacement:
	void MakeStereoscopicCameras(CCamera *pcameraLeftEye, CCamera *pcameraRightEye, float fEyeDistance, float fFocusDistance, float faFov=2.0F, float fNearClipping=0.1F, float fFarClipping=1000.0F); //Erzeugt eine komplexe Struktur aus drei Placements und zwei Kameras für Stereoskopie
- Stereoskopisches Schielbild zum Testen in VektoriaTest eingebaut (schielen bis Bilder miteinander verschmelzen, mitteres Bild ist stereoskopisch, Effekt besonders gut, wenn man auf M gedrückt hat)
- Einige veraltete Komentare im Testprogramm gelöscht 
- Starke Beschleunigung des Testprogramms (FR erhöhte sich bei mir um ca. 50%) durch Verschiebung der Initialisierungsmethode von DirectInput in die Init-Methode, wo sie auch hingehört
- Pointing-Attribut eines Placements wirkt sich nun auch auf die darunterliegenden stereokopischen Placements aus => Bessere Fokussierung eines Objekts 

05.04.2012 TB:
- Neue Methoden in CPlacement eingefügt:
	bool SubGeo(); // Hängt die Geometrie wieder von dem aktuellen Placement ab, gibt true aus, wenns geklappt hat
	bool SubSound(); // Hängt den 3D Sound wieder von dem aktuellen Placement ab, gibt true aus, wenns geklappt hat
	bool SubCamera(); // Hängt die Kamera wieder von dem aktuellen Placement ab, gibt true aus, wenns geklappt hat
	bool SubPlacement(CPlacement * pplacement); // Hängt das Unterplacement wieder von dem aktuellen Placement ab, gibt true aus, wenns geklappt hat
	void KillStereoscopicCameras(); // Eleminiert die aufgebaute Struktur für stereoskopische Kameras 
	void SetStereoscopicParameters(float fEyeDistance, float fFocusDistance); // Verändert die Parameter der stereoskopischen Struktur, wenn vorhanden
	bool GetStereoscopicParameters(float & fEyeDistance, float & fFocusDistance); // Gibt die Parameter der stereoskopischen Struktur zurück, gibt true aus wenn vorhanden
- Veränderung des stereoskopischen Augenabstandes in das Testprogram eingefügt (Taste Z macht Augenabstand größer, Taste U macht Augenabstand kleiner)
- Sinnlose bzw. veraltete Methoden und Variablen in Klasse CColor und CColors gelöscht, neue Komentare für die Intellisense eingefügt 
- Sinnlose bzw. veraltete Methoden und Variablen in Klasse CVertex und CVertexs gelöscht
- Pluralklasse CTextures in SmartAllocation umgewandelt
- Methode CTexture aufgeräumt (sinnlose veraltete Methoden und Variablen gelöscht)
- Neue Methoden in Pluralklasse CTextures:
	bool Sub(CTexture * ptexture); // Hängt Textur von Hierarchie ab
	bool Kill(CTexture * ptexture); // Vernichtet Textur
- Man kann nun an zwei verschiedene Materialien ein und dieselbe Textur dranhängen (ging vorher nicht) 

06.04.2012 TB:
- NullRenderer eingefügt
- FAQ-Dokument angefangen
- Veraltetete Image-Links aktualisiert
- Bugfix: Seltsame Artefakte bei In-Screens sind nun Vergangenheit
- Bugfix: kenne verzerrt dargestellten Bilder bei einigen Auflösungen mehr 


09.04.2012 TB:
- Bugfix: Long Avg. Frame Rate im Testprogramm wird jetzt richtig berechnet


19.04.2012 TB:
- Erweiterung der Klasse CViewport um Stile (aktuelle Projektgruppe braucht Cartoon-Shading für ihr Spiel, daher dieser Prio3-Task vorgezogen), dafür folgende Methoden implementiert:
	void CViewport::SetStyle(int eStyle); // Schaltet bestimmten Rendering-Stil an, die Stile sind kombinierbar 
	void CViewport::SetStyleTheshold(float frStyleThreshold); // Gibt den fraktionalen Grenzwert für den Renderingstil an, Default = 0.5
	void CViewport::SetColor(CColor & color); // Setzt eine Farbe, zur Parametrisierung eines Renderingstiles	
	void CColor::CopyWithoutAlpha(CColor & color); // Kopiert eine Farbe, belässt aber den Alpha-Wert
- Bis jetzt parametrisiertes Colorizing-, Toon- und Edge-Shading implementiert (Stile sind kombinierbar)
- Umwandlung der Copierparameter in CColor und CVertex in Referenzparameter (zur Beschleunigung)

21.04.2012 TB:
- Komplett überarbeitete Struktur für den Aufruf von TriangleLists und TriangleStrips
- Möglichkeit für mehrere Frames (für mehrere seperate Windows oder für zukünftige Erweiterungen, z.B.  z.B. für OpenGL und DirectX gleichzeitig), 
	bis jetzt sind maximal 4 gleichzeitige Frames ausführbar (mir fällt sowieso keine vernünftige Anwendung ein, wo mehr gebraucht werden)
- Einfachere und logischere Initialisierung von CGeoTriangleList, CGeoTriangleStrip, CGeoEllipsoid, CGeoQuad, CGeoCube, CGeoIcosahedron und CGeoTetrahedron 
	(ApiRender-Pointer muss nicht mehr übergeben werden, damit wird Objektstruktur vollkommen unabhängig von technischen Gegebenheiten => Voraussetzung für zukünftiges Verteiltes Rendering)

22.04.2012 TB:
- Nicht verwendeter Parameter prenderapi aus folgenden Klassen herausgenommen:
	CLight, CLights, CLightRadial, CLightRadials, CLightParallel, CLightParallels, CLightSpot, CLightSpots
	(ApiRender-Pointer muss nicht mehr übergeben werden, damit wird Objektstruktur vollkommen unabhängig von technischen Gegebenheiten => Voraussetzung für zukünftiges Verteiltes Rendering)

24.04.2012 TB:
Einfacherer Aufruf von häufig verwendeten Stilen, dazu folgende neue Methoden in CViewport:
	void StylePopArt(); // Schaltet auf Pop-Style-Anmutung
	void StyleCartoon(); // Schaltet auf Cartoon-Anmutung
	void StyleOutlining(); // Schaltet Konturierung an
	void StyleMonochrome(CColor c); // Schaltet Monochrome-Anmutung an, c gibt die Färbung an
	void StyleSepia(); // Schaltet Sepia-Anmutung an
	void StylePurpleHaze(); // Schaltet auf PurpleHaze-Anmutung
	void StyleBlueDream(); // Schaltet BlueDream-Anmutung an
	void StyleBlackWhite(); // Schaltet Schwarzweiß-Anmutung an
	void StyleContrast(float fr); // Erhöht Kontrast (Werte>0) bzw. vermindert Kontrast (Werte<0)
	void StyleContrast(CColor c); // Erhöht Kontrast (Werte>0) bzw. vermindert Kontrast (Werte<0) jeweils getrennt nach RGB-Werten 
	void StyleBrightness(float fr); // Erhöht Helligkeit (Werte>1), vermindert Helligkeit (Werte 0..1), invertiert Farbe (Wert<0) 
	void StyleBrightness(CColor c); // Erhöht Helligkeit (Werte>1), vermindert helligkeit (Werte 0..1), invertiert Farbe (Wert<0) jeweils getrennt nach RGB-Werten 
	void StyleRotateHue(float faHue); // Rotiert Farbwert um den Winkel fa im Bogenmaß
	void StyleInverse(); // Invertiert alle Farben
	void StyleOff(); // Schaltet alle Stile aus
Vereinheitlichung der Stilbehandlung durch homogene Farbmatrix
Erzeugung der Primitivenklasse CGeoTube zum Erzeugen von Röhren und CGeoExtrude (letztere noch nicht 100%-ig fertig) zum Erzeugen von extrudierten Körpern (aktuelle Projektgruppe braucht Solche Geometrieen für ihr Spiel, daher dieser Prio3-Task vorgezogen)
Einfügen einer Rakete in das Testprogramm zum Ausprobieren von CGeoExtrude 

29.04.2012 TB:
Methode in CHVector:
	void Scale(CHVector & v);		// skaliert einen Verktor mit den Werten eines anderen Vectors
Bugfix: Normalen, Tangenten und Bitangenten in CGeoSweep werden jetzt richtig berechnet
Neue Initalisierungsroutinen zur Erzeugung komplexer extrudierter Geometrieen:
	void CGeoTube::Init(float fRadiusInner, float fRadiusOuter, float fLength, CMaterial * pmaterial, int iLongitude = 24); // Initialisiert eine Röhren-Geometrie, fRadiusInner = innerer Röhrenradius, fRadiusOuter = äußerer Röhrenradius, fLength = Länge der Röhre, iLongitude = Anzahl der radialen Vertices  
	void CGeoSweep::Init(CHVector vSize, CMaterial * pmaterial, int iLongitude, int iLattitude, float * afrRadius, float * afrDistance, bool bFlip =false); // Initialisiert eine extrudierte Geometrie, vSize=allgemeine Skalierung, iLongitude = Anzahl radialer Vertices, iLattitude= Anzahl vetrices entlang des Pfades, afRadius  = Array von iLattitude Radien, afrDistance = Array von iLattitude Abständen zum Anfang des Pfades  
	void CGeoSweep::Init(CMaterial * pmaterial, int iLongitude, CHMats & matsPath); // Initialisiert eine extrudierte Geometrie,  iLongitude = Anzahl radialer Vertices, CHMats = hommogene Matrizen zum Plazieren, Skalieren und Rotieren des Pfades
	void CGeoSweep::Init(CHVector vSize, CMaterial * pmaterial, CHMats & matsPath, CHVectors & vs); // Initialisiert eine extrudierte Geometrie auf sehr komplexe Weise: matsPath gibt den Pfad als Liste homogener Matrizen an, vs die Punkte des Querschnitts 
Neue GeometrieKlassen:
	CGeoCone // Kegel als TriangleStrip
	CGeoCylinder // Zylinder als TriangleStrip
Einfügen von Boostern an die Rakete des Testprogramms zum Ausprobieren von CGeoTube, CGeoCone und CGeoCylinder => funktioniert

29.04.2012 MS:
Neue Methode in CHVector:
	void Dist(CHVector & v) // berechnet euklidische Distanz zwischen zwei Vektoren

01.05.2012 TB:
Bugfix: Methode CMaterial::SetGlowAsImage() funktionierte nicht, jetzt funzts.
Klasse COverlays und CFloatRects auf Smart Allocation umgestellt 
Veraltete Kommentare, Variablen und Methoden in CViewport, COverlay, CFloatRects und CFloatRect gelöscht
Chroma-Key in Asteroiden-Images verbessert
Neue Methoden in CFloatRect:
	CFloatRect(float fxPos, float fyPos, float fxSize, float fySize); // Konstuktor mit fxPos = linker x-Wert, fyPos = oberer y-Wert, fxSize = Breite, fy-Size = Höhe 
	float GetRight(); // gibt die rechte X-Position aus
	float GetBottom(); // gibt die untere Y-Position aus
	float GetRatio(); // gibt das Verhältnis zwischen Breite und Höhe aus
	bool IsInner(float fx, float fy); // Gibt true aus, wenn der Punkt P=(fx,fy) im Rechteck ist, ansonsten false 
	void SetXPos(float fxPos); // Setzt linken X-Wert
	void SetYPos(float fyPos);  // Setzt linken Y-Wert
	void SetXSize(float fxSize); // Setzt Breite
	void SetYSize(float fySize);  // Setzt Höhe
	float GetXPos(); // Holt linken X-Wert
	float GetYPos();  // Holt linken Y-Wert
	float GetXSize(); // Holt Breite
	float GetYSize();  // Holt Höhe
Neue Methode in CViewport:
	void AddSprite(COverlay * psprite); // Hängt 2D-Sprite an Viewport an
Erweiterung von Direct-X um Sprites (dazu Umbau der Draw-Methode notwendig)
Klasse COverlay funktioniert nun
Vektorialogo-Sprite in Testprogramm zur Evaluation dazugefügt

02.05.2012 TB:
#include-Hierarchie aufgeräumt & Vorkompilierte Header eingeschaltet => Wesentlich schnellere Compilierzeit (nur noch ein Bruchteil der vorherigen Zeit bei wenigen Änderungen)
Veraltete Methoden und Variablen in CHardware & CGeoCube gelöscht
 
02.05.2012 - 03.05.2012 MS/TB/KE/FS:
- In HVector MakePoint() verbessert. ;-)
- UV-Mapping und Affe im BlenderImporter gefixt (Danke für die Hilfe!)
- Nicht benötigter Paramter pApiRender aus CFileBlender entfernt.
- HINSTANCE Parameter aus InputX entfernt: AfxGetInstanceHandle wird nun innerhalb der Mehtode Init aufgerufen.
p.s.
Vektoria läuft bei mir mit ca. 63 fps.
Es läuft auch auf 3 Bildschirmen, sofern die Anzeige nicht erweitert wird, also mit einer Auflösung von 5760x1080 (auch im Vollbildmodus).
Es geht nicht wenn die Anzeige auf die zusätzlichen Bildschirme erweitert!!! wird.

03.05.2012 FS:
- Bug in der Intensitätswertberechnung ausgebessert. (eventuell für Streifen-Problem verantwortlich?!)
- Neue Testfälle für Schatten und Parallellichter geschrieben.
- ShadowMap Größe über Precompilermakro einstellbar.
- Projektionsmatrix für Parallellichtschatten verbessert.

05.05.2012 TB:
Klasse CGeoTube erweitert um:
	void InitStraight(float fRadiusInner, float fRadiusOuter, float fLength, CMaterial * pmaterial, int iLongitude = 24, bool bInner = true); // Initialisiert eine Röhren-Geometrie, fRadiusInner = innerer Röhrenradius, fRadiusOuter = äußerer Röhrenradius, fLength = Länge der Röhre, pmaterial = Materialpointer, iLongitude = Anzahl der radialen Vertices, bInner = true, wenn Innenleben des Rohres erzeugt werden soll
	void InitArc(float fRadiusInner, float fRadiusOuter, float fRadiusArc,  float faArc,  CMaterial * pmaterial, int iLongitude = 24, int iLattitude = 24, bool bInner = true); // Initialisiert eine Rohrbogen-Geometrie, fRadiusInner = innerer Röhrenradius, fRadiusOuter = äußerer Röhrenradius, fRadiusArc = Gesamtradius des Rohrbogens, faArc = zu zeichnender Öffnungswinkel des Rohrbogens im Bogenmß, iLongitude = Anzahl der radialen Vertexunterteilungen, pmaterial = Materialpointer, iLattitude = Anzahl der Vertexunterteilungen entlang des Rohres, bInner = true, wenn Innenleben des Rohres erzeugt werden soll   
Bugfix: Bei Vollbildmodus wurde nicht beste Pixelauflösung gewählt, TODO: Frame mit höchster Pixelauflösung initialisieren

08.05.2012 TB:
Bugfix: Initialisierung von Geometrien nach dem Adden hatte nicht funktioniert, klappt jetzt
namespaces für kritische Klassenbezeichnungen eingeführt (TODO für alle einführen)
Große Umbenennungsorgie für die Knotenobjekte, jetzt folgende Buchstabenzuordnung:
A: CAudio						(ehemals CSound)
B: CBackground
C: CCamera
D: CDIDevice  
E: CEmitter						(angedacht)
F: CFrame						(ehemals CRenderFrame)
G: CGeo 
H: CHardware					(ehemals CComputer)
I: CPixImage						(ehemals CPixImage)
J: (frei)
K: CKeyframe					(angedacht)
L: CLight						(=> LL: LightParallel, LP: LightRadial, LS: LightSpot)
M: CMaterial
N: (frei)
O: COverlay						(ehemals CSprite)
P: CPlacement
Q: (frei)
R: CRoot  
S: CScene
T: CTexture
U: CUnion						(angedacht)
V: CViewport
W: CWriting						(in Arbeit)
X: (frei)
Y: (frei)
Z: (frei)


09.05.2012 TB:
Versuche mit Namespaces 

------------>  V5 auf Laufwerk L gestellt



14.05.2012 TB:
Namensänderung, CViewoprt::AddSprite in CViewport::AddOverlay
Bugfix: Applikation schmierte ab, wenn in einer Hierarchie nur 2D-Overlays ohne 3D-Geometrie erstellt wurden => getestet, funktioniert jetzt
Bugfix: Smart Allocation reservierte zu viel Speicherplatz, alle Pluralklassen daraufhin geändert => getestet, funktioniert

15.05.2012 TB:
Bugfix: Maus-Koordinaten waren bei schnellen Mausbewegungen nicht genau
Bugfix: Maus-Bewegung stimmten nach Resizing vom Window nicht mehr 
analog zur möglichen Wahl zwischen DirectX,  OpenGL(TODO) und NullRenderer kann man jetzt zwischen DirectInput, SDL und NullDeviceApi wählen. Dafür folgende neue Klassen eingefügt: 
		CDevice, 
		CDeviceKeyboard, 
		CDeviceMouse 
		CDeviceGameController
NULL-ApiInput eingefügt 
Devices sind nun Knotenobjekte => Einfachere, konsistentere und logischere Bedienung, die Objekte einfach an ein Frame dranhängen und es funktioniert, dafür folgende neue Methoden in CFrame:
	void AddDeviceKeyboard(CDeviceKeyboard * pdevicekeyboard);
	void AddDeviceMouse(CDeviceMouse * pdevicemouse);
	void AddDeviceGameController(CDeviceGameController * pdevicegamecontroller);
Bugfix: SetBackfaceCullingOff erzeugte seltsame Effekte (Frontculling) => getestet, funktioniert nun

16.05.2012 TB, FS, MS, KE:
Release- läd nun Release-Lib und Debug- läd Debug-Lib (war vorher vertauscht)
Einige Compilerparameter verändert (Geschwindigkeitoptimierung)

17.05.2012 TB:
Scenes funktionieren jetzt, sie waren vorher blos Dummys, jetzt zeigt die Camera nur die Objekte an, die in der Szene tatsächlich vorhanden sind (TODO: Lichter haben noch Bug, sie wirken sich in allen Scenes aus)
Aufruf der Klasse CGame bei VektoriaApp und VektoriaTest vereinheitlicht
Materialien müssen nun nicht mehr bei der Root mit AddMaterial angemeldet werden (Szenengraf denkt nun mit)

18.05.2012 TB:
-Vektoria V6 erstellt

21.05.2012 FS:
- AABBs Implementiert
- Klasse CNode erstellt, alle Knoten welche in den Szenengraphen gehangen werden können müssen von dieser Klasse abgeleitet sein.
- Ein Knoten (CNode) spannt außerdem immer einen neuen Raum auf und stellt daher auch eine Bounding Box dar.
- In den Testprojekten ist nun außerdem der Einsatz der Taste "h" möglich um die Bounding Boxes anzeigen zu lassen. (Bereits allgemein als VisualHelpers bezeichnet, somit können demnächst auch Positionen von Placements visualisiert werden)
TODO:
- Bisher wurden die Bounding Boxes noch nicht für Placements realisiert, habe ich allerdings morgen vor.
- GeoCube ist nicht für Bounding Boxes geeignet, da immer symmetrisch => Anpassungen notwendig.
- Bounding Boxes für Kamera und Lichter.
- zu guter Letzt dann Projektionsmatrixberechnung aufgrund Schnitte mit Kamera und Geometrie AABBs.

22.05.2012 TB:
Halbtransparente Overlays nun möglich, dafür folgende Methoden(in App getestet, funktioniert):
	void SetTransparancy(float frTransparancy); 
Overlays können mit folgenden Methoden nun an- und ausgeschaltet werden:
	void SwitchOn();
	void SwitchOff();
Leichte Beschleunigung der Sprite-Zeichnung durch Vorinitialisierung der Vorldviewprojektion-Matrizen für Parallelprojektion
Backgrounds sind jetzt möglich (Test in App eingebaut)

05.06.2012 FS:
Zwischenstand auf dem Weg zu Bounding Boxes:
- CNode Klasse und CThing gemerged.
- Virtuelle Methode UpdateAABB erstellt.
  Diese soll bei jedem Baum Element aufgerufen werden können.
- AddParent und SubParent erstellt, diese müssen noch korrekt implementiert werden.

06.06.2012 KW + BW:
Features:
  extended CAABB (ctors, GetLongestAxis, Encompass, IsInside, GetMidPoint, GetMin, GetMax, GetSize, Copy);
  extended CDirectX:
    enabled Multisampling support,
    enabled Anisotropic filtering,
    changed shader model to 5.0,
    fixed memory bug (calloc/delete -> calloc/free),
    added methods (CreateBuffer, CreateSRVFromFile, DrawDrawable, SetShader, UnSetShader, GetMSAAQuality, CreateSamplerState, CreateShader, CreateStructuredBuffer, CreateConstantBuffer, CreateBuffer, CreateBufferUAV, CreateBufferSRV, SetConstantBuffers, SetDomainShaderResources, SetDomainShaderSamplers, RunComputeShader, Dispatch, TransferFromGPU, TransferToGPU, CreateInformationQueue, GetNextMessage),
    implemented shader precompiling,
    added hardware tesselation support,
    added compute shader support,
    added InformationQueue support,
    increased shader optimization level,
  added HumanicsApp demo;
  implemented CDrawable as a base for classes that wish to handle their drawing completely themselves;
  implemented CDynamicTriangleList and support classes (CDynamicListVertex, CDynamicListVertexs, CDynamicTriangle, CDynamicTriangles, CDynamicTriangleListData);
  added ezlogger;
  implemented CFileWavefront importer (*.obj);
  implemented spring-mass-damper simulator:
    CAABBNode        (a node in an AABB tree, that was created by a specific strategy, with children and an AABB),
    CAABBTree        (manages a whole AABB tree),
    CAngularSpring   (applies forces according to an angle/twist),
    CAngularSprings,
    CollisionHandler (detects and resolves collisions between masses and triangles),
    CLinearSpring    (applies forces according to a stretch/compression),
    CLinearSprings,
    CMass            (represents a physical mass),
    CMasses,
    CSpringMassSystem (base class that implements subframe sampling),
    CSpringMassSystemCPU (simulates springs and masses on the CPU),
    CSpringMassSystemGPU (simulates springs and masses on the GPU),
  implemented CTimer (platform independent, high resolution timer);
  implemented CVector3 (three dimensional vector);
  implemented CBufferService (manages buffers, SRVs, UAVs and constant buffers);

Minor changes:
  extended CGeoQuad   (added ability to specify texture mapping);
  extended CHVector   (default ctor now initializes to zero, operator[], Min, Max);
  extended CLight     (refactored FindLights to support CGeo and CDrawable);
  extended CPlacement (added AddDrawable);
  extended CBufferMap (getBuffer now returns NULL for negative buffer handle);
  extended CLightSpot (increased shadowmap size);
  fixed Sound.h for inclusion in files without stdafx.h;
  enabled OpenMP for CPU parallelism;

07.06.2012 FS:
- Shadow Map Größe kann jetzt manuell gesetzt und auch während des Programms geändert werden.
- Near und Far Planes können dynamisch geändert werden.
Nur eine vorläufige Lösung, da diese bald automatisch berechnet werden sollen.
Leider sitzt irgendwo ein Fehler und mir fehlt im Moment die Zeit lange danach zu suchen ...

08.06.2012 TB:
Neue Klasse CDeviceCursor hinzugefügt, damit absolute Mauskoordinaten nun möglich => Grundlage für vernünftiges Picking
Neue Methoden der Klasse CDeviceCursor: 
	bool GetAbsolute(int & ix, int & iy, bool bHideCursor = false); // Gibt die Zeigerpositionskoordinaten bezüglich der linken oberen Ecke des Frames aus, gibt true aus, wenn Cursor sich innerhalb des Frames befindet 
	bool GetFractional(float & frx, float & fry, bool bHideCursor = false); // Gibt die fraktionalen Zeigerpositionskoordinaten (Wertebereich jeweils 0..1) bezüglich des Frames aus, gibt true aus, wenn Cursor sich innerhalb des Frames befindet
	bool ButtonPressed(int iButton); // true, falls Taste iButton gedrückt wurde, ansonsten false
	bool ButtonPressedLeft(); // true, falls linke Maustaste gedrückt wird, ansonsten false
	bool ButtonPressedRight(); // true, falls rechte Maustaste gedrückt wird, ansonsten false
	bool ButtonPressedMid(); // true, falls mittlere Maustaste gedrückt wird, ansonsten false
Neue Methoden der Klasse CViewport: 
	void FrameToViewportCoord(float & frx, float & fry); // Übersetzt die Koordinaten des Frames in Koordinaten des Viewports
Neue Klasse zur Geometrieerzeugung (CGeoSlice) 
Neue Methode zur Beschleunigung von fixen, unveränderlichen Placement-Hierarchien in CPlacment:
	void Fix(); // Sollte aufgerufen werden, wenn sicher ist, dass Placment und Unterplacements starr in der Gegend stehen => Beschleunigt das Randering, da dann die Matrizen nicht immer wieder neu berechnet werden 

09.06.2012 KW:
fixed several crashes in CFileWavefront

11.06.2012 FS:
- Kleinen Bug in Light.cpp ausgebessert.

12.06.2012 BW:
fixed two crashes in vektoria test:
	- wrong handle for DirectX Init
	- CGeoTube needs init, before adding as geo (CNode needs initialized objects ...)

12.06.2012 KW + BW:
- header files cleanup
- minor changes in CSpringMassSystem

13.06.2012 TB:
- Vektoria V7 erstellt

14.06.2012 TB
- Klasse CSprite eingeführt, von der COverlay und CBackground erben => weniger redundanter Code
- Sprites (und damit Backgrounds und Overlays) lassen sich nun durch die Methdode Rotate(float fa) drehen
- bugfix: Kopieroperator bei Sprites funktionierte nicht
- Cursor lässt sich jetzt automatisch ausschalten, wenn er in Frame hineinbewegt wird => eigener Cursor erzeugbar
Aufräumaktion:
- Änderungen von veralteten und missverständlichen Headerkomentaren
- Veralterer unsinniger Code in COverlay, CBackground und CTriangeStrip gelöscht 
- kleine Variablennamenänderungen zum besseren Verständnis
- bugfix: in DirextX "white.jpg" => "textures//white_image.jpg"

30.08.2012 TB
- Pluralklasse CWritings in SmartAllocation umgewandelt
- CWriting ist jetzt von CSprite abgeleitet
- Pluralklasse CPixImages in SmartAllocation umgewandelt
- In die Pluralklassen jeweils die Methode "Sub" hinzugefügt, mit der man ein Objekt wieder aus der Klasse entfernen kann 

30.10.2012 TB
- Bug in CQuaternion gefixt: Quaternionennultiplikation lieferte falsche Ergebnisse
- Beschleunigung der Umwandlung von Quaternionen in Matrizen
- Folgende neue Funktionen in CQuaternion: 
	Quaternion::Inverse()		// Generiert Inverse des Quaternions
	CHMat GetMatrixByNormed(); // Generiert Rotationsmatrix aus einem normierten Quaternion und gibt sie aus, Achtung Quaternion muss normiert sein, sonst kommt hier was falsches raus, dafür ist sie etwas schneller als GetMatrix
- VektoriaApp m_fTimeDelta war ungenau -> korrekter Timer eingebaut
- Klasse CTimer komplett überarbeitet, einige Bugs gelöst, Header-Body-Struktur eingeführt, trotzdem aufwärtskompatibel
- folgende neue Methoden in CTimer:
    void Init();							// Initialisiert den Timer neu, falls der Aufruf des Konstruktors zu lange her ist
	void Tick(float & fTime, float & fTimeDelta);	// Sollte jeden Tick aufgerufen werden, berechnet fTime (Zeit in Sekunden, die seit Init bzw. Konstruktor-Aufruf vergangen ist) und fTimeDelta (Zeit, seit dem letzten Tick vergangen ist)
	void Fini();							// Finalisiert den Timer, wird zurzeit nicht verwendet
	float SwitchFrameRateCalculationOn();	// Schaltet die Berechnung der Bildwiederholrate ein, FR-Berechnung kostet ein wenig Performanz, daher per Default aus
	float SwitchFrameRateCalculationOff();	// Schaltet die Berechnung der Bildwiederholrate aus, FR-Berechnung kostet ein wenig Performanz, daher per Default aus
	void CalcFrameRate();					// Berechnet die Bildwiederholrate (vier Werte: der arithmetische Kurzzeitdurchschnitt, der arithmetische Langzeitdurchschnitt, die schlechteste und der beste Wert)
	float GetFrameRateAverage();			// Gibt den arithmetischen Kurzzeitdurchschnitt über die letzten Ticks (I_FR_TICKS) der FrameRate aus 
	float GetFrameRateAverageLong();		// Gibt den arithmetischen Langzeitdurchschnitt über die letzten Ticks (I_FR_TICKS*I_FR_LONG_TERM_FAKTOR) der FrameRate aus 
	float GetFrameRateMin();				// Gibt den schlechtesten Wert über die letzten Ticks (I_FR_TICKS) der FrameRate aus 
	float GetFrameRateMax();				// Gibt den besten Wert über die letzten Ticks (I_FR_TICKS) der FrameRate aus 
- Bugfix []-Operator bei CHVector gab bei iPos==3 nicht w aus 
- Viele Kommentare überarbeitet

31.10.2012 TB
- Bugfix in CHat::Transpose(): Matrixelement [3,3] wurde falsch berechnet

01.11.2012 MS (rev 297 + 298)
- Alle Headerfiles von Blender entfernt und minimal benötigten Code in DNATypes.h zusammengefasst.>>>>>>> .r298

01.11.2012 TB
- Unbenutzte Destruktoren in Elementar-Klassen (CHMat, CHMats,CHvector, CHVectors, CHQuaternion, CHQuaternions, CIntRect, CIntRects, CFloatRect, CFloatRects, CColor, CColors) gelöscht
- Frame Rate Anzeige in Titelleiste der App eingefügt

02.11.2012 MS
- 3DS-Importer von Michael Rücker eingefügt.
- DNATypes.h nochmal überarbeitet

02.11.2012 TB
- Folgende Operatoren in CHVector eingefügt:
	CHVector operator -(void); // Negativzeichen vor Vektor => Minus vor allen Vektorelementen
	CHVector operator +(void); // Positivzeichen vor Vektor => keine Veränderung, trotzdem der mathematisch vollwertigenNotation halber wichtig

07.11.2012 MS
- UV-Mapping Bugfix im neuen 3DS-Importer>>>>>>> .r302

08.11.2012 TB
- Übergabe in Copy-Methode und Istgleichoperator von Klasse CFloatRect nun als Call-of-reference statt Call-of-Value (ist nach einer Messung schneller)
- Folgende Methoden in Klasse CFloatRect eingefügt:
	bool IsBetweenX(float fx); // gibt true aus, falls sich fx zwischen linker und rechter Kante befindet (ausschleißlich Kante)
	bool IsBetweenY(float fy); // gibt true aus, falls sich fy zwischen oberer und unterer Kante befindet (ausschleißlich Kante)
	bool IsBetween(float fx, float fy); // Gibt true aus, wenn der Punkt P=(fx,fy) im Rechteck ist, ansonsten false (ausschleißlich Kante)
	bool IsInnerX(float fx); // gibt true aus, falls sich fx zwischen linker und rechter Kante befindet (einschließlich Kante)
	bool IsInnerY(float fy); // gibt true aus, falls sich fy zwischen oberer und unterer Kante befindet (einschließlich Kante)
	bool IsInner(float fx, float fy); // Gibt true aus, wenn der Punkt P=(fx,fy) im Rechteck ist, ansonsten false (einschließlich Kante)
	void Scale(float f); // Skaliert Rechteck ausgehend vom Ursprung
	void ScaleFromBottom(float f); // Skaliert Rechteck, aber lässt untere Kante auf gleichem Level (Rechteck wird hochgezogen)
	void Scale(float fx, float fy); // Skaliert Rechteck ausgehend vom Ursprung
	void ScaleFromBottom(float fx, float fy); // Skaliert Rechteck, aber lässt untere Kante auf gleichem Level (Rechteck wird hochgezogen)
	float GetDistLeft(CFloatRect & floatrect); // gibt Zwischendistanz des Parameter-Floatrects von der linken Kante aus
	float GetDistRight(CFloatRect & floatrect); // gibt Zwischenddistanz des Parameter-Floatrects von der rechten Kante aus
	float GetDistTop(CFloatRect & floatrect); // gibt Zwischenddistanz des Parameter-Floatrects von der oberen Kante aus
	float GetDistBottom(CFloatRect & floatrect); // gibt Zwischenddistanz des Parameter-Floatrects von der unteren Kante aus
	void Clip(); // Schneidet Ränder des Rechtecks dergestalt ab, dass sie alle zwischen Null und Eins liegen
- Folgende neue Makros in Util.h eingefügt:
	UM_ISRANGEEQUAL(fMin1,fMax1,fMin2,fMax2) // Überprüft, ob zwei Wertebereiche einigermaßen gleich sind
	UM_ISRANGEINRANGE(fMin1,fMax1,fMin2,fMax2) // Überprüft, ob ein Wertebereiche im anderen liegt 
	UM_ISINRANGEEXCLUSIVE(f,fMin,fMax) // Überprüft, ob Wert f in den Wertebereich (fMin bis fMax) liegt  (exklusive fMin und fMax), wenn ja => true, falls nein => false
	UM_ISINRANGEINCLUSIVE(f,fMin,fMax) // Überprüft, ob Wert f in den Wertebereich [fMin bis fMax] liegt (inklusive fMin und fMax), wenn ja => true, falls nein => false
	UM_ISRANGETOUCHESRANGE(fMin1,fMax1,fMin2,fMax2) // Überprüft, ob ein Wertebereiche den anderen Berührt 
	UM_ISONE(f)	// überprüft float und double-Werte auch dann auf Eins, wenn Ungenauigkeiten hinterm Komma bestehen

09.11.2012 TB
- Folgende Methoden in Klasse CHMat eingefügt (hat sich als praktisch erwiesen und fehlten als Analogon zu RotateX, ...:
	void TranslateX(float fx); // Generiert Verschiebungsmatrix in X-Richtung 
	void TranslateY(float fy); // Generiert Verschiebungsmatrix in Y-Richtung 
	void TranslateZ(float fz); // Generiert Verschiebungsmatrix in Z-Richtung 
	void TranslateXDelta(float fx); // Generiert Verschiebungsmatrix in X-Richtung und multipliziert diese mit der Rotationsmatrix 
	void TranslateYDelta(float fy); // Generiert Verschiebungsmatrix in Y-Richtung und multipliziert diese mit der Rotationsmatrix 
	void TranslateZDelta(float fz); // Generiert Verschiebungsmatrix in Z-Richtung und multipliziert diese mit der Rotationsmatrix 
- Folgende Methoden in Klasse CPlacement eingefügt (hat sich als praktisch erwiesen und fehlten als Analogon zu RotateX, ...:
	void TranslateX(float fx); // Generiert Verschiebungsmatrix in X-Richtung für das Placement
	void TranslateY(float fy); // Generiert Verschiebungsmatrix in Y-Richtung für das Placement
	void TranslateZ(float fz); // Generiert Verschiebungsmatrix in Z-Richtung für das Placement
	void TranslateXDelta(float fx); // Generiert Verschiebungsmatrix in X-Richtung und multipliziert diese mit der Rotationsmatrix für das Placement
	void TranslateYDelta(float fy); // Generiert Verschiebungsmatrix in Y-Richtung und multipliziert diese mit der Rotationsmatrix für das Placement
	void TranslateZDelta(float fz); // Generiert Verschiebungsmatrix in Z-Richtung und multipliziert diese mit der Rotationsmatrix für das Placement

11.11.2012 TB
	Die beiden Klassen CGeoWall und CGeoWindow eingefügt, mit ihnen lassen sich beliebige Mauern und Wände mit Fenstern, Türen und Durchbrüchen erzeugen.
	
13.11.2012 TB
 - MIN-, MAX-Makros in Util.h eingefügt:
		UM_MIN(f1,f2)		// Min-Funktion
		UM_MAX(f1,f2)		// Max-Funktion

20.11.2012 TB
- Folgende Methode in Klasse CFloatRect eingefügt:
	void Translate(float fx, float fy); // Verschiebt Rechteck um den 2D-Vektor(fx,fy)
- Folgende Methode in Klasse CGeoTriangleList eingefügt:
	void FlipSpin(); // Vertauscht Vertexreihenfolge, lässt aber anders als Flip den Normalen- und Tangentenvektor unbeeinflusst (wichtig für die korrekte Anzeige nach Spiegelungen)
- Klasse CGeoWall können jetzt auch Giebel und Dächer erzeugen, dafür folgende Methoden:
	float GetGableHeight(float fr); // Gibt die Höhe der Giebelschräge an dem relativen x-punkt fr an  
	void SetGable(float frCuspLeft, float frCuspRight); // Gibt den linken und den rechten Giebelpunkt an (z.B. 0.0 = an der linken ecke der Mauer, 0.5 = Mauermitte, 1.0 = ganz rechts an der Mauer)
	void SetGable(float frCusp); // Gibt für Spitzgiebel den gemeinsamen Scheitelpunkt an (z.B. 0.0 = an der linken Ecke der Mauer, 0.5 = Mauermitte, 1.0 = ganz rechts an der Mauer)
	void SetTextureStart(float fxTextureStart = 0.0F, float fyTextureStart = 0.0F); // Verschiebt die UV-Koordinaten der Mauertextur
	void SetTextureRepeat(float fxTextureRepeat = 1.0F, float fyTextureRepeat = 1.0F); // Skaliert die UV-Koordinaten der Mauertextur
	void Init(float fWidth, float fHeight, float fThickness, CMaterial * pmaterial, bool bLeft = true, bool bRight = true, bool bBottom = true, bool bTop = true, bool bFront = true, bool bBack = true); // Initialisiert die Mauer fWidth ist die Länge, fHeight die Höhe, fThickness die Dicke, pmaterial das Material der Mauer, mit den boolschen Flages lassen sich die entsprechenden Seiten an- und ausschalten  
	void AddGeoWindow(CGeoWindow * pgeowindow); // Stanzt ein Fenster in die Mauer, welches durch pgeowindow definiert wurde 
	CGeoWindow * MakeGeoWindow(CFloatRect floatrect, int eStyle); // Erzeugt ein Fenster
- Mit der Klasse CGeoWindow lässt sich jetzt hierarchisch wiederum CGeoWalls einbetten => Simse und Fensterrahmen möglich  
- SetMaterial lässt sich nun auch während der Laufzeit verwenden, d.h. Materialien können im Tick ausgetauscht werden
- Geometrien können nun an- und ausgeschaltet werden, dafür folgende Methoden in CGeo eingefügt:
	void SwitchOn(); // Schaltet Geometrie an
	void SwitchOff(); // Schaltet Geometrie aus

23.11.2012 TB
- GeoWall-Klasse etwas aufgeräumt
- Beim Updaten Kollision in CGeoTriangleList::Draw => hoffe, es wurden dabei keine wichtigen Änderungen von Flo oder Matthias zerstört => TODO Flo und Matthias fragen!
- WASD-Steuerung für Erdumgebungen hinzugefügt (mit Eulerwinkeln, im Gegensatz zu bisheriger WASD-Steuerung für Weltraumumgebungen bleibt Horizont stets horizontal), 
	dafür dritter boolscher Parameter Methode in PlaceWASD hinzugefügt, wenn true => Erdsteuerung, wenn false => Weltraumsteuerung
- Overlays können nun hierarchisch angeordnet werden, das heißt, an ein Overlay kann ein anderes Overlay angeheftet werden (TODO noch keine relative Plazierung)
- Bugfix in COverlay und CBackground (manche Grafikkarten stürzten ab)

27.11.2012 TB
- Kinderoverlays können nun relativ zum Vateroverlay parametrisiert werden, dafür folgende Methoden in der Klasse COverlay:
	void AddOverlay(COverlay * poverlay); // Hängt Kind-Overlay an Hierarchie an
	bool SubOverlay(COverlay * poverlay); // Hängt Kind-Overlay von Hierarchie ab, gibt true aus, wenn's geklappt hat
	void SetBehindOn(); // lässt Overlay hinter Vateroverlay erscheinen
	void SetBehindOff();  // lässt Overlay vor Vateroverlay erscheinen (Default)
	void SetInnerOn(); // lässt Overlay innerhalb vom Vateroverlay erscheinen
	void SetInnerOff();  // lässt Overlay außerhalb vom Vateroverlay (aber trotzdem ausgerichtet an Vaterkoordinaten) erscheinen (Default)

28.11.2012 TB
- Geoellipsoids können jetzt alternativ auch bizylindrisches, orthografisches und biorthografisches Mapping (ist leichter in Photoshop zu erstellen als reines zylindrisches)
- Bugfix in CGeoEllipsoid (Methode Init stürzte bei Werten von iLongitude oder iLattitude unter 2 wegen Division durch Null ab) 
- WASD-Steuerung kann jetzt optional höhenlimitiert werden, dafür folgende neue Methodern in DeviceKeyboard:
	void SetWASDLevelMin(float fyLevelMin); // Erzeugt Kameramaximalhöhenlevel für die Erdsteuerung, die Kamera kann nie über fyLevelMax steigen
	void SetWASDLevelMax(float fyLevelMax); // Erzeugt Kameraminimalhöhenlevel für die Erdsteuerung, die Kamera kann nie unter fyLevelMin untertauchen
	float GetWASDLevelMin(); // Holt Kameraminmalhöhenlevel für die Erdsteuerung, die Kamera kann nie über fyLevelMax drübersteigen
	float GetWASDLevelMax();// Erzeugt Kameramaximalhöhenlevel für die Erdsteuerung, die Kamera kann nie unter fyLevelMin untertauchen
- Alle Methodennamen, die mit WASD-Steuerungen zusammenhängen, wurden aneinander angeglichen
- Viele Kommentare in Header eingefügt

29.11.2012 TB
- CGeoEllipsoid kann nun auch nur Teile eines Ellisoids erzeugen, dafür Init-Methode erweitert:
	void Init(CHVector vSize, CMaterial * pmaterial, int iLongitude = 24, int iLattitude = 12, int iLattitudeMin=0, int iLattitudeMax = INT_MAX, int eMapping = S_GEOELLIPSOIDMAPPING_CYLINDRICAL); // Initialisiert eine ellisoide Geometrie 
-File3DS von Michael Rücker / MS in Projekt geladen (war vorher nur in Order)
- Zwei neue Klassen zur Geometrieerzeugung: 
	CGeoSphere (erzeugt Kugel)
	CGeoDome (erzeugt Kuppeln oder Skydomes)
- Materialieneigenschaften können nun auch nach dem Init im Tick verändert werden, dafür folgende Methode in ApiRender, NullRenderer und DirectX: 
		void UpdateTextures(CMaterial * pmaterial); 		


 30.11.2012 TB
 - In Placement kann jetzt die Z-Buffer-Distanz für die Alpha-Sortierung bei Transparenzen fixiert werden, 
   dies ist vor Allem bei ineinandergeschachtelten transparenten Objekten notwenig, 
   zum Beispiel Multi-Skydomes mit ineinander geschachtelten semitransparenten Layern, dafür folgende Methode:
   	void FixDistance(float fDistance); // Fixiert die Distanz, die für die Z-Buffer-Sortierung verwendet wird, notwendig für ineinander geschachtelte transparente Objekte (Multiskydomes, Atmosphärenhüllen, etc.) 	
- Draw-Aufrufe vereinfacht und beschleunigt
- Methoden in CPlacementund CHMat komplementiert, nun ist es "rund":
	void ScaleX(float fx);		// Generiert uniforme Skalierungsmatrix für die X-Achse
	void ScaleY(float fy);		// Generiert uniforme Skalierungsmatrix für die Y-Achse
	void ScaleZ(float fz);		// Generiert uniforme Skalierungsmatrix für die Z-Achse
	void Translate(CHVector & v); // Generiert Verschiebungsmatrix
	void ScaleXDelta(float fx);		// Generiert uniforme Skalierungsmatrix für die X-Achse und multipliziert diese mit der aktuellen Matrix
	void ScaleYDelta(float fy);		// Generiert uniforme Skalierungsmatrix für die Y-Achse und multipliziert diese mit der aktuellen Matrix
	void ScaleZDelta(float fz);		// Generiert uniforme Skalierungsmatrix für die Z-Achse und multipliziert diese mit der aktuellen Matrix
	void TranslateDelta(float fx, float fy, float fz); // Generiert Verschiebungsmatrix und multipliziert diese mit der aktuellen Matrix

02.12.2012 KW + BW:
added method CAABB::Intersects
CDevice gets hInstance from GetModuleHandle
several Fixes to CFileWavefront
extended logger for Vectors
Fixes in CNode
CDirectX:
  DepthStencil Buffer gets resized
  fixed runtime warning concerning Shadowmap
  CopyBuffer() added
  Texture Speedup
  CreateShader now also checks included files
  CreateTypedBuffer() added
  CreateScan() added
  added debug/profiling methods:
    QueryGraphicsCard()
    InitProfiling()
    WaitForShaderExecution()
moved physics simulation classes to LibParticlePhysics
removed Sound.cpp and .h
updated humanics demo application (now demonstrating usage of particles, springs, constraints, dynamic triangles and collision)	
	
03.12.2012 TB
- letzte CFrame::Init-Parameter in enums umgewandelt (angenehmere Programierung für Anwender mit Intellisense)
- Man kann nun automatisch zwischen ShaderModel 4.1 und 5.0 up- und downgraden,
	 indem man zwischen eApiRender_DirectX11_Shadermodel41 oder eApiRender_DirectX11_Shadermodel50 in CFrame::Init wählt (Wunsch einiger Studierender mit älteren Laptops)

12.12.2012 TB
- Nun sind auch Height-Maps statt Bump-Maps möglich, dafür folgende Methoden in CMaterial:
	void SetTextureHeight(CTexture *ptexture);
	CPixImage * MakeTextureHeight(char * acPath);
	void SetTextureHeightAsImage();
- Kameraberechnung des Vertex-Shaders vereinfacht und beschleunigt
- Nebel ist jetzt möglich, dafür folgende neue Methoden in CViewport:
	void SetFogOn(); // Schaltet Nebel an
	void SetFogOff(); // Schaltet Nebel aus
	void SetFogStrength(float fFogStrength); // Gibt Nebelstärke an, Default = 0.01 
- Bugfix: Wenn Texturpfad falsch gesetzt war, gab es überhaupt keine Anzeige eines Objektes, dies hat mehrere Anwender irritiert
- Bugfix: Wurde Glow-Pfad falsch gesetzt, leuchtete die Schattenseite der Geometrien  
- Bugfix: OutliningStyle war von der Richtung der Kamera abhängig 
- Bugfix: Spekulares Highlight wurde falsch berechnet
- Bugfix: System stürzte manchmal ab, wenn Geometrie nach dem Adden ans Placement angehangen wurde

15.12.2012 TB:
- Bugfix: Kopieroperator in CVertex kopierte nicht die UV-Koordinaten (getestet, funktioniert)
- Bugfix: CGeoCube w-Komponente bei Normalen und Tangentenvektoren wurden auf 1 gesetzt, was eine seltsame Beleuchtung nach Rotationen zur Folge hatte
- Flip und FlipSpin fnktionieren jetzt auch bei TriangleStrips (getestet, funktioniert)
- CGeoTriangleStrips lassen sich nun bei Bedarf in CGeoTriangleLists konvertieren (getestet, funktioniert), dafür folgende Methode in CGeoTriangleStrip:
	CGeoTriangleList * CopyToTriangleList(); // Gibt eine dem TriangleStrip äquivalente TriangleList aus

18.12.2012 TB:
- Funktion Transform in CVertex eingebaut:
		void Transform(CHMat &m); // Matrixmultiplikation aller Werte mit der Matrix m => Verschieben, Rotieren, Skalieren etc. möglich 
- Veraltete und nicht mehr benötigte Funktion CreatePoly überall gelöscht wo sie auftrat
- Durch die Löschung von CreatePoly nicht mehr benötigte globale Variablen in CVertex gelöscht => Nahezu Halbierung des Speicherplatzbedarfs bei großen Szenen
- BoundingBox-Berechnung kann nun ein- und ausgeschaltet werden, dafür folgende Methoden in CPlacement: 
	void SetBoundingBoxesOff();
	void SetBoundingBoxesOn();
- StateSorting mit Vereinigung aller Geometrien unterhalb einer Placement-Hierarchie implementiert => bei Szenen mit vielen komplexen starren Objekten (Städte, Gebäude, Landschaften, Fixsterne, etc.) große Beschleungigung!
  dafür folgende Methoden in CPlacement imlementiert: 
	void Fix(); // Sollte aufgerufen werden, wenn sicher ist, dass Placment und Unterplacements starr in der Gegend stehen => Beschleunigt das Rendering, da dann die Matrizen nicht immer wieder neu berechnet werden 
	void Unfix(); //Macht Fix rückgängig
	void FixAndFasten(); // Sortiert zusätzlich zu Fix() nach Status-Calls, um CPUGPU-Traffic zu reduzieren und vereinigt Geometrien mit gleichem Material zu einer => große Beschleunigung (Achtung, die Rekalkulation dauert lange und daherr nur für einen Aufruf in Init-Teil geeignet!)
	void UnfixAndUnfasten(); // Macht FixAndFasten rückgängig (Achtung, dauert lange!)
- Testapplikation mit 25000 Objekten und 300000 Polys zum Testen von FixAndFasten eingebaut
	Taste N: UnfixAndFasten (danach bei mir  1,7 fps)
	Taste M: FixAndFasten   (danach bei mir 14,3 fps)

20.12.2012 TB:
- DrawPoly-Funktionen gelöscht, da veraltet

01.02.2013 TB:
Bugfix in Debug-Version: Kompilierte nicht

07.04.2013 TB:
Testbeds vereinheitlicht, Dateien fangen jetzt alle mit "Testbed" an => leichteres Finden in Ordner
Klassen der Testbeds fangen auch mit Testbed an
CTestbedGeo hinzugefügt
Bugfix in CGeoWall: UV-Mapping wurde bei Fenstereinbau falsch gesetzt

15.04.2013 TB:
Bugfix in CGeoWall / CGeoWindow: Bei einigen fensterKombinationen wurde Maueroberkante nicht geschlossen
CGeoWall: Vereinfachung der Saw-Methode bei gleichzeitigem Erhalt der Funktion
CGeoWindow: Dreieckige Fenster möglich

16.04.2013 TB:
Neue Funktionen in CHVector:
	float Angle(CHVector & v); // gibt Winkel im Bogenmaß aus, der sich zwischen dem bestehenden Vektor und dem Vector v befindet.
	float AngleXY(); // gibt auf die XY-Ebene projizierten Drehwinkel im Bogenmaß aus (Null entspricht X-Achse);
	float AngleZX(); // gibt auf die XZ-Ebene projizierten Drehwinkel im Bogenmaß aus (Null entspricht Z-Achse);
	float AngleYZ(); // gibt auf die YZ-Ebene projizierten Drehwinkel im Bogenmaß aus (Null entspricht Y-Achse);
Sinnlose Methode Fini() in CHVector gelöscht => alle Aufrufe ebenfalls gelöscht

20.04.2013 TB:
Bugfix: Bumpmap wurde nicht angezeigt, wenn keine Imange-Map angegeben war
Neue Methode in CGeoWall:
	CGeoWindow **  AddGeoWindows(CGeoWindow * pgeowindow, CFloatRect floatrect, int iX, int iY); // Stanzt iX*iY gleichartige Fenster rasterartig in den Mauerteil floatrect der Mauer, welches durch pgeowindow definiert wurde,  
Romanische und Arcadenfenster in CGeoWindow möglich

24.04.2013 TB:
Neue Methoden in CDeviceCursor:
	void Hide(); // Macht Cursor unsichtbar
	void Show(); // Macht Cursor sichtbar
	bool IsHidden(); // true, wenn Cursor unsichtbar, ansonsten false
Bugfix in CDeviceCursor::GetFractional und CDeviceCursor::GetAbsolute: Cursor flackerte bei manchen Computern nach Hiding wieder auf
CGeoWindow kann jetzt folgende Fensterformen:
	eGeoWindowStyle_Rect,
	eGeoWindowStyle_Tri,
	eGeoWindowStyle_TriLeft,
	eGeoWindowStyle_TriRight,
	eGeoWindowStyle_TriRect,
	eGeoWindowStyle_TriRectLeft,
	eGeoWindowStyle_TriRectRight,
	eGeoWindowStyle_Roman,
	eGeoWindowStyle_RomanLeft,
	eGeoWindowStyle_RomanRight,
	eGeoWindowStyle_Gothic,
	eGeoWindowStyle_GothicLeft,
	eGeoWindowStyle_GothicRight,
	eGeoWindowStyle_Arcade,
	eGeoWindowStyle_ArcadeLeft,
	eGeoWindowStyle_ArcadeRight,
	eGeoWindowStyle_Eyebrow,
	eGeoWindowStyle_EyebrowLeft,
	eGeoWindowStyle_EyebrowRight,
	eGeoWindowStyle_U,
	eGeoWindowStyle_ULeft,
	eGeoWindowStyle_URight,
	eGeoWindowStyle_Bicircle,
	eGeoWindowStyle_BicircleLeft,
	eGeoWindowStyle_BicircleRight,
	eGeoWindowStyle_RectBeveled,
	eGeoWindowStyle_RectBeveledLeft,
	eGeoWindowStyle_RectBeveledRight,
	eGeoWindowStyle_Hexagon,
	eGeoWindowStyle_HexagonLeft,
	eGeoWindowStyle_HexagonRight,
	eGeoWindowStyle_Octagon,
	eGeoWindowStyle_OctagonLeft,
	eGeoWindowStyle_OctagonRight
Fenster können jetzt auch bei Giebelwänden eingestanzt werden 


25.24.2013 TB:
Neue Methoden in CDeviceMouse:
	bool ButtonPressedLeft(); // true, falls linke Maustaste gedrückt wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonPressedMid(); // true, falls mittlere Maustaste gedrückt wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonPressedRight();// true, falls rechte Maustaste gedrückt wurde, ansonsten false (synchrone Mausklickabfragemethode)
Klasse CGeos auf SmartAllocation umgestellt, 
	CGeo::Sub hinzugefügt
	Durch SamartAllocation sinnlos gewordene Variablen m_pgeoPrev und m_pgeoNext gelöscht.
Kommentare und Variablenbezeichnungen etwas aufgeräumt


28.24.2013 TB:
Neue Methoden in CHMat (Gab es bisher nur als entsprechende Fremdmethoden):
	void Transpose();			// Transponiert Matrix 
	void Inverse();				// Invertiert Matrix 
Neue Methode in CHVector:
	void Null(); // Setzt alle Tupelwerte auf Null
Bugfix bei CGeoWall::AddWindows: Es konnten nie mehr als 128 Fenster in eine Wand gestanzt werden
Veraltete Methode CFace::Draw gelöscht 
Neuer Generalkonstuktor zu CVertex hinzugefügt: CVertex(CHVector &  vPos, CHVector & vNormal, CHVector & vTangent, float fU, float fV);
Bugfix in Zuweisungsoperator vcon CCameras: Zusätzliches Adden nach kopieren führte zum Absturz 

01.05.2013 TB:
Umfangreiche neue Modellierungsmethoden in CGeo:
	bool SubVertex(CVertex *vertex); // Hängt betreffendes Vertex ab 
	void TwistX(float faStrength); // Twisting um die X-Achse
	void TwistY(float faStrength); // Twisting um die Y-Achse
	void TwistZ(float faStrength); // Twisting um die Z-Achse

	void TaperX(float fRadius, float faSection); // Tapering um die X-Achse
	void TaperY(float fRadius, float faSection); // Tapering um die Y-Achse
	void TaperZ(float fRadius, float faSection); // Tapering um die Z-Achse

	void BendX(float fStrength, bool bInfluenceX=false, bool bInfluenceY=true, bool bInfluenceZ = true); // Bending in Richtung der X-Achse
	void BendY(float fStrength, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Bending in Richtung der Y-Achse
	void BendZ(float fStrength, bool bInfluenceX=true, bool bInfluenceY=true, bool bInfluenceZ = false); // Bending in Richtung der Z-Achse

	void Transform(CHMat & m); // Transformiert alle Punkte der Geometrie mit der Transformationsmatrix m
	void Unite(CGeo * pzg, CHMat & m, bool bKill = false); // Vereinigt die Vorliegende Geometrie und die Geometrie pzg zu einer Einzigen, wenn bKill gleich true ist, wird pzg danach gelöscht, ansonsten kannn man mit ihr ganz normal weiterarbeiten.
	bool IsTriangleList(); // Gibt true aus, wenn es sich bei der vorliegenden Geometrie um ein TriangleList handelt, ansonsten fal
	bool IsTriangleStrip(); // Gibt true aus , wenn es sich  bei der vorliegenden Geometrie um ein TriangleStrip handelt, ansonsten false
Umfangreiche neue Modellierungsmethoden in CGeoTriangleList:
	void Copy(CGeoTriangleList & trianglelist); // Kopiert TriangleList in die aktuelle hinein
	void Subdivide(float fLengthMax);  // Wandelt Mesh in ein Subdivision-Mesh mit mehr Polygonen um, abhängig von der maximalen Kantenlänge fLengthMax
	void SubdivideX(float fLengthMax); // Wandelt Mesh in ein Subdivision-Mesh mit mehr Polygonen um, abhängig von der maximalen Kantenbreite fLengthMax in X-Richtung
	void SubdivideY(float fLengthMax); // Wandelt Mesh in ein Subdivision-Mesh mit mehr Polygonen um, abhängig von der maximalen Kantenhöhe fLengthMax in Y-Richtung
	void SubdivideZ(float fLengthMax); // Wandelt Mesh in ein Subdivision-Mesh mit mehr Polygonen um, abhängig von der maximalen Kantentiefe fLengthMax in Z-Richtung

	CGeoTriangleList * ExtractSubdivition(float fLengthMax); // Extrahiert Subdivision-Mesh mit mehr Polygonen aus dem aktuellen Mesh, abhängig von der maximalen Kantenlänge fLengthMax
	CGeoTriangleList * ExtractSubdivitionX(float fLengthMax);// Extrahiert Subdivision-Mesh mit mehr Polygonen aus dem aktuellen Mesh, abhängig von der maximalen Kantenbreite fLengthMax in X-Richtung
	CGeoTriangleList * ExtractSubdivitionY(float fLengthMax);// Extrahiert Subdivision-Mesh mit mehr Polygonen aus dem aktuellen Mesh, abhängig von der maximalen Kantenhöhe fLengthMax in Y-Richtung
	CGeoTriangleList * ExtractSubdivitionZ(float fLengthMax);// Extrahiert Subdivision-Mesh mit mehr Polygonen aus dem aktuellen Mesh,  abhängig von der maximalen Kantentiefe fLengthMax in Z-Richtung
Löschen folgender Methoden in CGeo, CGeoTriangleList und CGeoTriangleStrip, die die ganze Smart Allocation durcheinanderbrachte und bei Studierenden zu verwirrung führte:
	void Init(int iAllocVertices); 
Umstellen der Pluralklasse CEmitters auf SmartAllocation, Methoden Sub und Kill hinzugefügt
Viele veraltete Kommentare gelöscht, neue hinzugefügt


02.05.2013 TB:
Axis-Aligned-Billboards und Billboard-Scaling nun möglich, dafür folgende neue Methoden in CPlacement: 
	void SetBillboardX();
	void SetBillboardY();
	void SetBillboardZ();
	void SetBillboardScaling(float fx, float fy);
	float GetBillboardScalingX();
	float GetBillboardScalingY();
Bugfix in CGeoEllipsoid: Bumpmapping wurde beim bizylindrischen und quadrobizylindrischen Mapping an einigen Stellen falsch berechnet
Es werden nun semantische Netzwerktopologien bei CGeoEllipsoid, CGeoShpere und CGeoDome berücksichtigt => UV-Mapping sieht bei Quadro- und bizylindrischen Mapping besser aus, es gibt keine Artefakte mehr: 
Konstante QUARTERPI in Util.h hinzugefügt

07.05.2013 TB + KE:
Network Klassen von Klaus in das Projekt integriert
Network-Klassen etwas an die polnische Datentypnotation angepasst
TestbedNetworkMaster und TestbedNetworClient erstellt

07.05.2013 TB:
Neue Methoden in CGeo.h:
	void MapPlanarX(); // Planares UV-Mapping entlang der X-Achse
	void MapPlanarY();  // Planares UV-Mapping entlang der Y-Achse
	void MapPlanarZ(); // Planares UV-Mapping entlang der Z-Achse
	void MapCubic(); // Vereinfachtes kubisches UV-Mapping
	void MapCylindricalY(); // Zylindrisches UV-Mapping um die Y-Achse
	void MapBicylindricalY(); // Bizylindrisches UV-Mapping um die Y-Achse
	void ReduceRedundancy(bool bSmooth = true); // Reduziert redundante Vertices (Achtung!!! Braucht sehr lange, nur in Notfällen benutzen)
	void Magnet(CHVector v, float fRadius, float frStrength, bool bAttract, EMagnetKind eKind = eMagnet_Center); // Neuartige Modellierungsmethode (Magnet, der die Vertices im Radius fRadius anzieht bzw. abstößt)
Neue Methoden in CGeoTriangleList.h:
	void FlattenFaces(); // Macht jedes Polygon flach, indem die Normalenvektoren senkrecht zur Fläche ausgerichtet werden
	void EstimateTangentsAndBitangents(); // Versucht, die Tangenten und die Binormalen für das Bumpmapping aus den gegebenen UV-Koordianten zu erraten  

08.05.2013 TB:
Bugfix: Beim allerersten Tick wurde manchmal ein nicht vorhandener Mausklick von ButtonPressed, ButtonPressedLeft, ... etc. zurückgegeben
Neue Methoden in CViewport:
	bool SubOverlay(COverlay * poverlay); // Hängt ein vorhandenes 2D-Sprite vom Viewport ab, gibt true aus, wenn's geklappt hat
	bool SubBackground(CBackground * pbackground); // Hängt ein vorhandenes 2D-Background vom Viewport ab, gibt true aus, wenn's geklappt hat

09.05.2013 TB:
Es sind nun Gehrungen in CGeoWall möglich, dafür folgende vier neue Methoden in CGeoWall:
	void SetMiterLeft(float faLeft); // Gibt eine eventuelle linke Wandgehrung im Bogenmaß an, muss vor Init aufgerufen werden
	void SetMiterRight(float faRight); // Gibt eine eventuelle linke Wandgehrung im Bogenmaß an, muss vor Init aufgerufen werden
	void SetMiterTop(float faLeft); // Gibt eine eventuelle obere Wandgehrung im Bogenmaß an, muss vor Init aufgerufen werden
	void SetMiterBottom(float faRight); // Gibt eine eventuelle untere Wandgehrung im Bogenmaß an, muss vor Init aufgerufen werden
Bugfix in CGeoWindow: Bei runden Fenstern, die außerhalb von Giebeln gesetzt wurden, wurde der rechte untere Teil angezeigt
Bugfix in CGeoWall: Bitangente wurde auf Rückseite nicht richtig ausgerechnet => Bumpmapping sah dort seltsam aus
Bugfix in CGeoTriangleList::Subdivide: Bitangente wurde bei inversen Texturen nicht richtig ausgerechnet => Bumpmapping sah dort seltsam aus
Zwei neue Methoden in CFloatRect:
	float GetXMid(); // Gibt die Mitte in X-Richtung aus
	float GetYMid();  // Gibt die Mitte in Y-Richtung aus
Neuer Konstruktor in CVertex:
	CVertex(CHVector &  vPos, CHVector & vNormal, CHVector & vTangent, CHVector & vBitangent, float fU, float fV);

12.05.2013 TB:
Neue Modellierungsmethoden in CGeo:
	void WaveX(float fAmplitude, float fWavelength, float fOffset, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Wellenform in Richtung der X-Achse
	void WaveY(float fAmplitude, float fWavelength, float fOffset, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Wellenform in Richtung der Y-Achse
	void WaveZ(float fAmplitude, float fWavelength, float fOffset, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Wellenform in Richtung der Z-Achse
Bugfix in den Taper-Methoden: Tangenten- und Bitangentenvektoren wurden nicht richtig neuberechnet
Neue Methoden in CGeoWall:
	void AvoidCracks(); // Versucht, Tiles, so anzuordnen, dass sie auch für anschließendes Tapering, Bending und Twisting in Y-Richtung geeignet sind
	void SetDeclinationZ(float fa, float fTranslationZ); // neigt die Wand um den Winkel fa nach hinten und verschiebt sie in Z-Richtung
	void SetRoundingX(float fa, float fLengthMax = 0.2f); // Gibt eine eventuelle Wandrundung in X-Richtung ein (z.B. um Türme zu erzeugen)
	void SetRoundingY(float fa, float fLengthMax = 0.2f); // Gibt eine eventuelle Wandrundung in Y-Richtung ein (z.B. um Kuppeln zu erzeugen)
	void InitDome(float fRadius, float fThickness, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.5F, bool bBottom = true, bool bBack = true); // Erzeugt runde Kuppel mit Radius fRadius
	void InitOnionDome(float fRadius, float fHeight, float fThickness,  float fStrength = 0.7, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.2F,  bool bBottom = true, bool bBack = true);  // Erzeugt allgäuer Zwiebeltürmchen mit Radius fRadius und Spitzenhöhe fSpike
	void InitSpikeDome(float fRadius, float fHeight, float fThickness, float fStrength = 0.7, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.2F, bool bBottom = true, bool bBack = true);  // Erzeugt reingebogenes Spitztürmchen mit Radius fRadius und Spitzenhöhe fSpike
	void InitRoundTowerCylinder(float fRadius, float fHeight, float fThickness, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.5F, bool bBottom = true, bool bTop = true, bool bBack = true); // Erzeugt eine Wand für einen runden Turm mit Radius fRadius und Höhe fHeight
	void InitRoundTowerWave(float fRadius, float fHeight, float fThickness, float fAmplitude = 1.0F, float fWavelength = 1.0F, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.5F, bool bBottom = true, bool bTop = true, bool bBack = true); // Erzeugt eine wellenförmige Wand für einen runden Turm mit Radius fRadius und Höhe fHeight
	void InitRoundTowerOriel(float fRadius, float fHeight, float fThickness, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.5F, bool bTop = true, bool bBack = true); // Erzeugt einen Erker für einen runden Turm mit Radius fRadius und Höhe fHeight
	void InitRoundTowerRoof(float fRadius, float fHeight, float fThickness, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.5F, bool bBottom = true, bool bBack = true); // Erzeugt ein glattes Spitzdack für runde Türme

|--------------------------------------------------------------------------------------|
|    12.05.2013 TB: V9 Alpha erstellt (noch nicht online, nur auf Laufwerk L)		   |
|--------------------------------------------------------------------------------------|


13.05.2013 TB:
Bugfix in Debug-Version: Debug-Versionen stürzten auf Laborrechner ab
Bugfix in CGeoWall: InitRoundTowerCylinder: Radius wurde 4 mal so groß gezeichnet
Bugfix in CGeoWall: bei gebogenen Wänden wurden die Parameter bTop und bBottom nicht berücksichtigt
Bugfix in CGeoWall: bei Domes und TowerRoofs wurden die Fenster gegen den Uhrzeigersinn platziert 
Bugfix in CGeo: RippleY, WaveY ... berechneten Normalenvektoren nur ansatzweise richtig
Neue Funktionen in CGeoWall:
	void InitRoundTowerInterface(float fRadiusBottom, float fRadiusTop, float fHeight, float fThickness, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.5F, bool bBottom = true, bool bTop = true, bool bBack = true); // Erzeugt eine Wand-Interface (unterer Radius zu oberem Radius) für einen runden Turm mit Höhe fHeight
	void InitRoundTowerInterfaceSine(float fRadiusBottom, float fRadiusTop, float fHeight, float fThickness, CMaterial * pmaterial = 0, float fEdgeLengthMin = 0.5F, bool bBottom = true, bool bTop = true, bool bBack = true); // Erzeugt ein gebogenes Wand-Interface (unterer Radius zu oberem Radius) für einen runden Turm mit Höhe fHeight
 
|--------------------------------------------------------------------------------------|
|    14.05.2013 TB: V9 Beta erstellt (noch nicht online, nur auf Laufwerk L)		   |
|--------------------------------------------------------------------------------------|

16.05.2013 TB:
Bugfix in CGeoWall: In der Release-Verion wurden manchmal die Tiles nicht angezeigt
	void FlipTangents();
	void FlipBitangents();



22.05.2013 MS:
Neue Klasse CFont (Eng verknüpft mit CText) die für das Handling der Schriftarten und das Erstellen der Geometrie für den Text zuständig ist.
Neue Klasse CText mit der Texte direkt in einer Szene (Ohne Overlay) ausgegeben werden können:
---------------------------------------------------------------------------
   Noch nicht in Vektoria integriert. Vorerst nur in VektoriaEditor		       
---------------------------------------------------------------------------
Methoden:

    bool Init(char* a_acText);  //Initialisiert einen Text mit default Schriftart. Achtung: Jeder Aufruf erzeugt ein neues Material. Nur für Debug-Zwecke verwenden!
    bool Init(char* a_acText, char* a_acFontFilename, char* a_acTextureFilename); //Initialisiert einen Text und erstellt eine neue Schriftart. Diese Methode sollte nur verwendet werden, wenn nicht mehrere Texte mit dem selben Material/Schriftart erzeugt werden.
    bool Init(char* a_acText, char* a_acFontFilename, CMaterial* a_pFontMaterial); //Initialisiert einen Text mit gegebener Schriftart.
    void Fini(void);                                                                    

    char* GetText(void); //Gibt den Text als String zurück.
    bool SetText(char* ac_NewText); //Setzt einen neuen Text.
    void AppendText(char* ac_Text); //Hängt einen String an den Text an.

    float GetTextWidth(void); //Gibt die Breite des Textes in Pixel zurück.

    bool ChangeFont(char* a_acText, char* a_acFontFilename, CMaterial* a_pFontMaterial); //Schriftart ändern.

Beispiel:

    CText* ptext = new CText();
    ptext->Init("Hello World!");
    
    pplacementText = new CPlacement();
    pplacementText->TranslateY(140.0f);
    pplacementText->TranslateXDelta(ptext->GetTextWidth() / -2);
    pplacementText->AddGeo(ptext);
    pplacementRoot.AddPlacement(pplacementText);

Schriftarten können erzeugt werden, indem man eine Textur mit allen Zeichen erstellt und die UV-Koordinaten entsprechend dem File default.txt angibt.


26.05.2013 TB:
	Komplettumbau der Klasse CGeoWindow und CGeoWall => Mitdenken für wenig Polys und keine Artefakte mehr 
Bugfix bei Bounding Boxes, Bounding Boxes wurden nicht berechnet, falls Geo danach geadded wurde
Die Boundingbox-Berechnung kann jetzt komplett unter einem Placement an- und ausgeschaltet werden (Default = off), dafür die Methoden SetBoundingBoxesOff() und SetBoundingBoxesOn() in CPlacement rekursiv gemacht:
Komplett runde und ovale Fenster möglich, dafür folgende neue Methoden in CGeoWindow:	
	void InitOval(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitOvalLeft(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitOvalRight(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitOvalArc(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitOvalArcLeft(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitOvalArcRight(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitOvalU(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitOvalULeft(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitOvalURight(CFloatRect floatrect, bool bAbsolute, int iGranularity = 12);
	void InitU(CFloatRect floatrect, bool bAbsolute = false, int iGranularity = 12); 
	void InitURight(CFloatRect floatrect, bool bAbsolute = false, int iGranularity = 12); 
	void InitULeft(CFloatRect floatrect, bool bAbsolute = false, int iGranularity = 12);
Es können nun Kniestöcke erzeugt werden, auch linke und rechte Giebel versetzt, dafür folgende neue Methoden in CGeoWall: 	
	void SetKneeWallHeight(float frKneeWallHeightLeft, float frKneeWallHeightRight);  // Setzt Kniestockhöhe links und rechts auf unterschiedliche Höhe
	void SetKneeWallHeight(float frKneeWallHeight);  // Setzt Kniestockhöhe links und rechts auf selbe Höhe
	void SetKneeWallHeightLeft(float frKneeWallHeightLeft); // Setzt Kniestockhöhe links
	void SetKneeWallHeightRight(float frKneeWallHeightRight);  // Setzt Kniestockhöhe rechts
	void SetGable(float frCuspLeft, float frCuspRight); // Gibt den linken und den rechten Giebelpunkt an (z.B. 0.0 = an der linken Ecke der Mauer, 0.5 = Mauermitte, 1.0 = ganz rechts an der Mauer)
	void SetGable(float frCusp); // Gibt für Spitzgiebel den gemeinsamen Scheitelpunkt an (z.B. 0.0 = an der linken ecke der Mauer, 0.5 = Mauermitte, 1.0 = ganz rechts an der Mauer
	void SetGableLeft(float frCusp); // Gibt für Spitzgiebel den linken Scheitelpunkt an (z.B. 0.0 = an der linken ecke der Mauer, 0.5 = Mauermitte, 1.0 = ganz rechts an der Mauer
	void SetGableRight(float frCusp); // Gibt für Spitzgiebel den rechten Scheitelpunkt an (z.B. 0.0 = an der linken ecke der Mauer, 0.5 = Mauermitte, 1.0 = ganz rechts an der Mauer
Alle Fensterseiten können nun einzeln versteckt werden, dafür folgende Methoden in CGeoWindow: 
	void HideLeft();
	void HideLeftUpper();
	void HideLeftLower();
	void HideRight();
	void HideRightUpper();
	void HideRightLower();
	void HideBottom();
	void HideTop();
Nun Erker und Anbautürme möglich, dafür folgende neue Methode in 
	void SetSpareAngleX(float fa); // Gibt den Aussparungswinkel um die Y-Achse für eine gebogene Wand Turm / Zylinder an.=> Möglichkeit für Anbauten, Erker Beitürmchen etc.
Neue Kopiermethode in CGeoWall:
	void Copy(CGeoWall &zgw); // Kopiert Werte aus zgw in aktuelle hinein, erzeugt Kopien jedes einzelnen Vertex
Neue Justierungsmethode in CWall => Größere Lo-Poly-Gebäude mit runden Wänden möglich
	void Adjust(CGeoWall & geowallTop, bool bAdjustMapping = true); // Justiert die oberen Vertices so, dass sie zur Wand geowallTop passen
Neue Verschmelzungsmetnode in Klasse CVertex:
	void UniteDirections(CVertex & vertex2);  // Verschmilzt Normalen-, Tangenten- und Bitangenteninformationen der beiden Vertices this und vertex2
CGeo::ReduceRedundancy verbessert, es werden auch n-Redundanzen ausgemerzt
Neue Methoden in Pluralklasse CVertxs:
	void CopyHierarchy(CVertexs vertexs); // Kopiert komplette Unterhierarchie und erzeugt Kopien jedes einzelnen Vertex
	CVertex CalcMid(); // Mittelt alle Werte aller Vertices und gibt sie aus
	void SetPos(CHVector & v); // Setzt die Positionen in allen Vertices auf den Wert v
	void SetNormal(CHVector & v); // Setzt die Normalenvektoren in allen Vertices auf den Wert v
	void SetTangent(CHVector & v); // Setzt die Tangentenvektoren in allen Vertices auf den Wert v
	void SetBitangent(CHVector & v); // Setzt die Bitangentenvektoren in allen Vertices auf den Wert v
	void Transform(CHMat & m); // Transformiert alle Vertices mit der Matrix m
Octrees angefangen (für spätere Kollisionserkennung und Beschleunigung von Geometrieoperationen)=======


27.05.2013 MS:
Umbau der Pluralklasse CVertexs.
Umstrukturierung des Codes.

Folgende Neue Methoden zur Speicherverwaltung:
    	void Reserve(unsigned int uiCapacity);
    	void Resize(unsigned int uiCount);
    	void Clear(void);
    	void ClearAndDelete(void);

Überladung des Index Operators:
    	CVertex* operator[](unsigned int i) const;
    	CVertex*& operator[](unsigned int i);

Folgende Neue Methoden:
    	void AddRange(CVertex** apVertices);
    	void AddRange(CVertex** apVertices, unsigned int uiCount);

    	void Insert(unsigned int uiAt, CVertex* pVertex); //Insert given vertex at position uiAt
    	void AddFirst(CVertex* pVertex); //Insert given vertex at position 0            

    	bool Find(CVertex* pVertex, unsigned int &uiPos); //Stores position of given vertex in uiPos
    	void Remove(unsigned int uiAt); //Remove vertex at position uiAt
	bool Sub(CVertex* pVertex); //Remove given vertex

	unsigned int GetCount(void) const;  //Returns number of vertices

Membervariablen < CVertex** m_apvertex > und < unsigned int m_iVertexs > sollten nichtmehr direkt verwendet werden. In Zukunft Indexoperator und GetCount() verwenden!

Klasse CText: Methode SetText(...) zum setzten eines neuen Strings gefixt -> Rücksprache mit Tobi wegen: CGeoTriangleList::m_bFirstDraw = true; damit der Text geupdatet wird. Ist das richtig so?



2013.05.30 TB:
Neue Funktion in CHVector:
	bool IsNull(); // Gibt true aus, wenn alle Tupelwerte auf Null sind
Neue Funktion in CHMat:
	bool IsScaledToNull(); // gibt bei Nullskalierung true aus
Neue Tauschmakros in Util.h: 
	#define UM_SWAP_F(f1,f2)	// Tauscht die Werte zweier Floats miteinander aus
	#define UM_SWAP_I(i1,i2)	// Tauscht die Werte zweier Integers miteinander aus
	#define UM_SWAP_V(v1,v2)	// Tauscht die Werte zweier Vektoren miteinander aus
Sweeping lässt sich jetzt in alle drei Achsenrichtungen ausführen
Klasse CGeoSweep total überarbeitet, beschleunigt und "entrümpelt"
UV-Mapping sieht bei Sweeping jetzt besser aus und lässt sich toggeln, dafür folgende neue Methoden in CGeoSweep:
	void SetPlanarMappingAxis(int eAxis); // Setzt die Planare Mappingachse, 0 = X, 1 = Y, 2 = Z   
	void SetPlanarMappingBottomOn(); // Erzeugt planares Mapping an der Basisreihe, muß vor Init aufgerufen wer
	void SetPlanarMappingTopOn(); // Erzeugt planares Mapping an der Kopfreihe, muß vor Init aufgerufen werden
	void InitRadial(CHVector vSize, CMaterial * pmaterial, int iLongitude, int iLattitude, float * afrRadius, float * afrDistance, bool bFlip =false, int eAxis = 1); // Initialisiert eine extrudierte Geometrie, vSize=allgemeine Skalierung, iLongitude = Anzahl radialer Vertices, iLattitude= Anzahl vetrices entlang des Pfades, afRadius  = Array von iLattitude Radien, afrDistance = Array von iLattitude Abständen zum Anfang des Pfades  
	void InitCircle(CMaterial * pmaterial, int iLongitude, CHMats & matsPath, int eAxis = 1); // Initialisiert eine extrudierte Geometrie,  iLongitude = Anzahl radialer Vertices, CHMats = hommogene Matrizen zum Plazieren, Skalieren und Rotieren des Pfades
Bugfix in CGeoSlice: letztes Polygon wurde manchmal nicht richtig geshadet
Bugfix in CGeoCylinder: Tangenten und Bitangenten wurden an der Basis falsch berechnet 
Vertices-Pluralklasse restauriert
Alle Pluralklassen in Smart Allocating umgewandelt (auch die Lichtklassen, IntRect, Hardware ...) 
Alle Pluralklassen haben nun eine Funktion Sub, um Objekt von Hierarchie abzuhängen
Bugfix in allen Pluralklassen::Sub()  : Nach dem Abhängen konnte man die Objekte nicht wieder anhängen. => Sub sollte nun einwandfrei funktionieren 
Punkt- und Spot-Lichter können jetzt an verschiedene Placements angehangen werden 
Bugfix in CLightSpot: Near und Far-Clipping-Plane wurde überschrieben, falls Init nach SetClippingPlane aufgerufen wurde 
Man kann nun auch während der Laufzeit (Tick) Placements an- und abhängen (war vorher nicht möglich) 
Testtasten für Sub in TestbedGeneral inklusiert ("P" hängt Mond ab, "O" wieder dran)
Neue Funtionen in CScene:
	bool SubPlacement(CPlacement * pplacement); // Hängt ein Placement von einer Szene ab, gibt true aus, wenn es geklappt hat.
	bool SubLightParallel(CLightParallel * pparallelLight);	// Hängt ein direktionales Licht von der Szene ab, gibt true aus, wenn es geklappt hat.
In Editor CText:
	CGeoTriangleList::m_vertices.ClearAndDelete(); in gleichwertiges CGeoTriangleList::m_vertices.Fini(); umgewandelt
 

2013.06.03 TB:
Bugfix: Billboards wurden nicht angezeigt, wenn SetBillboardAngle ohne SetBillboardScaling aufgerufen wurde 
Klasse CFaces entrümpelt
CGeoSweep, CGeoTube, CGeoCylinder und CGeoCone können jetzt in alle drei Achsenrichtungen erzeugt werden, dafür jeweils folgende Funktion:
	void SetAxis(EAxis m_eAxis); // Setzt Modellierungsachse
Neue Funktionen in CHMat:
	void Rotate(EAxis eAxis, float fa);		// Generiert Rotationsmatrix um kartesische Achse eAxis mit Winkel fa
	void Translate(EAxis eAxis, float f); // Generiert Verschiebungsmatrix in Axenrichtung, die durch eAxis festgelegt ist
	void RotateDelta(EAxis eAxis, float fa); // Generiert beliebige Rotationsmatrix um die Drehachse eAxis mit Winkel fa und multipliziert diese mit der aktuellen Matrix  
	void TranslateDelta(EAxis eAxis, float f); // Generiert Verschiebungsmatrix in Axenrichtung, die durch eAxis festgelegt ist, und multipliziert diese mit der aktuellen Matrix 

2013.06.05 TB:
GeoQuads können etzt in alle drei Achsenrichtungen erzeugt werden, dafür jeweils folgende Funktion:
	void SetAxis(EAxis m_eAxis); // Setzt Modellierungsachse
CGeoQuad:Init(CFloatRect ...) in CGeoQuad:InitForSprites(CFloatRect ...) umbenannt (Alter Name führte bei Anwendern öfters zu Verwirrung)
CGeoQuad von alten Headern, Parametern, etc. "entrümpelt"
Bugfix in CGeoQuad::Init Textur wurde auf dem Kopf gemappt

2013.06.06 TB:
Klasse CPlacement komplett umgebaut:
	Es können nun mehrere verschiedene Geometrien, Pointlights, Spotlights, Drwables, Audios und Cameras an ein und dasselbe Placement an- und abgehangen werden !
CPlacement::AddSound in CPlacement::AddAudio umbenannt
Pluralklasse CDrawables eingefügt
Pluralklasse von CAudio erweitert, nun können gleiche Soundfiles parallel (kanonmäßig) abgespielt werden
Neue Methoden in CAudios:
	void Add(CAudio * paudio);
	bool Sub(CAudio * paudio);
	CAudio * Make(char *stringWavFile, HWND hwnd);
	bool Kill(CAudio * paudio);
	void PauseCauseLoD(int iAudio);
	void ContinueCauseLoD(int iAudio);
	void Listen(CHMat & mListener, int iAudio); // Positioniert den Zuhörer beim 3D-Audio mittels der globalen Matrix mListener
Zwei neue Methoden in CHMat:
	void ProjectionOrtho(float fWidth, float fHeight, float fNear, float fFar); // Generiert eine orthografische Projektionsmatrix 
	void ProjectionFov(float fWidth, float fHeight, float fNear, float fFar); // Generiert eine foveale Projektionsmatrix 
Projektionsberechnung in CLight, CLightParallel, CLightSpot und CLightRadial vereinfacht und beschleunigt (pro Licht und Frame 23 Funktionsaufrufe weniger)
Alle Includes von xnamath.h und D3Dmath.h aus den Headern des Cores herausgenommen, entsprechende Funktionen durch eigene ersetzt => Schöne saubere Trennung zwischen Core (ohne Fremdbibliotheken) und DirectX (mit Direct-Bibliotheken) - Vorbereitung für spätere Trennung in verschiendene Libraries

2013.06.07 TB:
Leichte Beschleunigung von CPlacement, indem die Ermittlung ob ein transparentes Geo vom Tick in die Add- und Sub-Methoden verschoben wurden 
Folgende neue Methoden in CPlacement:
	bool SubLightSpot(CLightSpot * pspotlight); // Hängt das Scheinwerferlicht wieder von dem aktuellen Placement ab, gibt true aus, wenns geklappt hat
	bool SubLightRadial(CLightRadial * ppointlight); // Hängt das Punktlicht wieder von dem aktuellen Placement ab, gibt true aus, wenns geklappt hat
	bool SubDrawable(CDrawable * pdrawable); // Hängt das Drawable wieder von dem aktuellen Placement ab, gibt true aus, wenns geklappt hat
Lichter-Klassen optimert

2013.06.07 TB:
Einige neue Vektorfüllmethoden (auf Wunsch von Projektgruppe)
	void SetXYZW(float f); // setzt alle Werte auf Wert f
	void SetXYZ(float f); // setzt XYZ-Werte auf Wert f
	void SetXYZ0(float f); // setzt XYZ-Werte auf Wert f, W-Wert auf 0
	void SetXYZ1(float f); // setzt XYZ-Werte auf Wert f, W-Wert auf 0
	void NormalX(); // setzt Vektor auf X-Normale (1,0,0,0)
	void NormalY(); // setzt Vektor auf Y-Normale (0,1,0,0)
	void NormalZ(); // setzt Vektor auf Z-Normale (0,0,1,0)

	//------------------------------------------------------------------------------
	// Vektoria V9 erstellt, Manual upgedatet, VektoriaV9App + VektoriaV9HalloWelt erstellt
	//------------------------------------------------------------------------------

2013.06.13 MS:
AABBs in CNode überarbeitet:
    bool    m_bAABBOn; // Boolsches Flag, um die AABB des Knotens aus (false) bzw. an (true) zu schalten
    bool    m_bVisualHelpersEnabled; // Boolsches Flag, um die Visualisierung der AABB aus (false) bzw. an (true) zu schalten
    CAABB   m_aabbBounds; // Axis Aligned Bounding Box

	void SwitchAABBOn(bool a_bSwitchSubtreeOn = false); // Schaltet AABBs für diesen Node und seine gesamte Unterhierarchie an
	void SwitchAABBOff(bool a_bSwitchSubtreeOff = false); // Schaltet AABBs für diesen Node und seine gesamte Unterhierarchie aus

    void EnbaleVisualHelper(void); // Schaltet die Visualisierung der AABB nur für diesen Node an
    void DisableVisualHelper(void); // Schaltet die Visualisierung der AABB nur für diesen Node aus
    void EnableVisualHelpers(void); // Schaltet die Visualisierung der AABBs für diesen Node und seine gesamte Unterhierarchie an
    void DisableVisualHelpers(void); // Schaltet die Visualisierung der AABBs für diesen Node und seine gesamte Unterhierarchie aus
	
Alle Nodes erben die Einstellungen für die AABBs vom übergeordneten Node.
D.h.: Hängt man eine Geometrie an ein Placement, bei dem die AABBs angeschaltet sind, ist die AABB automatisch auch für die Geometrie angeschaltet.
!!! Ob das sinnvoll ist sollte noch besprochen werden.
Standardmäßig sind AABBs ausgeschaltet.

Neue virtuelle Methode die den Klassennamen eines Nodes zurückgibt.
	virtual const char* ClassName(void); //Gibt den Namen der Klasse zurück
Alle Klassen die von Node abgeleitet werden geben somit beim Aufruf dieser Methode ihren Klassennamen zurück.
z.B. CGeoSphere::ClassName() gibt "CGeoSphere" zurück CPlacement::ClassName() gibt "CPlacement" zurück. (Wird für den Editor benötigt.)

Zwei neue Methoden für das "Picking" eines beliebigen Knotens (Placement, Geo, Camera, etc.)
    bool IntersectSubtree(CHVector &a_vOrigin, CHVector &a_vRayDirection, CNode** r_pNode); //Dursucht die komplette Unterhierarchie nach einem Schnitt mit dem Picking-Ray und gibt den ersten getroffenen Knoten zurück.
    bool Intersects(CHVector &a_vOrigin, CHVector &a_vRayDirection); //Prüft ob der PickingRay den Node schneidet und gibt bei einem Schnitt mit der AABB den Knoten zurück.

Bugfix:
Die Methode CNode::Draw(... ) zeichnet - wenn die "VisualHelpers" eingeschaltet sind - nun die AABBs des jeweiligen Nodes richtig.
Ausserdem wurde eine sehr zeitaufwändige Resize Methode entfernt, die eine extreme FPS-reduzierung zur Folge hatte, wenn "VisualHelpers" eingeschaltet waren.

TODO: 
Update der AABBs ist noch nicht richtig implementiert.


2013.07.04 MS:
Neue Methode in CHMat
    void GetRotation(float &fYaw, float &fPitch, float &fRoll); // Converts the matrix back to yaw, pitch, roll angles. [yaw: around the Z-Axis], [pitch: around the Y-Axis], [roll: around the X-Axis]

CNode hat neuen Member const char* m_acName; damit Benutzer im Editor eigene Namen für die Objekte anlegen könne

2013.07.18 TB:
Bugfix: Backgrounds wurden ohne Rotationsangabe nicht richtig angezeigt
Geometrien können nun an andere Geometrien geadded werden, dies sorgt bei komplexen Game Levels für mehr Übersichtlichkeit, dafür folgende neue Methoden in CGeo:
	void AddGeo(CGeo * pgeo); // Hängt eine Geometrie an eine andere Geometrie an
	bool SubGeo(CGeo * pgeo); // Hängt die Geometrie wieder von der aktuellen Geometrie ab, gibt true aus, wenns geklappt hat
	bool HasTransparent(); // Gibt true aus, wenn irgenein transparentes Objekt an die Geometrie angehangen wurde
Matrizenberechnungen in CCamera vereinheitlicht, vereinfacht und beschleunigt
Cameras können nun auch in orthographische Parallelprojektion umgeschaltet werden (wichtig für CAD-Anwendungen und Dreitafelprojektionen), dafür folgende neue Methoden in CCamera:
	void SetOrthoOn(); // Schaltet Kamera in Othogonalprojektionsmodus
	void SetOrthoOff(); // Schaltet Kamera wieder in normalen fovealen Projektionsmodus (default)

2013.07.26 MS:
- Abstürtze beim Minimieren des Fensters sollten behoben sein. -> Siehe CFrame
- Umbau von VektoriaApp.cpp -> Einfacherer und übersichtlicherer Code (vorallem für WindowResize)
- F11 (Windows standrad) für Vollbildmodus
    - TODO: Alte Breite und Höhe des Fensters merken und beim Verlassen des Vollbildmodus wieder setzten. (Wird momentan fest auf 1980x1080 gesetzt.)
- CCamera wieder alten Code für ProjectionMat eingbaut, da neuer nicht das gleiche gemacht hat wie der alte.

2013.07.29 TB:
Pluralklasse CGeoWalls eingefügt.
GeoWalls können jetzt DIREKT an GeoWindows drangehängt werden (übersichtlicher, stringenter und eröffnet für die Zunkunft mehr Möglichkeiten), dafür folgende Methoden in CGeoWindow:
	void AddGeoWall(CGeoWall * pgeowall);
	bool SubGeoWall(CGeoWall * pgeowall);
	void Draw(float & fDistanceToCameraSquare, CHMat & mGlobal);
	// bis jetzt nur bei geraden Wänden möglich, gebogene Wände sollen folgen
GeoWalls können jetzt als Geometrie verschoben werden, dafür folgende Funktion: SetMat()
CGeoWalls und CGeoWindow jetzt von CNode abgeleitet // Habe der EInfachkeit halber einige virtual-Methoden in CNode in normale Methoden umgewandelt
Bugfix in CPlacment: Matrizen wurden teilweise noch nach Fixing berechnet 

 
2013.07.29 PF:
Turntablenavigation hinzugefügt.
Navigation, die vor allem aus der Vogelperspektive sinnvoll ist. 
Ermöglicht Orbitrotation, Zoom und WASD Steuerung.
Die meisten Parameter der Steuerung lassen sich anpassen.

2013.08.09 TB:
Veralteter Parameter prenderapi aus CScene::Draw, CScenes::Draw, CPlacement::Draw und CPlacements::Draw entfernt => Beschleunigung
Bugfix in CGeoWall: Bei bestimmten Parametrisierungen von SetRoundingY trat Endlosschleife auf. 
Unterwalls werden jetzt in Window-Hierarchie richtig plaziert, siehe neue Demo in TestbedGeo, TODO: Funktioniert noch nicht zusammen mit FixAndFasten
Vektoria-Manual, FAQs und UML-Hierarchieskizze erneuert auf V9

2013.08.19 TB:
Neue Funktionen in CHVector:
	float AngleYX(); // gibt auf die XY-Ebene projizierten Drehwinkel im Bogenmaß aus (Null entspricht Z-Achse);
	float AngleXZ(); // gibt auf die XZ-Ebene projizierten Drehwinkel im Bogenmaß aus (Null entspricht X-Achse);
	float AngleZY(); // gibt auf die YZ-Ebene projizierten Drehwinkel im Bogenmaß aus (Null entspricht Z-Achse);
Neue Klassen für Geraden und Strahlen CRay und CRays eingefügt:
In CRay folgende neue Methoden:
	CRay operator=(CRay ray); // Kopieroperator von Strahl ray
	void Copy(CRay ray); // Kopiert von Strahl ray 
	void Init(CHVector & vOrigin, CHVector & vDirection); // Initialieret Strahl ray
	void InitFromTo(CHVector & vOrigin, CHVector & vTo); // Initialieret Strahl ray mittels Start- und Endvektor
	void SetMin(float fMin); // Setzt Strahlminimaldistanz ausgehend von vOrigin
	void SetMax(float fMax); // Setzt Strahlmaximaldistanz ausgehend von vOrigin
	float GetMin();  // Gibt Strahlminimaldistanz ausgehend von vOrigin aus
	float GetMax(); // Gibt Strahlmaximaldistanz ausgehend von vOrigin aus
	float Distance(CRay & ray); // Berechnet den minimalen Abstand zweier Strahlgeraden
	float Distance(CHVector & v); // Berechnet den kleinsten Abstand der aktuellen Strahlgeraden von Punkt v
	float Angle(CHVector & v); // Berechnet den Winkel der Strecke zwischenvOrigin und Punkt v zum Strahl 
Pluralklasse CRays wie gewohnt mit Smart Allocation, Kopieroperator, Add, Sub, Make und Kill 
Klasse GGeoWing für komplexe Gebäudestrukturen eingefügt
Neue Methode in CGeoWall:
	void SetGableByAngle(float faLeft, float faRight); // Erzeugt Gabelpunkte, indem die Winkel ausgehend von den unteren Ecken angegeben werden
Bugfix: Nulldivision in CDevice::Init bei fehlendem Adden 

2013.08.20 MS:
Speicherleck in CText Entfernt.
Diverse Copy-Methoden (CopyTranslation, CopyRotation, CopyScale) in CHMat und CPlacement hinzugefügt.
Neue Methode "int GetKey(void)" in CDeviceKeyborad eingebaut. -> Gibt die aktuell gedrückte Taste zurück.
Neue Methode "char GetChar(void)" in CDeviceKeyboard eingebaut. -> Zuordnung der DirectX-Keycodes (z.B. DIK_A) zu charaktern (deutsches Tastaturlayout).
Editor Textboxen und Texteingabe für Position, Rotation und Skalierung von Objekten.
 
2013.08.21 TB:
Veraltete Funktionen in CFace gelöscht (Fini etc.)
Rechte und linke Gehrung können sich nun ohne Artefakte überkreuzen
Vereinfachung und Beschleunigung der Vertexberechnung in CGeoWall
Bugfix: GetRightCuspByAngle gab bei HALFPI 0 statt 1 aus

2013.09.04 TB:
Neue Klassen für Ebenen eingefügt: CPlane inclusive Pluralklasse CPlanes
In CPlane folgende neue Methoden:
	CPlane(CHVector * pvA, CHVector * pvB, CHVector * pvC); // Initialisiert eine Ebene durch die Angabe dreier Punkte
	CPlane(CHVector & vPoint, CHVector & vNormal); // (Re-)initialisiert eine Ebene durch die Angabe eines Punktes plus Normalenvektor
	~CPlane();
	CPlane operator=(CPlane & plane); // Kopieroperator
	void Copy(CPlane & plane); // Kopierfunktion
	void Init(CHVector * pvA, CHVector * pvB, CHVector * pvC); // (Re-)initialisiert eine Ebene durch die Angabe dreier Punkte
	void Init(CHVector & vPoint, CHVector & vNormal); // (Re-)initialisiert eine Ebene durch die Angabe eines Punktes plus Normalenvektor
	float Angle(CPlane & plane); // Berechnet den Schnittwinkel zwischen zwei Ebenen
	CRay Intersect(CPlane & plane); // Berechnet die Schnittgerade zweier Ebenen
	CHVector Intersect(CPlane & plane2, CPlane & plane3); // Berechnet den Schnittpunkt dreier Ebenen
	CHVector Intersect(CRay & ray); // Berechnet Schnittpunkt eines Strahls mit der Ebene // noch ungetestet
	bool IsFront(CHVector & v); // true, wenn v vor der Ebene liegt, false ansonsten
	bool IsIn(CHVector & v); // true, wenn v in der Ebene liegt, false ansonsten
	bool IsBack(CHVector & v); // true, wenn v hinter der Ebene liegt, false ansonsten
	float GetD(); // Gibt D-Parameter der Ebene aus
	CHVector GetNormal(); // rechnet Normale der Ebene aus
	float Distance(CHVector & v); // gibt die Entfernung des angegebenen Punktes zur Ebene aus, liegt Punkt hinter der Ebene, wird der Wert negativ
Pluralklasse CPlanes wie gewohnt mit Smart Allocation, Kopieroperator, Add, Sub, Make und Kill 
GGeoWing erzeugt jetzt schon die Grundfassaden (noch ohne Fenster und Türen) von Gebäudestrukturen (übersichtliche Klasse soll ab V10 die Quick'n Dirty-Methoden MakeRoof und MakeWallByWindow in CPlacement ersetzen) 


2013.09.12 PF:
Namespace Vektoria eingefügt. Löst ebenfalls das Problem mit den DX-Makro-Compilerwarnungen.
Weitere Namespaces unterhalb von ::Vektoria wären wünschenswert. Dafür sollte aber ein einhetliches System für die 
Forwarddeclaration in Headern (z.B eine globale Forwarddeclaration) gefunden werden damit der Aufwand für die notwendigen 
Änderungen in den einzelnen Projekten sich in Grenzen hält. 
Wer in seinem Projekt keine hässlichen using namespace Vektoria;-Statements im Header wünscht, muss Das selbständig ändern ;)
Das Ganze ist auch mit der V8 App vom Netzlaufwerk getestet. Es genügt ein using namespace Vektoria; in der game.h damit Es läuft.
Ein Root-Singelton wiederspricht derzeit den Distributionfactory-Klassen, welche wohl mehrere Versionen des SG halten.

2013.09.13 TB:
CGeoWing erzeugt nun ganze Häuserteile bzw. Gebäudeflügel mit Dach und Fenster, verschiedene Dachformen möglich Spitzdach, Mansardendach, Zeltdach ...
Seiten eines Gebäudeflügels können einzeln zu- oder abgeschaltet werden, dafür folgende Methoden in CGeoWing: 
	void HideRoof();
	void ShowLeft();
	void ShowRight();
	void ShowBottom();
	void HideTop();
Fenster können auf ein Gebäudeflügel appliziert werden, dafür folgende Methoden:
	void AddGeoWindow(CGeoWindow * pgeowindow, int iWall, EGeoWingPart ePart = eGeoWingPart_Facade); // Stanzt ein einzelnes Fenster an die Wand mit der Nummer iWall
	void AddGeoWindows(CGeoWindow * pgeowindow, int iWall, CFloatRect floatrect, int ixs, int iys, EGeoWingPart ePart = eGeoWingPart_Facade); // Stanzt ixs mal iys Fenster in den Bereich der Wand mit der Nummer iWall, der mit floatrect angegeben ist
	void AddGeoWindowsRandom(CGeoWindow * pgeowindow, CGeoWindow * pgeowindowDoor, int iWallDoor); // Versucht, die Fanster automatisch zu platzieren
	void AddRandomDoor(CGeoWindow * pgeowindow, int iWallDoor); // Fügt eine Tür hinzu, die automatisch plaziert wird
	void AddRandomWindow(CGeoWindow * pgeowindow); // Fügt ein Fenster hinzu, das automatisch plaziert wird
	void AddRandomWindowHighest(CGeoWindow * pgeowindow); // Fügt ein Fenster hinzu, das automatisch in die oberste Fensterzeile plaziert wird
	void AddRandomWindowLowest(CGeoWindow * pgeowindow); // Fügt ein Fenster hinzu, das automatisch in die unterste Fensterzeile plaziert wird
	void AddRandomWindowMid(CGeoWindow * pgeowindow); // Fügt ein Fenstertyp hinzu, das automatisch in die milleren Fensterzeilen plaziert wird
	void AddRandomWindowRoof(CGeoWindow * pgeowindow); // Fügt ein Fenstertyp hinzu, das automatisch auf die Dächer plaziert wird
	void AddRandomWindowCellar(CGeoWindow * pgeowindow); // Fügt ein Fenstertyp hinzu, die automatisch als Kellerfenster plaziert wird
Bei den Methoden AddGeoWindow und AddGeoWindos von CGeoWing und CGeoWall sind jetzt auch absolute Maße möglich


2013.09.18 TB:
Bugfix: Zufallmakros in Util.h UM_RANDRADIAL und UM_RANDRADIALPN funktionierten nicht
Bugfix in Vektoria-App: TimeDelta-Berechnung war ungenau, sie lag sogar teilweise bei schneller Frame-Rate konstant auf Null
Vektoria-App-Klasse durch Herausnahme von redundantem Code beschleunigt und entrümpelt  
Copy-Funktion in CNodes und CNode hinzugefügt
CNode leicht beschleunigt durch Löschung von redundantem Code
In CFloatRect eine Collide-Methode hinzugefügt, die untersucht, ob zwei FloatRects  im 2D-Space miteinander kollidieren. 
In CGeoWindows eine Collide-Methode hinzugefügt, die untersucht, ob zwei Fensterbereiche auf einer Wand miteinander kollidieren. 
Veraltete Kommentare in allen Klassen aufgeräumt
Parent-Child-Struktur vereinheitlicht (bis jetzt aus Zeitgründen nur unterhalb von CPlacement), dafür viele SetRoot-Funktionen herausgenommen  
Erschda Versuch vonner klaanen ekstärnen Koodvärschluesselung (Aas demjenische Grund werd des TeschdbedGeo aa ned bei Eich rischdisch funktioniere), bessere Grübdofunktione werre irschendwann folsche 
namespaces in restliche Pluralklassen eingefügt 
Frage an PF: Vielen Dank für die Namespaces! Halte ich auch für sehr sinnvoll. :-) Hast Du die Namespaces aber auch nach der Erzeugung einer externen Release-SDK getestet? Das war ja beim letzten Mal mein Problem => siehe EIntag vom 09.05.2012

2013.09.21 TB:
In CPlacement alle Beschleunigungsroutinen überarbeitet, alte Routinen erlauben nun noch eine schnellere Beschleunigung als vorher, Neue Methoden Fasten und Unfasten hinzugefügt 
	void Fasten(); // Sortiert nach Status-Calls, um CPUGPU-Traffic zu reduzieren und vereinigt Geometrien mit gleichem Material  => Beschleunigung (Achtung 1, die Rekalkulation dauert lange!, Achtung 2: Transparente Objekte funktonieren nicht mehr), erlaubt Beschleunigung der untergeortneten Hierarachie, das Placement kann im Gegensatz zu FixAndFasten trotzdem noch bewegt werden
	void Unfasten(); // Macht Fasten rückgängig (Achtung, dauert lange)
In CGeoWing folgende Routine hinzugefügt:
	void InitRoundTower(float fRadius, float fHeight, float fHeightRoof, float fThickness, float fOverroofDepth, CMaterial * pmaterialFacade, CMaterial * pmaterialRoof, CMaterial * pmaterialCeiling, float fEdgeLengthMin = 0.2F, bool bInner=false, bool bOpen=false, EGeoWingTowerRoof eKind = eGeoWingTowerRoof_Normal);

2013.10.06 PF
Spotlight wirft nun weiche Schatten via PCF (Percentage Closer Filtering). Shadowmaps mit 8kx8k laufen gerade noch
flüssig genug, um zu zeigen wie nett so eine Shadowmap aussehen kann =). 

2013.10.13 PF
Spotlight hat nun kaskadierte Schatten und bool-Werte um soft/cascaded aus- und anschalten zu können.
Spotlight kann nun bis zu 30 entfernt sein und Schatten werfen. 

 
2013.10.16 TB:
Bugfix: CGeoWall erzeugte bei Gabeln 2 unnötige interne Polygone
CGeoWall kann nun auch Wände mit "negativen" Giebeln erzeugen, also Wände, die nach oben breiter werden. 
CGeoWall hat folgende Methode 
	void SetNrOfFloors(int iFloors); // gibt die zu einer Wand dazugehörige Stockwerksanzahl an, verbessert u.a. die Vorab-Allozierung von Tiles (diese muss dann nicht mehr auf den Maximalwert gesetzt werden), so dass auch nahezu beliebig große Wände möglich sind.
CGeoWing erzeugt nun auch Gebäude mit beliebigen Grundriss, dafür folgende neue Methoden:
	void InitPrintTent(); // erzeugt Gebäude mit beliebigen Grundriss und Zeltdach 
	void InitPrintFlat(); // erzeugt Gebäude mit beliebigen Grundriss und Flachdach
	void InitYardRoof(); // erzeugt Gebäude mit beliebigen Grundriss, Satteldach und Innenhof
	void InitYardFlat(); // erzeugt Gebäude mit beliebigen Grundriss, Flachdach und Innenhof
	void InitYardRutsh(); // erzeugt Gebäude mit beliebigen Grundriss, Schrägdach und Innenhof
	void InitPolyFlat(); // erzeugt Gebäude mit n Kanten und Flachdach
	void InitPolyTent(); // erzeugt Gebäude mit n Kanten und Zeltdach
	void InitRectFlat(); // erzeugt rechteckiges Gebäude mit Zeltdach
	void InitRectMans(); // erzeugt rechteckiges Gebäude mit Mansardendach
	void InitRectTent(); // erzeugt rechteckiges Gebäude mit Zeltdach
	void InitRectSaddle(); // erzeugt rechteckiges Gebäude mit Satteldach
Neue Funktion in CHVector:
	CHVector Mid(CHVector & hvector); // ermittelt Vektor, der genau in der Mitte zwischen aktuellem und angegebenen Vektor liegt
Neue Funktion in CHVectors:
	CHVector Mid(); // Rechnet arithmetischen Mittelpunkt aller Vektoren aus
Bugfix: CFloatRect::Clip schnitt bei Size-Werten über 1.0F falsch ab
Bugfix: UM_ROTINSPANFA(fa) funktionierte nicht
Bei Lichtern wurde pro Tick und Licht die Varialble plightstructure jeweils alloziert und dealloziert => machte Szenen mit vielen Lichtern langsam, dies wurde nun durch eine entsprechende Membervariable m_plightstructure verhindert   
While-Schleife der VektoriaApp.cpp entrümpelt, vereinfacht und beschleunigt

2013.10.20 PF:
In CCameraNavigationTurntable ist eine Pan-Bewegung (Bewegung entlang einer Ebene, die senkrecht zur Kamera steht) mit l.Alt + r. Maustaste verfügbar.
Optional lässt sich die Achsensperre, die verhindert dass unter den Boden oder Überkopf rotiert werden kann in der Init() deaktivieren.

2013.10.24 TB:
3 neue Vektoria-Manuals für V10 erarbeitet: Barr-Modellierung, Hierachitekturmodellierung und Placement-Beschleunigung
12 alte Vektoria-Manuals überarbeitet 
FAQs überarbeitet
Bugfix in CGeoWall: Bei Gehrungen wurden bei bestimmten Winkeln die Seitenwände nicht mehr angezeigt  
CGeoWindows und CGeoWing "entrümpelt", vereinfacht und beschleunigt
Neue Windows-Stile in CGeoWindows:
	void InitV(CFloatRect floatrect, bool bAbsolute = false); 
	void InitVLeft(CFloatRect floatrect, bool bAbsolute = false); 
	void InitVRight(CFloatRect floatrect, bool bAbsolute = false); 
Neue Methoden um Windows-Stile zu modifizieren (inveriert Kurvenzüge):
	void SetInverseCurveAll();
	void SetInverseCurveLeftUpper();
	void SetInverseCurveLeftLower();
	void SetInverseCurveRightUpper();
	void SetInverseCurveRightLower();
Neue AbfrageMethoden in CGeoWindows:
	bool IsStyleRight(); 
	bool IsStyleLeft();
	bool IsStyleSym();

2013.10.25 PF:
Weiche Schatten werden nun mit Randomsampling gerendert (gibt schönere Kanten).

2013.10.28
Environmentmapping ist nun möglich mit: CPixImage * CMaterial::MakeTextureEnvironment( char * acPath )>>>>>>> .r451

2013.10.31 TB:
Neue Testumgebung: TestbedTown, in der die Architekturklassen und Schatten getrennt getestet werden können
Bugfix: System stürzte ab, wen überhaupt kein Material geladen wurde oder überall nur NULL-Pointer als Materialzeiger übergeben wurden, nun wird Default-Material auf jeden Fall im ersten Tick der Root geladen, um dies zu verhindern 
Bugfix: System stürzte ab, wenn Schatten bei mehreren Viewports angeschaltet wurde
Bugfix: Polyflat erzeugte bei Winkeln unter 90° Artefakte
Methoden für die weichen Schatten von Patrick in CLightSpot:
	void SetShadowOn();
	void SetSoftShadowOn();
	void SetCascadedShadowOn();

2013.11.03 PF:
- Parallax Occlusion Maps mit MakeTextureHeight() möglich
- SetTextureHeightAsImage() nicht sinvoll und und wurde entfernt
- Kombination von POM und Bumpmapping möglich
- MSAA wegen GPU-problemen auf 1 in directX::init gesetzt (m_uiSampleCount = 1;)
- Demo in VektoriaTest

2013.11.08 PF:
-Environment Mapping interagiert mit Licht und Schatten
-Weniger Probleme mit POM-Selfshadowing



2013.11.12 MR:
- Neue Version von CFile3DS hinzugefügt.
	Paar Bugs gefixed.
	Primitive Animationen möglich. Wird demnächst erweitert.
- CMaterial hat eine neue Methode: void CMaterial::SetTextureAddressMode(ETextureAddressMode eTextureAddressMode).
- CGeoSkybox hinzugefügt. (Geflippter, speziell UV gemappter Würfel mit allen Normalenvektoren in Richtung Parallellicht. Außerdem immer TextureAddressMode auf Clamp und specular aus)
- Partikelsystem hinzugefügt
	Ein neues Partikelsystem wird erzeugt, indem man einen Emitter erstellt, diesen an ein Placement hängt und das wiederum an eine Szene. Beispiele befinden sich im Testbed "CTestbedParticleSystemExamples"
	Grundsätzliche Methoden des Emitters:
	void Start();
	void Stop();
	void Pause();
	
	Weiterhin kann das System über folgende Methoden konfiguriert werden. Diese sind dabei jeweils Kategorien zugeordnet:
	
	CEBasic Basic;
		void SetDuration(float fDuration);
		void SetMaxParticles(int iMaxParticles);
		void SetLoop(bool bLoop, bool bCoolDown = false);
		void SetBillboardSize(float fBillboardSizeX, float fBillboardSizeY);
		void Prewarm(float fSeconds);
		void SoftParticles(bool bEnabled, float fFactor);
		void Update();
		
	CETexture Texture;
		CEFramesOverTime FramesOverTime;
			void IsRandBetweenGraphs(bool bActive);
			void GraphAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphClear();
		void SetMaterial(CMaterial * pmaterial);
		void SetBlendMode(EBlendMode m_bmBlendMode, bool bAlphaToCoverageEnabled);
		void Update();
			
	CEEmission Emission;
		void SpawnGraphAdd(int iPercent, float fValue);
		void SpawnGraphClear();
		void SpawnBurstsAdd(float fTime, int iParticles);
		void SetSpawnAccuracy(int iSpawnAccuracy);
		void SetSpawnShape(CESpawnShape ssSpawnShape);
		void Update();
		
	CEVelocity Velocity;
		CEVelocityOverTime VelocityOverTime;
			void IsRandBetweenGraphs(bool bActive);
			void GraphXAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphXClear();
			void GraphYAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphYClear();
			void GraphZAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphZClear();
		void Update();
		
	CEForce Force;
		CEForceOverTime ForceOverTime;
			void IsRandBetweenGraphs(bool bActive);
			void GraphXAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphXClear();
			void GraphYAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphYClear();
			void GraphZAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphZClear();
		void Update();
		
	CESize Size;
		CESizeOverTime SizeOverTime;
			void IsRandBetweenGraphs(bool bActive);
			void GraphAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphClear();
		CESizeBySpeed SizeBySpeed;
			void IsRandBetweenGraphs(bool bActive);
			void GraphAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphClear();
			void SpeedRange(float fSpeedRangeBottom, float fSpeedRangeTop);
		void Update();
		
	CERotation Rotation;
		CERotationOverTime AngularVelocityOverTime;
			void IsRandBetweenGraphs(bool bActive);
			void GraphAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphClear();
		CERotationBySpeed AngularVelocityBySpeed;
			void IsRandBetweenGraphs(bool bActive);
			void GraphAdd(int iPercent, float fValueTop, float fValueBottom = 0);
			void GraphClear();
			void SpeedRange(float fSpeedRangeBottom, float fSpeedRangeTop);
		void Update();
	CEColor Color;
		CEColorOverTime ColorOverTime;
			void IsRandBetweenGraphs(bool bActive);
			void GraphAdd(int iPercent, CColor fValueTop, CColor fValueBottom = CColor(1.0f, 1.0f, 1.0f, 1.0f));
			void GraphClear();
		CEColorBySpeed ColorBySpeed;
			void IsRandBetweenGraphs(bool bActive);
			void GraphAdd(int iPercent, CColor fValueTop, CColor fValueBottom = CColor(1.0f, 1.0f, 1.0f, 1.0f));
			void GraphClear();
			void SpeedRange(float fSpeedRangeBottom, float fSpeedRangeTop);
		void Update();
	
2013.11.13 TB:
Bugfix: Environmental- un POM-Texturen luden nicht Default-Material, falls falscher Pfad angegeben wurde   
- Mehrere größere Levels können nun nacheinander geladen und entladen werden
- Scenes können nun von der Wurzel wieder abgehangen werden, dafür folgene Methode in CRoot:
	bool SubScene(CScene * pscene);	// Hängt eine Szene von der Wurzel ab, gibt false aus, wenn die angegebene Szene nicht ein Kind der Wurzel ist oder überhaupt nicht existiert, bei Erfolg wird true ausgegeben 
- Materialien können nun aus Root-Liste wieder abgehängt werden, dafür folgende Funktion in CRoot:
	bool SubMaterial(CMaterial * pmaterial); //Löscht ein Material aus der Materialliste der Wurzel, gibt true aus, wenn es funktioniert hat 
	bool SubAllMaterials(); // Löscht alle Materialien aus der Materialliste der Wurzel, außer dem Defaultmaterial
- und folgene Funktion in Render-API, um Ressorcen wieder freizugeben: 
	bool DeleteMaterial(CMaterial * pmaterial); 		
- Kleine Beschleunigung des Materialladens, durch Entrümpelung von UpdateTextures  
- Übersichtlichere und wenigere verwirrende Benennungen in Render-API-Schnittstelle, ab jetzt: 
	void CreateMaterial(CMaterial * pmaterial);
	void UpdateMaterial(CMaterial * pmaterial); 		
	bool DeleteMaterial(CMaterial * pmaterial); 		
- Zwei neue Methoden in CGeos:
	bool AddOnce(CGeo * pgeo); // Fügt pgeo nur hinzu, wenn es noch nicht in der Liste vorhanden ist
	bool Has(CGeo * pgeo); // Schaut, ob pgeo in der Liste vorhanden ist, gibt true aus, falls ja
ACHTUNG, SOLLTE COMITT NET FUNZE, ERINNERT EUCH AN DES G-HEIMGESPAECH BAAM LETSCHDE TREFFE!

2013.11.13 TB:
- Transform, Subdivition, Barr-Modellierung, Rippleing und Waving funktionieren jetzt auch bei CGeoWings, dafür folgende neue Methoden in CGeoWing: 
	void Transform(CHMat & m); // Transformiert alle Punkte der Geometrie mit der Transformationsmatrix m, polymorphe Überschreibung
	void Subdivide(float fLengthMax);  // Wandelt Mesh in ein Subdivision-Mesh mit mehr Polygonen um, abhängig von der maximalen Kantenlänge fLengthMax, polymorphe Überschreibung
	void SubdivideX(float fLengthMax); // Wandelt Mesh in ein Subdivision-Mesh mit mehr Polygonen um, abhängig von der maximalen Kantenbreite fLengthMax in X-Richtung, polymorphe Überschreibung
	void SubdivideY(float fLengthMax); // Wandelt Mesh in ein Subdivision-Mesh mit mehr Polygonen um, abhängig von der maximalen Kantenhöhe fLengthMax in Y-Richtung, polymorphe Überschreibung
	void SubdivideZ(float fLengthMax); // Wandelt Mesh in ein Subdivision-Mesh mit mehr Polygonen um, abhängig von der maximalen Kantentiefe fLengthMax in Z-Richtung, polymorphe Überschreibung
	void RippleY(float fAmplitude, int iHarmonics, float faPhase = 0.0F, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Wellenriffeln um die Y-Achse, polymorphe Überschreibung
	void RippleYHard(float fAmplitude, int iHarmonics, float faPhase = 0.0F, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Wellenriffeln um die Y-Achse, polymorphe Überschreibung
	void TwistX(float faStrength); // Twisting um die X-Achse, polymorphe Überschreibung
	void TwistY(float faStrength); // Twisting um die Y-Achse, polymorphe Überschreibung
	void TwistZ(float faStrength); // Twisting um die Z-Achse, polymorphe Überschreibung
	void BendX(float fRadius, float faSection); // Bending um die X-Achse, polymorphe Überschreibung
	void BendY(float fRadius, float faSection); // Bending um die Y-Achse, polymorphe Überschreibung
	void BendZ(float fRadius, float faSection); // Bending um die Z-Achse, polymorphe Überschreibung
	void TaperX(float fStrength, bool bInfluenceX=false, bool bInfluenceY=true, bool bInfluenceZ = true); // Tapering in Richtung der X-Achse, polymorphe Überschreibung
	void TaperY(float fStrength, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Tapering in Richtung der Y-Achse, polymorphe Überschreibung
	void TaperZ(float fStrength, bool bInfluenceX=true, bool bInfluenceY=true, bool bInfluenceZ = false); // Tapering in Richtung der Z-Achse, polymorphe Überschreibung
	void WaveX(float fAmplitude, float fWavelength, float faPhase = 0.0F, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Wellenform in Richtung der X-Achse, polymorphe Überschreibung
	void WaveY(float fAmplitude, float fWavelength, float faPhase = 0.0F, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Wellenform in Richtung der Y-Achse, polymorphe Überschreibung
	void WaveZ(float fAmplitude, float fWavelength, float faPhase = 0.0F, bool bInfluenceX=true, bool bInfluenceY=false, bool bInfluenceZ = true); // Wellenform in Richtung der Z-Achse, polymorphe Überschreibung

2013.11.19 TB:
- CPixImage wieder in CImage umbenannt (laut Elescheid v. Jun. 2012)
- Logo in VektoriaApp etwas aufgehübscht
- Poly-Wings können nun an Hauptgebäude angehangen werden (diesbezügliches Testtürmchen in TestbedTown) 
- Artefakte bei vererbten Dachfenstern in runden Türmchen verhindert
- Veraltete Kommentare in verschiedenen Klassen gelöscht 

2013.11.21 TB:
- Bugfix: BumpMapping funktionierte nur noch für Spekulare Texturen => Shaders.hlsl gefixt
- Bugfix: CGeoCube hat jetzt richtigte Normalen, Binormalen und Tangenten (gecheckt)
- Leichte Beschleuigung der Draw Calls (ca. 2%) in PassToGPU 
- Klasse CHVector3 aus Vektoria Core entfernt (Elescheid v. 21.11.2013) und in CLibParticlePhysics verschoben 
	=> Kleine Änderungen in CGeoSkybox und TurntableNavigation notwendig
- CGeoCube hat jetzt zweites Init für Würfelformen statt allgemein Quaderform:
	void Init(float fSize, CMaterial * pmaterial, float fTextureRepeat = 1.0f, bool bFlip = false); // Initialisiert eine Würfelform-Geometrie
- CGeoCube::Resize() auskommentiert und CGeoCube::m_fSize gelöscht (war überflüssig)
- In CMaterial: Neue Texturform für Skydomes, Skycubes, etc. (ging zwar auch schon vorher über Imagetexturen, man musste aber zusätzlich 5 verschiedene Parameter einstellen, nun nur noch ein praktischer Befehl):
  	CImage * MakeTextureSky(char * acPath); // Erzeugt eine Texturhierarchie, die für Skymaps, Skydomes etc. geeignet ist  
	void SetTextureSky(CTexture *ptexture); // Setzt eine Textur, die für Skymaps, Skydomes etc. geeignet ist  

2013.11.28 TB:
- Bugfix: Texturveränderungen während der Laufzeit wurden nicht mehr an DirectX weitergegeben (hatte das schon einmal gefixt)
- Verminderung der Material-DrawCalls (ab jetzt nur wenn sich Material zu vorherigem Call verändert hat) => Beschleunigung
- Animierte Texturen nun möglich, dafür folgende neue Methode in  CMaterial:
	void SetAni(int ixPics, int iyPics, float fFps); // Erzeugt ein animiertes Material 
- Umschaltbare Texturen nun möglich, dafür folgende neue Methoden in CMaterial:
	void SetBot(int ixPics, int iyPics); // Erzeugt ein steuerbares Material
	void SetPic(int ixPic, int iyPic); // Setzt Unterbild bei animierten oder steuerbaren Materialien
- Texturanimation ist nach reiflicher Überlegung keine Eigenschaft von Images sondern von Materials => Altes angefangene Animationsteile in CImage rausgenommen, musste daher auch Partikelcode von Michi eingreifen

2013.11.29 PF:
- 64bit builds für Vektoria/VektoriaApp/VektoriaEditor/VektoriaTest (ein Bug kann dazu führen, dass im Debugmodus ohne angehängten Debugger Objekte fehlen oder falsch transformiert sind, kA woran Das liegen kann)
- Alle Projekte nutzen das /Qpar flag um die Autovektorisierung des MS-Compilers zu nutzen
- BRDF funktioniert nun mit beliebig vielen Lichtern in der Szene, die mehr als 0.1f Helligkeit besitzen>>>>>>> .r478

2013.12.01 TB:
- Materiallade- und Entlademethoden in DirectX komplett überarbeitet, Grund: Bisher wurde das selbe Image mehrfach geladen, wenn zwei Materialien auf das gleiche Image zurückgriffen => Schneller Texturespeicherüberlauf bei Sprites
- Folgende neue Methoden in CDirectX:
	int TexturePathExists(char *acPath);
	bool CreateTexture(CTexture * ptexture, bool bDefaultWhite, int & iTexture); 
- Komplettneubenennung der Variablennamen in CDirectX, die mit Texturen und Materialien zu tun haben (bisher wurde nicht zwischen Texturen und Materialien getrennt, war total durcheinander) 
Bugfix: Copyoperator von CMaterial funltionierte nicht richtig


2013.12.05 TB:
- Writings funktionieren jetzt!
- Folgende neue Klassen:
	CWritingFont: Spezielles Font-Material
		CWritingFont(); // Konstruktor
		~CWritingFont(); // Destruktor
		CWritingFont operator=(CWritingFont & writing); // Kopieroperator
		void Copy(CWritingFont & writing); // Kopiermethode
		void Init(char * acPath, bool bChromaKeying); // Initialisiert SchriftartMaterial durch Pfadangabe, bChromaKeying setzt chromatischen Farbschlüssel (Pixel 0,0)
		void Fini(); // Finalisiert Schriftart
		void SetTableSize(int ixTable, int iyTable); // Setzt die Feldgröße in Buchstaben im übergebenen ASCII-Feld
		void SetTableStartASCII(int iTableStartASCII); // Setzt dien Anfang des übergebenen ASCII-Feldes
	CWritingChar: Einzelner Buchstabensprite, folgende Methoden:
		CWritingChar(); // Konstruktor
		~CWritingChar(); // Destruktor
		CWritingChar operator=(CWritingChar & writing); // Kopieroperator
		void Copy(CWritingChar & writing); // Kopiermethode
		void Init(CFloatRect & floatrect, CWritingFont * pwritingfont); // Initialisiert ein Zeichensprite, floatrect ist die 2D-Größe des Zeichenfeldes,  pwritingfont ein ASCII-Schriftsatzmaterial 
		void Tick(float & fTimeDelta, CFloatRect & floatrectFather); // Wird automatisch jeden Tick aufgerufen, der Programmierer braucht sich normalerweise um diese Methode nicht zu kümmern
		void Fini(); // Finalisiert Zeichensprite
		void SetChar(char c); // Aktualisiert Zeichensprite
		void SetFont(CWritingFont * pwritingfont); // Aktualisiert Font
		void Draw(); // Wird automatisch aufgerufen
	CWritingChars: Pluralklasse für Buchstabensprites
	CWriting: Textfeld-Sprite, folgende Methoden: 
		CWriting(); // Konstruktor
		~CWriting(); // Destruktor
		CWriting operator=(CWriting & writing); // Kopieroperator
		void Copy(CWriting & writing); // Kopiermethode
		void Init(CFloatRect & floatrect, int ixChars, CWritingFont * pwritingfont); // Initialisiert ein Textfeldsprite, floatrect ist die 2D-Größe des Textfeldes,  ixChars die maximalanzahl der Buchstaben, pwritingfont ein ASCII-Schriftsatzmaterial 
		void Tick(float & fTimeDelta, CFloatRect & floatrectFather);// wird automatisch aufgefufen
		void Fini(); // Finalisiert das Textfeldsprite
		void SetString(char * ac); // Aktualisiert den Text
		void SetFont(CWritingFont * pwritingfont); // Aktualisiert das ASCII-Schriftsatzmaterial
		void SetViewport(CViewport * pviewport); // Wird automatisch aufgerufen
	CWritings: Pluralklasse für Textfeldsprites
Bugfix: Sprites wurden bei Rückbeleuchtung schwarz 
Neue Methoden in CMaterial:
	void SetTextureSprite(CTexture *ptexture);	// Setzt eine Textur, die für Sprites wie Backgrounds, Overlays, Writings und WritingChars geeignet ist   
	CImage * MakeTextureSprite(char * acPath); // Erzeugt eine Texturhierarchie, die für Sprites wie Backgrounds, Overlays, Writings und WritingChars geeignet ist   

2013.12.08 TB:
- Neue praktische Methoden in CWriting:
	void PrintF(LPCSTR szMsg, ...); // Äquivalent zu "printf" im Konsolenfenster
	void PrintInt(int i); // Schreibt eine Integerzahl 
	void PrintFloat(float f); // Schreibt eine Float-Gleichtkommazahl 
	void PrintString(char * ac); // Schreibt einen Text
	void SetFont(CWritingFont * pwritingfont, int & iCharStart, int & iCharEnd); // Aktualisiert das ASCII-Schriftsatzmaterial im Buchstabenbereich iCharStart bis iCharStartEnd
- Methode PassToGPU vereinfacht und beschleunigt (Ein Material wird nur noch dann geladen, wenn vorheriges Material anderes Image)
- Tickaufruf von Writing und WritingChar sehr beschleunigt, (UpdateMaterial wird nur noch bei Veränderungen aufgerufen)
- Textlabels jetzt möglich, dafür folgende neue Klassen: 
	CWribel: Textfeld-Label (WRIting + LaBEL = WRIBEL), folgende Methoden: 
		CWribel(); // Konstruktor
		~CWribel(); // Destruktor
		CWriting operator=(CWribel & wribel); // Kopieroperator
		void Copy(CWribel & wribel); // Kopiermethode
		void Init(CFloatRect & floatrect, int ixChars, CWritingFont * pwritingfont); // Initialisiert ein Textfeldsprite, floatrect ist die 2D-Größe des Textfeldes,  ixChars die maximalanzahl der Buchstaben, pwritingfont ein ASCII-Schriftsatzmaterial 
		void Tick(float & fTimeDelta, CFloatRect & floatrectFather);// wird automatisch aufgefufen
		void Fini(); // Finalisiert das Textfeldsprite
		void PrintF(LPCSTR szMsg, ...); // Äquivalent zu "printf" im Konsolenfenster
		void PrintInt(int i); // Schreibt eine Integerzahl 
		void PrintFloat(float f); // Schreibt eine Float-Gleichtkommazahl 
		void PrintString(char * ac); // Schreibt einen Text
		void SetFont(CWritingFont * pwritingfont, int & iCharStart, int & iCharEnd); // Aktualisiert das ASCII-Schriftsatzmaterial im Buchstabenbereich iCharStart bis iCharStartEnd
	CWribels: Pluralklasse für Textfeldlabels

2013.12.14 TB:
- Backgrounds gecheckt
- Animierte Materialien funktionieren jetzt auch bei Backgrounds und Overlays 
- CDirectX::id um Faktor 5 beschleunigt, indem initialisierende For-Schleife in CCreateMaterial verschoben wurde 
- Neue Schnittstellenfunktionen CDirectX::id, CApiRender::UpdateMaterialAni und CNullRenderer::UpdateMaterialAni hinzugefügt, die nur noch Animationsflags verändert => Beschleunigung

2013.12.15 TB
- Umbenennung der BufferMap-Methoden, damit sie konsistent zur anderen Software sind.  
- BufferMap die Methode OverwriteBuffer hinzugefügt
Es ist nun möglich, eine existierende Geometrie nachträglich zu ändern, dazu folgende Methoden:
- TriangleList::Update() 
- TriangleStrip::Update()
- CDirectX,CNullRenderer, und CApiRender haben jetzt folgende neue Schnittstellenmethoden:
	void UpdateTriangleList(CGeoTriangleList *ptriangleList, SRenderObjectHandle & handle);
- Rechtschreibkorrektur in CNode-Methode: EnabaleVisualHelper zu EnaableVisualHelper
	void UpdateTriangleStrip(CGeoTriangleStrip *ptriangleStrip, SRenderObjectHandle & handle);

2014.01.13 TB
- Bugfix: SetTexture funktioniert wieder

2014.02.11 TB
- Foliensatz für Writings erstellt

2014.03.09 TB
- Bugfix: CWriting stürzte bei mehr als 223 Buchstaben in Zeile ab

2014.04.04 TB
- Szenen und Viewports können nun einfach an- und ausgeschaltet werden, dafür folgende neue Methoden, in den beiden diesbezüglichen Klassen:
	SwitchOff();
	SwitchOn();
 - friend-Klassen mit private-Zonen in allen Klassen damit unnötige Methoden dem Anwender verborgen bleiben

2014.04.16 TB:
- Bugfix: System blieb schwer hängen, wenn zu kleine Frame-Rate (z.B. wenn man App ohne Code aufgrufen hatte oder mit NUll-Renderer)

2014.05.19 TB:
- Unlöschbarer Splash-Screen mit Sound programmiert, 
	(Klasse CSplash)
- Achtung, Root muss jetzt mit Splash initialisiert werden, damit Programme funktionieren!

2014.05.16 TB:
- Neue Server-Version wieder konsistent gemacht
- Änderungen von MS teilweise wieder rückgängig gemacht (sinnvolle Änderungen werden in Zukunft wieder suksessive rückentwicklelt)
- Veraltete Files gelöscht (logger.h, connection.h, etc.) 

2014.05.21 TB:
- Bugfix: Projektionsmatrix in CCamera war falsch und führte daher bei der Picking-Routine im DV-Projekt zu Problemen, daher raus und durch richtige ersetzt:
- Bugfix: CTimer konnte nicht bei Win64 funktionieren
- CTimer überarbeitet, beschleunigt und übersichtlicher gestaltet, nicht mehr benötigte Routinen von Kim und Bene wurden rausgenommen
- Neue Uitlity-Routine in CUtil.h: UM_SWAP // Tauscht die Werte zweier beliebiger Datentypen miteinander aus
- Bugfix: CNode AABBs und Visualhelpers wurden nicht richtig gesetzt, wenn Add-Methode nach EnableAABBs oder EnableVisualHelpers aufgerufen wurden 
- Bugfix: Kim und Benes Methoden "Encompass" in der Klasse CNode waren falsch implementiert und konnten so nicht funktionieren, durch folgende neue Methoden ersetzt:
    void AddAABB(CAABB &aabb);
	void AddVector(CHVector &vPos);
- Clearing der AABB möglich
- Neue Methode in CNode: 
	ClearAABB()


2014.05.22 TB:
- Draw-Aufrufe von CNode und CGeo entrümpelt und beschleunigt
- Bugfix: CPlacement::SetPointing(CPlacement * pplacementPointing) funtionierte nicht vor dem Adden


2014.05.25 TB:
- Löschung von unsinniger Funktion von Kim und Bene in CVertexs: void Init(int iAllocVertices); 
- Komplette Neuschreibung der Klasse CNode von Flo, Kim und Bene, da Kraut und Rüben, konnte gar nicht richtig funktionieren  
- Trennung der Methoden, Variablen und Daten aus CNode in 3 Klassen:
		- CNode: Basisklasse für alle Knotenobjekte, für Knotenhierarchie, Noemen und Knoten-ID verantwortlich 
		- CNode3D: Basisklasse für alle 3D-Objekte, für Bounding-Boxen, Frustrum-Culling, etc. verantwortlich
		- CSprite: Basisklasse für alle 2D-Sprite-Objekte, für 2D-Intersectionen, Chromakeying, etc. verantwortlich
- Neue Methoden in CNode:
		bool IsNode2D(void); // Gibt true zurück, wenn es sich bei diesem Knoten um ein 2D-Knoten (Sprite) handelt, ansonsten false
		bool IsNode3D(void); // Gibt true zurück, wenn es sich bei diesem Knoten um ein 3D-Knoten handelt, ansonsten false
- Verschiedene Farben bei Bounding-Box-Visual-Helpers zum besseren Debuggen:
			Geos: Grün
			Placments: Rot
			Audios: Magenta
			Sonst: Weiß
- Bugfix: Copy-Funtion in CNode funktionierte nicht

2014.05.27 TB:
- CGeoTriangleStrip.cpp: SWAP-Makro durch Util-Makro ersetzt
- Folgende Methoden wurden wieder aus CPlacement herausgenbomme und in CGeoWindow hineingesteckt (War schnelle Lösung für Zwiaschenprojekt mit Zeitdruck): 
-	void MakeWallByWindow(CGeoWall *pgeowallChild, CGeoWindow * pgeowindow, float fThickness, CHVector vOffset, CHVector vScale, CMaterial * pmaterial, bool bLeft = true, bool bRight = true, bool bBottom = true, bool bTop = true, bool bBack = true);
-	void MakeWallByWindow(CGeoWall *pgeowallChild, CGeoWindow * pgeowindow, float fThickness, float fOffset, CMaterial * pmaterial, bool bLeft = true, bool bRight = true, bool bBottom = true, bool bTop = true, bool bBack = true);
-	void MakeRoof(CPlacement * pzpBack,CPlacement * pzpFront, CPlacement * pzpLeft, CPlacement * pzpRight,   CGeoWall *pgeowallBack, CGeoWall *pgeowallFront, CGeoWall *pgeowallLeft, CGeoWall *pgeowallRight, CHVector vSize, float fThickness, float frGableFrom, float frGableTo, CMaterial * pzm, float fxTextureRepeat, float fyTextureRepeat);
-	void MakeRoof(CGeoWall *pgeowallBack, CGeoWall *pgeowallFront, CGeoWall *pgeowallLeft, CGeoWall *pgeowallRight, CHVector vSize, float fThickness, float frGableFrom, float frGableTo, CMaterial *pzm, float fxTextureRepeat = 1.0F, float fyTextureRepeat = 1.0F);
- CPlacemengt: Alle Translate- Scaling- und Rotate-Methoden in CPlacement updaten nun das AABB
- CGeo: Beim Hinzufügen eines Vertex wird nun automatisch das AABB geupdatet
- CGeo: Twisting, Tapering, Bending, Waving und Rippling updaten automatisch das AABB
- Buggfix in CPlacement: AABB in CPlacement wurde immer auf 5 Units Durchmesser gesetzt 
- Fremdbibliotheken aus CAABB herausgeworfen und durch Util-Makros ersetzt
- Komplettumbau von CAABB 

2014.05.27 TB:
- Methode GetTranslation aus CNode3D herausgeworfen (kan gar nicht funktionieren, da CNode3D den translativen Anteil gar nicht kennt, das tun nur einige vererbte Methoden)
- Bugfix: VisualHelpers werden jetzt auch für Objekte richtig angezeigt, die keine Spheres sind
- Notation in CAABB Vektoria-konform gemacht
- CNode3D entrümpelt

2014.05.30 TB:
- S_SOUND in S_AUDIO umgewandelt (wegen Namenskonsistenz)
- Bugfix: CNode::IsPlacement funktionierte nicht, falls Placement nicht geadded war 
- Bugfix: SetPointing stürzte ab, wenn Placement auf das gezeigt wurde, noch nicht geadded war
- Bugfix: Draw-Call in CNode3D funktioniert jetzt

2014.06.05 TB (rev. 549): 
-Bugfix: Placement-ViusalHelpers für AABBs werden nun korrekt angezeigt
- Geo ABBB werden nun für ALLE Gemegtrieen korrekt berechnet
- Übergeordnetes Placement ABBB wird nun  geupdatet (TODO: ist noch nicht ganz korrekt und funktioniert noch gar nicht für zusammenlaufende Hierarchien)
- Man kann nun Placmeents auch unabhängig global statt local positionieren mit der Funktion SetMatGlobal();
- Folgende neue Geometrie-Klassen erstellt (diese Klassen sind notwendig, falls man repetetive, gesteuerte oder animierte Texturen auf Spheres/Domes/Ellipsoide adden will, brauchte DV-Gruppe)
 	CGeoEllipsoidTiled
 	CGeoSphereTiled
 	CGeoDomeTiled
- Animierte Wasser-Bumpmaptextur mit richtigem Z-Vektor zum Testen hinzugefügt 


2014.06.06 TB: (rev. 550)
- Uralt-Klasse "connection", die ohne Funktion ist, zum 3. Mal herausgenommen (wer tut die eigentlich immer wieder rein?)
- Hurrraaaaaa! Es klappt! Die BVH-Hierarchie funzt!!! Ist nun eine geschickte Kombination aus hierarchisch strukturierten AABBs und OBBs und damit das Performanteste, was überhaupt möglich ist, also ein weiteres USP für Vektoria.
- Sogar zusammenlaufende Placement-Hierarchien sind möglich (TODO: noch keine zusammenlaufende Geo-Hierarchien, 3D-Sounds bringen BVH noch durcheinander,
	Die Klasse CAABB werde ich demnächst in CBoundingBox umbenennen, damit es keine Missvertändnisse gibt. Dann kann ich ans Picking und das Frustrum Culling gehen.

2014.06.07 TB: (rev. 553)
- Bugfix: Disable- & EnableVisualHelpers funktionierte nicht, wenn Placement erst zur Laufzeit geadded wurde
- Bugfix: Disable- & EnableAABBS funktionierte nicht, wenn Placement erst zur Laufzeit geadded wurde
- UpdateAABB-Methode wurde bei Placements beschleunigt, überladene Methode ohne Matrix geschaffen 


2014.06.10 TB: (rev. 554)
- Bounding Boxen funktionieren nun auch bei Geos, die an Geos geadded wurden und zusammenlaufende Geo-Hierarchien
- CNode3D aufgeräumt
- Bounding Boxen sollten nun auch nach FixAndFasten-Methoden funktionieren (noch ungetestet) 

2014.06.10 TB: (rev. 555)
- Beschleunigung der Bounding Box-Berechnung

2014.06.12 TB: (rev. 557)
Neue Funktion in CHMat:
	void Rotate(CHVector & vOrientation, EAxis & eAxis); // Rotiert angegebene Achsen-Vektor eAxis in Richtung der Orientierung vOrientation


2014.06.14 MR: (rev. 558)
- Windows 8.1 SDK-Dateipfad in Shadercache gefixed.

2014.06.14 MR: (rev. 560)
- Bugfix: Partikelsysteme crashen jetzt nicht mehr wenn man die Prewarm-Phase auf mehr als 10 Sekunden stellt.
- Bugfix: Fehler beseitigt der dazu führte, dass nur eine .3ds-Datei geladen werden konnte.
- Die Methode CAudio::Stop pausiert einen Sound jetzt nicht mehr sondern stoppt ihn wirklich. (Wie der Name eigentlich vorgibt.)
- CAudio hat eine neue Methode mit der man den Sound auch pausieren kann. CAudio:Pause

2014.06.18 TB:
- Ray-BoundingBox-Schnittberechnung implementiert, dafür folgende Methode in CAABB:
		bool Intersects(CRay & r);

2014.06.20 TB:
- Neue Makros in Util.h:
	#define UM_ISINRANGEFR(fr) ((fr>=0.0F)&&(fr<=1.0F))  // Überprüft, ob Wert f im fraktionalen Wertebereich [0,0 bis 1,0] liegt, wenn ja => true, falls nein => false
	#define UM_ISNOTINRANGEFR(fr) ((fr<0.0F)&&(fr>1.0F))  // Überprüft, ob Wert f im fraktionalen Wertebereich [0,0 bis 1,0] liegt, wenn nein => true, falls ja => false
- Funktion FrameToViewportCoord gibt jetzt auch einen boolschen Parameter aus:
	bool FrameToViewportCoord(float & frx, float & fry); // Übersetzt die Koordinaten des Frames in Koordinaten des Viewports, gibt true aus, wenn Cursor innerhalb des Viewports liegt
- Folgende neue Picking-Routinen in CDeviceCursor:
	CViewport * PickViewport(); // Gibt erstes sichtbares Viewport aus, welches unter dem Cursor liegt, falls kein Viewport gefunden wurde ist das Ergebnis NULL
	COverlay * PickOverlay(); // Gibt erstes sichtbares Overlay aus, welches unter dem Cursor liegt, falls kein Overlay gefunden wurde ist das Ergebnis NULL
	CCamera * PickCamera(); // Gibt die Kamera aus, die mit dem sichtbaren Viewport verbunden ist, welches unter dem Cursor liegt, falls kein Viewport gefunden wurde ist das Ergebnis NULL
	CPlacement * PickPlacement(); // Gibt dasjenige Placement mit der niedersten Hierarchiestufe aus, welches unter dem Cursor liegt, falls kein Placment gefunden wurde ist das Ergebnis NULL
	CPlacements * PickPlacements(); // Gibt alle Placements aus, welches unter dem Cursor liegen, falls kein Placment gefunden wurde ist das Ergebnis NULL
	CGeo * PickGeo(); // Gibt dasjenige Geo mit der niedersten Hierarchiestufe aus, welches unter dem Cursor liegt, falls kein Geo gefunden wurde ist das Ergebnis NULL
- m_fFov in m_fFovHorizontal umbenannt, unm weitere Missverständnisse bei Studierenden entgegenzuwirken
- Neue schnellere Projektionsmatrix in CHMat:
	void ProjectionFov(float fFovHorizontal, float fRatio); // Generiert eine foveale Projektionsmatrix (ohne Near und Far-Clipping-Plane) 

2014.06.26 TB: (rev 563)
- Neue Methoden in der Pluralklasse CScenes:
	bool AddOnce(CScene * pscene); // Fügt Szene nur dann in die Liste hinein, wenn sie noch nicht in der Liste eingetragen ist (Verhindert Doppeltabspeicherungen)
	bool Has(CScene * pscene); // Gibt true aus, wenn Szene in der Liste vorhanden ist
- Neue Methoden in CViewport:
	CCamera * GetCamera(); // Holt die mit dem Viewport assoziierte Kamera
	CScene * GetScene(); // Holt die mit dem Viewport assoziierte Szene
- Neue Methoden in CDeviceCursor:
	CScene * PickScene(); // Gibt die Szene aus, welche das sichtbare Viewport zeigt, welches unter dem Cursor liegt, falls keine Szene gefunden wurde ist das Ergebnis NULL
- Parameter bei CCamera-Zuweisungsoperator und Kopiermethode in Call by Reference umgewandelt (schneller)
- Neuw Ray-BoundingBox-Schnittberechnung mit Entfernungsberechnung implementiert, dafür folgende Methode in CAABB:
		bool Intersects(CRay & r, float & fMin, float & fMax);
- Neue Methode in CCamera:
	CScene * GetScene(); // Gibt die angezeigte Szene aus
- Picking funktioniert jetzt halbwegs (TODO: noch entfernungsabhängig machen)

2014.06.28 TB: (rev 564)
- Durch CNode veraltete Variable m_pparent gelöscht 
- Bugfix: Neue CCamera-Projektionsmatrix zeigte Objekte invers an
- Beschleunigung der Camera-Fov-Berechnung  
- Picking von Placements funktioniert jetzt (auch entfernungsabhängig)

2014.06.28 TB: (rev 565)
- Temporärer Workaround um einen Bug bei LightSpots, (zwei Fehler heben sich hier gegenseitig halbwegs auf) TODO CLightSpot komplett neu schreiben: 
	void ProjectionFovOld(float faFovHorizontal, float fRatio, float fNear, float fFar); // Generiert die foveale Projektionsmatrix aus V11 (falsch, nur der Aufwärtskombabilität in V12 drinnen, wird danach herausgenommen)

2014.06.29 TB: (rev 566)
- Bugfix in CHMat: Orthografische Projektion wird nun richtig skaliert
- Bugfix in CCamera: Orthografische Kameras sind nun richtig skaliert
- Neue Methoden in CCameras für orthografische Kameras:
	void SetOrtho(float fOrthoScalingHorizontal); // Schaltet Kamera in Othogonalprojektionsmodus und gibt gleich den horizontalen Skalierungsfaktor an
	void SetOrthoScaling(float fOrthoScalingHorizontal); // Setzt den horizontalen Skalierungsfaktor bei orthogonalen Kameras (vertikaler wird daraus automatisch berechnet), bei Fov-Kamera ohne Wirkung
	float GetOrthoScaling(); // Gibt den orthogonalen Skalierungsfaktor aus
- CCamera::CalcMat() durch Löschung redundanter Teile beschleunigt  
TODO: Picking funktiert noch nicht bei orthografischer Projektion, sondern nur bei normaler fovealer

2014.07.02 TB: (rev 568)
Neue Methode in CRay zur Schnittpunktberechnung für das genaue Geometrie-Picking und die Kollisionsberechnung
	bool IntersectsTriangle(CHVector & v1, CHVector & v2, CHVector & v3, CHVector & vIntersection); // Schaut, ob Strahl mit Dreieick v1-v2-v3 kollidiert, wenn ja, wird true ausgegeben
Neue Methode in CGeoTriangleList und CGeoTriangleStrip zur Schnittpunktberechnung für das genaue Geometrie-Picking und die Kollisionsberechnung (TODO: noch ungetestet)
	bool Intersects(CRay & r, CHVector & vIntersection); // berechnet, ob Strahl r ein Dreieck der Geometrie trifft, vIntersection ist dann der Schnittpunkt
Neue Geo-Klasse hinzugefügt: 
	CGeoTriangle  -2D-Dreieck im Raum (ist vor Allem praktisch zum Debuggen, aber auch für spitze Billboards)
BUgfix: Link in Projekteigenschaften für Release-Ausgabedatei stimmte nicht  (jetzt korrekt "Vektoria_Release.lib")


2014.07.06 TB: (rev 569)
Neue Picking-Methoden in CDeviceCursor:
	CViewport * PickViewport(float & frxViewport, float & fryViewport); // Gibt erstes sichtbares Viewport aus, welches unter dem Cursor liegt, falls kein Viewport gefunden wurde ist das Ergebnis NULL, dazu werden die passenden Bildschirmkoordinaten frxViewport und fryViewport des Picking-Punktes mit ausgegeben
	CGeo * PickGeo(CHVector & vIntersection, float & fDistanceSquare); // Gibt dasjenige Geo mit der niedersten Hierarchiestufe aus, welches unter dem Cursor liegt, falls kein Geo gefunden wurde ist das Ergebnis NULL, vIntersection ist der genaue Schnittpunkt, fDistanceSquare ist das Quadrat der Entfernung zwischen Strahlursprung und Schnittpunkt, kann bei großen Geometrien einige Millisekunden dauern, ist dafür sehr exakt
Picking-Routinen vereinfacht, aufgeräumt und beschleunigt
Schnittpunktberechnungen für das genaue Geometrie-Picking und die Kollisionsberechnung in CGeoTriangleList und CGeoTriangleStrip wurden eingehend getestet => OK
Bugfix: CGeoTriangleStrip::CopyToTriangleList() kopierte letztes Dreeick nicht mit
Bugfix: CGeoTriangleStrip::AddIndexFirst() hat zweites und letztes Dreieck gelöscht.  
Bugfix: CGeoTriangleStrip::Flip() drehte zwar alle Normalen der Vertices um, aber drehte nur einen Teil der Flächennormalen um (die indirekt aus deer Drehrichtung der Vertices berechnet wird) 
Bugfix: CGeoTriangleStrip::FlipSpin() drehte nur einen Teil der Dreiecke um
Picking abgeschlossen, gehe jetzt ans Frustum Culling

2014.07.12 TB: (rev 570)
Projektstruktur vereinfacht und unnötige Ordnerhierarchien abgeflacht
Projekt in kleine Untereinheiten mit Libraries unterteilt (nun kann man Aufgaben an andere Peronen verteilen, ohne den ganzen Code zu veröffentlichen), außerdem wird das Compilieren beschleunigt:
- VektoriaApp
- Vektoria (Core)
- VektoriaMath
- ApiDirectX11
- ApiNullrenderer
- ApiOpenGL40
- ApiDirectInput
- ApiNullInput 
TODO für weitere Untereinheiten-Libraries: 
- ImporterBlender
- ImporterOBJ
- Importer3DS
- ImporterCatia
- ImporterX3D
- VektoriaParticles ?
 -VektoriaEditor

2014.07.12 TB: (rev 573)
- Unnötige Dateien gelöscht
- OpenGL40-Klasse für AV erstellt
- Dynamische Einbiundung von OpenGL40 in die Frame-Klasse
- Entwicklungs- und Testumgebung für Anderas Vesenmeyer erstellt (nicht auf Server hochgeladen)  
- Neue Klassen CFrustum und CFrustrums hinzugefügt

2014.07.20 TB: 
- Neue Konstruktoren für CRay und CFrustum:
	CRay(); // Konstruktor ohne Initialisierung
	CRay(CHVector & vOrigin, CHVector & vDirection); // Konstruktor mit einem Punktvektor und einer Richtung, fMin wird auf QUASI_ZERO und fMax auf F_MAX gesetzt.
	CRay(CHVector& vOrigin, CHVector& vDirection, float fMin = QUASI_ZERO, float fMax = F_MAX); // Kostruktor, alle relevanten Parameter des Strahls werden initialisiert
	CFrustum(); // Erzeugt Pyramidenstumpf ohne Initialisierung
	CFrustum(CRay r, CHVector vNormalRight, float faHorizontal, float faVertical); // Initialisiert Pyramidenstumpf
- Kamera hat jetzt einen Frustum als Member
	die Methode  CalcFrustum(); in CCamera berechnet den aktuellen globalen Frustum
- Neue Methoden in CFrustum:
	bool IsInside(CHVector & v); // Gibt true aus, wenn Punkt innerhalb des Pyramidenstumpfes liegt, ansonsten false
	int IsInside(CAABB & aabb); // Gibt -1 aus, wenn Box komplett außerhalb des Pyramidenstumpfes liegt, 0 fals halb drin, haln draußen, 1 fall komplett drinnen
Bugfix: Copyoperator in CPlane kompierte Fz-Komponente falsch 

2014.07.23 TB: (rev 587)
- Folgende Veraltete Dateien gelöscht:
	Computer.h
	Computer.cpp
	Computer.h
	Computer.cpp
- Folgende Methoden in CPlacement vor Anwender mittels Friend-Klassen und Private-Zone versteckt: 
	void Draw(CCamera * pcamera, CHMat & mGlobalFather, int & itFatherIsInFrustum);
	CPlacement * PickPlacement(CRay & r, float & fMin, float & fMax);
- CFrustum::IsInside(CAABB & aabb); benutzt jetzt den Presenham-Algorithmus, um auch semitangierende Objekte des Frustums zu detektieren 
- Testumgebung für CFrustum::IsInside(CAABB & aabb) gebaut und gecheckt => Funktioniert 
- m_bAABBsOn defaultmäßig auf true gesetzt

2014.09.20 TB: 
- Bugfix: BVH-Baum aktualisierte sich nicht bei freien Rotationen

2014.10.23 TB: Revision: 595:
- Bugfiux: Frustum funktionierte nicht bei Winkeln über 180° 
- Frustum Culling funktioniert jetzt (außer bei Hierarchitekturmodellierung

2014.10.24 TB:
- Frustum Culling funktioniert jetzt auch bei Hierarchitekturmodellierung, dafür UpdateAABB in CGeoWing überladen; 

2014.10.26 TB
- Collition Detection von Placments, dafür folgende Methoden in C
- Frustum Culling funktioniert jetzt auch bei zusammenlaufenden Hierarchien
- Auch Lichter können nun mehrfach durch zusammenlaufende Hierarchien instanziiert werden (war vorher nicht möglich!)
- Geometrien können mehrfach in verschiedenen Scenes instanziiert werden

2014.11.02 TB Rev 630:
- Komplettumbau der Node3D-Hierarchie => Vereinheitlichung, Instanziierung in Node3D gepackt, anstatt in Placement, Geo, Scene, ...
- Übersichtlichere Instanzliierung
- Beschleunigung des Frustum Cullings
- CGeoWing aufgeräumt 
Bugfix in CViewport::CalcSize(): VieportBreite wurde falsch berechnet (Dieser Fehler ist neu dazaugekommen, wer hat ihn hineinprogrammiert?)
Bugfix in CDeviceCursor::GetFractional: Funktion gab unsinnige Werte zurück, wenn vor erstem Root-Tick aufgerufen.
Bugfix in CGeoWing::Draw kam nicht mit neuer Instanziierung zurecht und zeigte Innenfenster schwarz

2014.11.02 TB Rev 631:
- Release-Fehler teilweise gefixt (läuft in Debug aber nicht in Release)
- Bugfix: stürzte ab (auch in Debug), wenn Camera nicht an Placement gehängt war
- Redundanzen bei Parameterübergabe von Materialstrukt verringert

2014.11.05 TB 
- Bugfix: Es wurde vergessen die Variable m_bSwitch im Konstruktor von Node3D auf true zu setzen => CXrash bei bestimmten Lichttypen)

2014.11.07 TB 
- Einige Bugfixes von vergessenen Initialisierungen im Konstruktor
- S_KIND-Struktur vereinheitlicht

2014.11.07b TB 
- m_eKind wird jetzt einheitlich initialisiert
- Alle Membervariablen der Knotenklassen werden jetzt im Konstruktor initialisiert => Release-Fehler besteht immer noch (ist aber stets weg, wenn Nullrenderer eingeschaltet wird!) 

2014.11.13 TB: 
Bugfix: Bitangente an der rechten Seite von einer CGeoWall war falsch
- Angefangen, das UV-Mapping zu vereinheitlichen, dafür zwei meue Methoden in CGeoWall: GetUVFront, und GetUVBack (TODO: für alle Fenstertypen anwenden)
Bugfix: Bintangente war an der Spitze von romanischen Bögen nicht 100&-ig korrekt 
- Steuerungs-Define in TestbedShader (von Turntable zu WASD)

2014.11.16 TB: 
- Neue Methode in CHMat: void RotateDelta(CHVector & vTo, CHVector & vFrom), // Generiert eine Rotationsmatrix, die Richtungsvektor vFrom genau in die Richtung des Richtungsvektors vTo rotiert und multipliziert diese mit der aktuellen Matrix  
- Bumpmaps laden jetzt per Default Blautextur 
- Neue Klasse: CGeoArrow generiert einen geometrischen 3D-Pfeil (Teil der Normalen, Tangenten und Bitangentenanzeige)

2014.11.17 TB:
Bugfix: m_pPostProcessor->UpdatePostProcessingCB(pviewport); in ForwardPlusRenderer getan 

2014.11.19 TB:
Bugfix: ForwardPlus-Renderer stürzte bei Vorhandenseins eines TriangleStrips ohne Vertices ab.
- Neue Klasse: CGeoInfoVertex gibt Position, Normale, Tangente und Bitangenteeines Vertex grafisch in Form einer Kugel (Pos) und drei farbigen Pfeilen (Normale, Tangente und Bitangente) aus
- Neue Klasse: CGeoInfoGeo gibt die Informationen einer ganzen Geometrie aus
- Neue Default-Grundimages eingefügt (red_image.jpg, green_image.jpg, blue_image.jpg)

2014.11.22 TB: (Rev 629)
- Angefangen, DirectX-Klasse etwas aufzuräumen:
- Die neunen Klassen CDrawObject und CDrawObjects eingefügt => Vereinfachung
- SmartAllocating in CDrawObjects
- Mergesort in CDrawobjects eingefügt
- Mergesort kopiert nur noch pointer statt values => BEschleunigung des Sortierens 
- Die beiden DirectX-Funktionen void CopyCHMatToXMFLOAT4X4(CHMat &m, XMFLOAT4X4 &f4); und void CopyXMFLOAT4X4ToCHMat(XMFLOAT4X4 &f4, CHMat &m); wurden entrümpelt, konsistent gemacht und beschleunigt durch Call by Reference
Bugfix in CGeos: Geometrien wurden nicht richtig sortiert, wenn unter der zweiten Hierarchiestufe einer reinen Geo-Hierarchie ein einzelnes transparentes Material dabei war 
Bucket für Binäre Alphamaterialien hinzugefügt (TODO: Nochmal checken)
Folgende neue Methoden in CMaterial:
		void SetTransparencyKind(ETransparencyKind eTransparencyKind); // Gibt die Transparenzart an: eTransparencyKind_No für opake Texturen, eTransparencyKind_BinaryByAlphaTest für ja-nein-Alpha-Texturen, eTransparencyKind_BinaryByChromaKey für Farbschlüsseltexturen, eTransparencyKind_Continual für Semitransparente Texturen mit Alpghakanal
		bool IsOpaque(); // Gibt true aus, falls es sich um eine vollkommen undurchsichtige Textur handelt, ansonsten, also wenn Chroma-Keying, Transparenz oder AlphaTest eingeschaltet ist wird false ausgegeben


2014.12.01 TB: (Rev 630)
Bugfix in CDirectX: Der Y-Wert von Bot-Materialien wurde auf den X-Wert gesetzt => Wribels gaben seltsame Buchstaben aus


2014.12.02 TB: (Rev 634)
Bugfix in CQuaternion::GetMatrix() und CQuaternion::GetMatrixByNormed(): Objekt wurde bei manchen Rotationspoitionen des Quaternions deformiert
Bugfix in CQuaternion::Slerp(): Stürzte bei Rotationswinkeln um TWOPI ab (Division by Zero).
- CQuaternion::Slerp beschleunigt
Folgende meue Funktionen in CPlacement:
- 	void Rotate(CQuaternion &q); // erzeugt eine Rotationsmatrix aus dem Rotationsquaternion q
-	void RotateDelta(CQuaternion &q); // erzeugt eine Rotationsmatrix aus dem Rotationsquaternion q und multipliziert diese mit der bisherigen Matrix des Placements

2014.12.07 TB: (Rev 634)
- Neue Methode in CHMat:
	void ProjectionFovMirror(float faFovHorizontal, float fRatio, float fNear, float fFar); // Generiert eine horizontal gespiegelte foveale Projektionsmatrix 
- Seitenverkehrte Spiegelausgabe in normalem Renderer jetzt möglich, dafür zwei neue Routinen in CCamera
	void SetMirrorOn(); // Schaltet spiegelverkehrte Aufnahme an
	void SetMirrorOff(); // Schaltet spiegelverkehrte Aufnahme wieder aus
- Bugfix in CDirectX: In normalem Renderer wurden Overlays nicht mehr angezeigt
- Overlays können jetzt in mehreren Ebenen übergeben werden => Transparente Overlays sollten im normalen Renderer jetzt richtig angezeigt werden (noch ungetestet)


2014.12.17 TB (Rev 652):
- DirectX-Renderer in drei getrennte Libraries aufgesplittet:
  1.) ApiDirectX11Basic (für alten einfachen Renderer von mir) 
  2.) ApiDirectX11ForwardPlus  (für neuen Luxusrenderer von Patrick) 
  3.) ApiUtils (für nützliche gemeinsame Klassen der Api-Libraries)
- Verschiedene Renderer müssen jetzt nicht mehr neu kompiliert werden, sondern können direkt in CFrame:Init() angewählt werden, dafür folgende enum-Struktur als 2.Parameter:
	enum EApiRender
	{
		eApiRender_Null,
		eApiRender_DirectX11_Shadermodel41,
		eApiRender_DirectX11_Shadermodel50,
		eApiRender_DirectX11_ForwardPlus,
		eApiRender_OpenGL40
	};
- Letzte Codereste von Benedikt und Kim aus DirectX11 entfernt 
- Particle-Renderroutinen von Michi aus DirectX11 entfernt 
- DirectX11 teilweise aufgeräumt (TODO: Das Gleiche müsste auch im ForwardPlus-Renderer gemacht werden)

2014.12.17 TB (Rev 653):
- Bugfix: FP-Renderer ging nicht im Release-Modus

2014.12.18 TB (Rev 654):
- ShaderCompilationModes lassen sich jetzt auch in Fram::Init angeben => Ohne Neukomplierung des Codes veränderbar
- Namen für die Übergabe vereinheitlicht (müsste dafür auch einige Variablen im FP-Renderer leicht ändern)
- Unnötige Warnings beim Compillieren in den Projekteigenschaften mit SECURE_NO_WARNINGS ausgeschaltet.

2014.12.27 TB (Rev 654):
- Andere konsistente Namen für 64-Bit Versions-Libs
- Overlays können jetzt mit einer Ebenendistanz versehen werden => für GUIs wichtig 

2014.12.27b TB (Rev 666):
- Overlays funktionieren jetzt auch im Mirror-Modus
- Overlays werden für Patricks Shader jetzt auch getrennt nach Alpha-Binary und Alpha-Continual übergeben
- Mein Alter DirectX11-Basic-Renderer etwas weiter aufgeräumt 

2015-01.06 TB:
- Frustum Culling berücksichtigt jetzt auch Punkt- und Spotlichter (TODO: Noch ungetestet)
- Frustum Culling berücksichtigt jetzt auch Audios als vorläufige Version: bei Branches wird AABB auf Max gestellt, TODO: Noch ungetestet)
- Standardtexturen image_black und image_white verkleinert

2014-01-12 TB: (Rev 682)
Bugfix: Bei Walls stand das UV-Mapping auf der rechten Seite auf dem Kopf

2014-01-13 TB: 
#define UM_SWAP(A,B) decltype(A) C=B;B=A;A=C; // Tauscht die Werte zweier beliebiger Datentypen miteinander aus
Bugfix: PickPlacement und PickGeo lieferten bei einer Hierarchiestufe von eins immer NULL zurück
Alte Header- und Body-Dateien gelöscht
Neue Funktion in CHVector: 	void Null(); // Setzt alle Werte auf Null


2014-01-18 TB: 
Bugfix: FrustumCulling funktionierte nicht in speziellen zusammenlaufenden Hierarchiekonstellationen mit LODs 
Beschleunigung des Frustum-Culling-Updates
Anfang von neuer Demo für ATCSim (Galaxis)


2014-01-22 TB: 
Bugfix: Clipping von bewegten Cameras veränderte sich nicht!
Bugfix: Background wurde im Basic-Shader nicht richtig angezeigt
- ProgressBar beim Splash-Screen, dafür zwei neue Methoden in CRoot:
		void ShowBar(float frProgress);
		void HideBar();
- Beschleunigung der Vertexübergabe an die Shader bei CGeoTriangleLists um das doppelte
- Neue Mapping-Möglichkeiten bei CGeoDomeTiled, CGeoEllipsoidTiled und CGeoSphereTiled
- Neue vorgefertigte Geometrie CGeoFrustum mit entsprechende Klasse
- Debugginghilfe für das Frustum Culling mit der Methode void  CGeoFrustum::Init(CCamera & camera, CMaterial & material);
- Einige Methoden in CHVector beschleugigt.
- Neue Methoden in CHVector:
	void InitPoint(float fx, float fy, float fz); // initialisiert oder überschreibt die Werte des Vektors, der W-Wert ist Eins um einen Raumpunkt anzuzeigen
	void InitDirection(float fx, float fy, float fz); // initialisiert oder überschreibt die Werte des Vektors, der W-Wert ist Null  um eine Richtung anzuzeigen

2015-01-27 TB:Rev 695
Bugfix: Das AABB von Point- und Spotlights wurden nicht richtig geupdtatet, wenn nach Placement geadded.
- Vereinfachung und Beschleunigung der Bewegungsmethoden in CPlacement
- Splash-Screen sicherer gemacht durch zweiten Gesamt-Kryptoschluessel 

2015-01-27b TB:Rev 696
Tick von Background in Protected-Zone gestellt
Alle Parameter der Copy, Tick und SetFrame-Routinen vereinheitlicht in Call by Reference umgewandelt => Beschleunigung und Vereinheitlichung 
Tick-Routinen in Singular-Klassen in protected gestellt (braucht der Anwender nicht zu kennen)
Prozeduren in CViewpoort einheitlich umbenannt statt Enable.. Disable => Set..On Set..Off

2015-02-12 TB:
Großer Audioumbau! Nun gibt es eine Schnittstelle für die Audio-Api, die Sound-logig ist in eine getrennte LIB ausgegliedert worden 
Die Apis wurden von der Benennung vereinheitlicht
Apis beginnen jetzt immer mit Api...
Alle Image-Methoden wurden in Diffuse-Methoden umgbenannt
Mit folgenden Routinen lässt sich das FrustumCulling für jedes Placement nun getrennt aus- und anschalten: 
- SetFrustumCullingOn();
- SetFrustumCullingOff();
 
2015-02-13 TB:
Bugfix: Vektoria stürzte ab, wenn im ersten Frame kein Objekt zu sehen war, sowohl im BasicRenderer als auch im FP-Renderer!
Bugfix: Vektoria stürzte ab, wenn einer Geometie ein Null-Pointer als Material übergeben wurde.

2015-04-01 FP & TB:
Bugfix: CFrame stürzte bei ReSize ab, wenn Größe verkleinert wurde.

2015-04-04 TB:
Bugfix: FrustumCulling funktionierte bei zusammenlaufenden Hierarchien nicht einwandfrei
Bugfix: Picking nacvh ReSize ungenau
CScene und CPlacement haben jetzt die Möglichkeit, FrustumCullung und BVH-Berechnung verschieden genau zu toggeln, au folgende Funktionen:  
	void SetFrustumCullingOn(); // schaltet das Frustum Culling für dieses Placement und alle Unterplacements/ Untergeometrien ein
	void SetFrustumCullingOff(); // schaltet das Frustum Culling für dieses Placement und alle Unterplacements/ Untergeometrien aus
	void SetFrustumCullingByFather(); // schaltet das Frustum Culling für dieses Placement auf Überschreibmodus, d.h.. es wird durch die Vorfahren gesteuert.
	void SetBVHExactCalculationOn(); // schaltet den genauen Berechnungsmodus für die Bounding Volume Hierarchie dieses Placement und alle Unterplacements/ Untergeometrien ein (Achtung, kann Performanz stark nach unten drücken, nur in Notfällen verwenden)
	void SetBVHExactCalculationOff(); // schaltet den schnellen Berechnungsmodus für die Bounding Volume Hierarchie dieses Placement und alle Unterplacements/ Untergeometrien ein (Achtung, kann bei zusammenlaufenden Hierarchien mit vielen bewegten Objekten zu ungenau sein) 
	void SetBVHExactCalculationByFather();// schaltet den genauen/schnellen Berechnungsmodus für die Bounding Volume Hierarchie auf Überschreibung duch die Vorfahren


2015-04-16 TB:
- Integration der Ändereungen in die Head-version
- Audio-Klassen unterstützen jetzt auch Frequenzänderungen und Stereoballanceänderungen des Sounds, dafür folgende neue Methoden in CAudio:
	void SetFrequency(float fFrequency); // Setzt die Frequenz in Hertz, wenn nicht aufgerufen wird die originale Frequenz des Samples genommen
	void SetPan(float ftPan); // Stereoeinstellungen zwischen links und rechts (-1 = links, 0= Mitte, 1 = rechts) 
	void ResetFrequency(); // Setzt die Frequenz wieder auf die originale Frequenz des Samples
- Umbenennung von sAxisX, sAxisX, sAxisZ in eAxisX, eAxisX, eAxisZ (Der Namenskonsistenz wegen)
- Neue Klasse CPhysical für die physikalische Animation
- Auf CPhysicals können einfache kräfte appliziert werden, fdafür folgende Funktionen:
	void ApplyForce(CHVector v); // Appliziert eine Kraft auf den Partikel, kann mehrfach angewendet werden
	void ApplyGravity(); // Applziert die normale Gravitationskraft auf das Partikel

- Alle CEmitter-Klassen und Apps von Michael Rücker gelöscht
- Neue CEmitter-Klasse geschrieben

2015-04-19 TB:
Bugfix: CGeoCube::InitByAABB war versehentlich global

2015-04-20 TB:
Neue Pickingroutine in CDeviceCursor:
	void PickPlacements(CPlacements * pzps); // Gibt alle Placements in pzps aus, welches unter dem Cursor liegen. Achtung, pzps muss muss ein Pointer auf ein instanziertes Placement-Objekt sein. 

2015-04-20 TB:
Bufgfix: SetFrustumCullingOn funtionierte nicht
 
2015-04-24 TB:
Bugfix: PickGeo funtionierte auf manchen Rechnern nicht im Release-Mode
Neues einfach zu bedienendes Log-File-System zum besseren Debuggen erstellt

2015-04-27 TB:
Bugfix: Picking war bei großen Kameraöffnungwinkeln ungenau
Bugfix: Löschen von using nemespace std; im Frame-Header
Bugfix: _DEBUG war in Projekteinstellungen mit Komma getrennt
Bugfix: CFrame::ReSize wurde nicht aufgerufen, wenn in den Vollbildmodus geswitcht wurde.
Picking funkioniert jetzt auch im Mirrormodus und im orthogonalen Kameramodus
Veraltete Network- und Drawable-Klassen gelöscht => Leichte Render-Beschleunigung (ca. 2%)
Neues Debug-LogFile-System eingeführt (TODO: Error-Meldungen eintragen)

2015-04-28 TB:
Bugfix: PickPlacements lieferte nicht alle Placements zurück
Bugfix: Game-Pointer in der Template-App war nicht auf Null initialisiert

2015-05-01 TB:
Spherical Environmental Mapping implementiert

2015-05-03 TB:
Spärische WASD-Steuerung implementiert

2015-05-05 TB:
Bugfix: CQuaternion CQuaternion::operator*=(CQuaternion & q) funktionierte nicht bei Werten != 0
Bugfix: CPlacement::SetPointing funktionierte nicht, wenn mehrere Instanzen des Zielplacements vorhanden waren
Zwei neue nützliche Funktionen in CPlacement: 
	void PlaceSphericalGlobal(float fRadius, float faAzimuth, float faAltitude, CPlacement * pzpCenter, int iGlobalInstance = 0); // Plaziert das Placment anhand Azimut, Elevation und Radiús global um ein anderes Zielplacement (gut, um Zielplacement von allen Seiten anzuschauen) 
	void PlaceSphericalLocal(float fRadius, float faAzimuth, float faAltitude, CPlacement * pzpCenter);// Plaziert das Placment anhand Azimut, Elevation und Radiús im lokalen Koordinatensystem um ein anderes Zielplacement (gut, um Zielplacement von allen Seiten anzuschauen, wenn beide Placements direkt an Szene hängen) 


2015-05-07 TB:
Picking-Routinen erkennen jetzt auch, ob Nodes ein- oder ausgeschaltet sind
PickPlacements gibt intelligentere Liste aus (mehrfache Instanzen ein- und desselben Placements werden nur noch einmal aufgelistet
Neue Routinen in CPlacments:
	bool AddOnce(CPlacement * pplacement); // Schaut, ob Placement schon in der Liste vorhanden ist, nur wenn nicht,  wird es hinzugefügt und true ausgegeben
	bool Has(CPlacement * pplacement); // Schaut, ob pplacement in der Liste vorhanden ist, wenn ja, wird true ausgegeben
Spherical EnvironmentalMapping wurde um 90° gedreht, damit es kompatibel zur Startrichtung von Domes ist
Bugfix: Projektionsmatrix bei LightSpots war bezüglich FarClippingPlane falsch
Testbed Materials erweitert

2015-05-10 TB:
Neue Klasse für Kollisionspunkte: 
- CHitPoint
Neue Picking-Routinen:
- PickGeo(); //Ohne Zusatzinfos
- PickGeos();
- PickHitPoints();
Icosahedron und Tetraeder können auch durch Radius Initialisiert werden

2015-05-11 TB:
V13 Patch 2 Erstellt

2015-05-15 TB:
Alle Intersect, Intersects, PickGeos, etc.-Routinen haben jetzt eine Vertices-Limitierung
Shaders-Basic beschleunigt 
Spherical Environmental Mapping beschleunigt
Spherical Environmental Mapping in Richtung der Z-Achse gedreht
Fresnel Parameter in CMaterial eingefürgt (TODO an Shader weiterreichen)
Picking-Routinen beschleunigt
Mehr Fehlermeldungen 
Splash-Screen sicherer gemacht

2015-05-20 TB:
Bugfix: PickOverlays pickte nicht immer das oberste Objekt
Bugfix: SwitchOff funktionierte nicht bei Writings 
Neue Picking-Routine in CDeviceCursor:
- 	CGeo * PickGeoPreselected(CGeos & zgs); // Untersucht nur diejenigen Geos, die in der Liste CGeos angegeben sind und pickt nur darus eine Geo aus, falls kein Geo gefunden wurde, ist das Ergebnis NULL. Diese Funktion kann das Picking stark beschleunigen

2015-05-21 TB:
Neue Picking-Routinen in CDeviceCursor:
	CHitPoint * PickHitPoint(); // Gibt den nähesten HitPoint aus, der unter dem Cursor liegt, falls kein Geo gefunden wurde ist das Ergebnis NULL, vIntersection ist der genaue Schnittpunkt, fDistanceSquare ist das Quadrat der Entfernung zwischen Strahlursprung und Schnittpunkt, kann bei großen Geometrien einige Millisekunden dauern, ist dafür sehr exakt
	void PickOverlays(COverlays * pzos); // Gibt alle Overlays in pzos aus, welche unter dem Cursor liegen, unabhängig davon, ob sie eventuell von anderen Overlays verdeckt werden. Achtung, pzos muss muss ein Pointer auf ein instanziertes Geos-Objekt sein. 
	void PickPlacements(CPlacements * pzps, bool bPickOnlyPlacementsWithDirectGeos = false); // Gibt alle Placements in pzps aus, welches unter dem Cursor liegen. Achtung, pzps muss muss ein Pointer auf ein instanziertes Placement-Objekt sein. 
	COverlay * PickOverlayPreselected(COverlays & zos); // Untersucht nur diejenigen Overlays, die in der Liste zos angegeben sind und pickt nur darus eine Geo aus, falls kein Geo gefunden wurde, ist das Ergebnis NULL. Diese Funktion kann das Picking stark beschleunigen
	CPlacement * PickPlacementPreselected(CPlacements & zps); // Untersucht nur diejenigen Placements, die in der Liste zps angegeben sind und pickt nur darus eine Geo aus, falls kein Geo gefunden wurde, ist das Ergebnis NULL. Diese Funktion kann das Picking stark beschleunigen
	CHitPoint * PickHitPointPreselected(CGeos & zgs); // Untersucht nur diejenigen HitPoints, die durch die Liste zgs erzeugt werden können
Neue Ray-Kollisionsroutinen in COverlays, CPlacements etc.

2015-05-22 TB: V13 Patch 4
Bugfix: ProgressBar auf Splash Screen hatte rote Streifen
Bugfix: ProgressBar-Methode SetProgress wurde mit Call-By-Reference angesprochen
Bugfix: In Basic-Shader & wurden spekulare Materialen weiß dargestellt
Reduced-Shader hinzugefügt (für Demos, die durch einen abgespeckten Shader die Performanz darstellen und für Projekte (wie das aktuelle Hochspannung-Projekt) welche eher Performanz als Darstellungsschönheit benötigen).
Mehr Fehlermeldungen für das Log-File

2015-05-31 TB: 
- BVH-Baum-Erstellung stark beschleunigt (ca. Faktor 100 bei zusammenlaufenden Hierarchien)
- Frustum-Berechnung leicht beschleunigt
- AABBs liegen nun "enger" an den tatsächlichen Werten 
- CGeoCube::InitByAABB funktioniert jetzt für beliebige Node3Ds
- Alle VisualHelper-relevanten Teile wieder herausgenommen (war veraltet und gehackt)
- Warnings herausgenommen

2015-06-02 TB: 
- Bugfix: Spotlights hatten in manchen Positionen eine falsche Lichtrichtung
- Bugfix: POM funktionierte nicht in Kombination mit Spotlights (zumindest im BasicShader)

2015-06-07 TB: V13 Patch 5 
- shader_Basic um Schatten erweitert
- Verbesserte SoftShadows
- Beschleunigung des shader_Basic
- shader.hlsl aufg korrekte Lichtrichtung gesetzt
- Frame auf Dunkelcyan
- Entrümpelung und Beschleunigung der Lichtberechnung

2015-06-08 TB: 
- BasicShader kann nun auch ChromaKeying
- BasicShader weiter beschleunigt
- BasicShader nimmt nun auch das Flag bShadingOff an
- BasicShader von den Variablenamen Vektoria-Konform gemacht
- Bugfix: LightParallel strahlte aus der engegengesetzten Richtung

2015-06-10 TB: 
- Bugfix: Writings waren immer im Vordergrund, egal welcher Layer gesetzt wurde
- Bugfix: SwitchOff/On funktionierte bei Writings manchmal nicht
- Bugfix: PickOverlay fand nicht die Unteroverlays
- Bugfix: Memoryleak in Wribel::Init
- PickOverlaysPreselected implementiert
- Splashscreen kann man nicht mehr so einfach durch Hide-Hacking ausschalten
- Workaround im OBJ-Importer für Blender-UV-Flip-Fehler (neuer optionaler Parameter bUVFlipVertical)

2015-06-11 TB: 
- Neue Picking-Routinen in CDeviceCursor:
	COverlay * PickOverlayOrWriting(); // Gibt erstes sichtbares Overlay oder Writing aus, welches unter dem Cursor liegt, falls kein Overlay bzw. Writing gefunden wurde ist das Ergebnis NULL
	CWriting * PickWriting(); // Gibt erstes sichtbares Writing aus, welches unter dem Cursor liegt, falls kein Writing gefunden wurde ist das Ergebnis NULL
	CWribel * PickWribel(); // Gibt erstes sichtbares Wribel aus, welches unter dem Cursor liegt, falls kein Wribel gefunden wurde ist das Ergebnis NULL
	CBackground * PickBackground(); // Gibt erstes sichtbares Background aus, welches unter dem Cursor liegt, falls kein Background gefunden wurde ist das Ergebnis NULL
	void PickOverlaysOrWritings(COverlays * pzos); // Gibt alle Overlays oder Writings in pzos aus, welche unter dem Cursor liegen, unabhängig davon, ob sie eventuell von anderen Overlays verdeckt werden. Achtung, pzos muss muss ein Pointer auf ein instanziertes Overlays-Objekt sein. 
	void PickWritings(COverlays * pzos); // Gibt alle Writings in pzos aus, welche unter dem Cursor liegen, unabhängig davon, ob sie eventuell von anderen Overlays verdeckt werden. Achtung, pzos muss muss ein Pointer auf ein instanziertes Overlays-Objekt sein. 
- Neue Picking-Routinen in COverlays:
	COverlay * PickOverlay(float frxViewport, float fryViewport, float &fLayerDistance, EOverlaySearch eOverlaySearch = eOverlaySearch_All); // Pickt vorderstes Overlay bzw. Writing in Overlay-Hierachie
	void PickOverlays(float frxViewport, float fryViewport, COverlays * pzos, EOverlaySearch eOverlaySearch = eOverlaySearch_All); // Pickt alle Overlays oder Writings in Overlay-Hierarchie
- Neue Picking-Routinen in COverlays:
	CBackground * PickBackground(float frxViewport, float fryViewport, float &fLayerDistance);
	void PickBackgrounds(float frxViewport, float fryViewport, CBackgrounds * pzbs);
- Erweiterte Picking-Routinen in CPlacement:
	CPlacement * PickPlacement(CRay & r, float & fMin, float & fMax, EPlacementSearch ePlacementSearch = ePlacementSearch_All); // Schaut, ob Placement mit der irgendeiner Boundingbox der Unterhueirarchie kollidiert, fMin und fMax geben die Ausmaßdistanzen des gefundnen Placments aus 
	void PickPlacements(CRay & r, CPlacements * pzps, EPlacementSearch ePlacementSearch = ePlacementSearch_All);
- Erweiterte Picking-Routinen in CScene:
	CPlacement * PickPlacement(CRay & r, EPlacementSearch ePlacementSearch = ePlacementSearch_All);
	void PickPlacements(CRay & r, CPlacements * zps, EPlacementSearch ePlacementSearch = ePlacementSearch_All);

2015-06-14 TB: (V13 Patch 6)
- Neue Picking-Routine in CDeviceCursor:
- 	CWribel * PickWribelPreselected(CWribels & zgw); // Untersucht nur diejenigen Wribels, die in der Liste zgw angegeben sind und pickt nur darus ein Wribel aus, falls kein Wribel gefunden wurde, ist das Ergebnis NULL.Diese Funktion kann das Picking stark beschleunigen
-   Bugfix: Mal-Operator in FloatRect lieferte für y-Wert falsche Ergebnisse, falls der Vater nicht Fullscreen war.
-   Bugfix: SetInner() platzierte Unteroverlays in Y-Richtung falsch  
-   Bugfix: PickOverlay und PickOverlays pickte Unteroverlays nicht richtig
-  SetInner funktioniert jetzt auch für Writings


2015-06-16 TB:
- Bugfix: Wribels wurden in in manchen Positionen heller 
- Nicht richtig funktionierende CDIGameController-Klasse von Matthias komplett gelöscht und durch eigene, neue Klassen ersetzt:
- CDIFoundController // Ein einzelner von Direct Input gefundener Game Controller
- CDIFoundControllers // Liste der von Direct Input gefundenen Game Controller
- CDIGameController // In die Applikation hinzugefügter Game Controller von DI 
- CDIGameControllers // In die Applikation hinzugefügter Game Controller von DI 
- CGameController // Für den Anwender sichbare Singular-Klasse
- CGameControllers // Pluralklasse von Game Controllers


2015-06-17 TB:
- Umfangreiches Testbed für Sounds gebaut 
- Umfangreiche Testung: Kann von einer Projektgruppe berichteter Fehler (Zwischen Stop und Start müssen angeblich einige Millisekunden liegen, damit Sound wieder abgespielt wird) partout nicht reproduzieren.
- Umfangreiches Testbed für Game Controller gebaut (mit drei verschiedenen Controllertypen getestet) 
- Game Controller funktionieren jetzt, auch mit beliebig vielen! :-)
- Smart Allocation in Plural-Klassen der Game Controller eiungebaut.

2015-06-18 TB: (V13 Patch 7)
- Logfile-Meldungen für Maus, Keyboard und GameController eingefügt 
- Neue Ansteuermethoden in CGameController: 
	float GetRelativeX(void); // gibt die X-Richtung des Hauptknüppels an (-1.0 ist links, 0.0 ist Mitte, 1.0 ist rechts). 
	float GetRelativeY(void); // gibt die Y-Richtung des Hauptknüppels an.(-1.0 bis +1.0, Ruhestelluzng = 0.0f) 
	float GetRelativeZ(void); // gibt die Z-Richtung des Hauptknüppels an.(-1.0 bis +1.0, Ruhestelluzng = 0.0f)
	float GetSliderMain(void); // Gibt die Stellung des Hauptsliders als Wert zwischen 0.0f und 1.0f an. (die meisten Joysticks/Gamepads haben nur diesen einen Slider)
	float GetSliderVice(void); // Gibt die Stellung des Nebensliders als Wert zwischen 0.0f und 1.0f an. (diese Slidert ist nur bei sehr exotischen Joysticks/Gamepads/Flightsticks vorhanden, trotzdem der Vollständigkeit halber implementiert)
	bool POV1Pressed(); // Ist die Point of View-Taste 1 aus der Ruhestellung gedrückt? (die meisten Joysticks/Gamepads haben nur diese eine POV-Taste)
	bool POV2Pressed(); // Ist die Point of View-Taste 2 aus der Ruhestellung gedrückt? 
	bool POV3Pressed(); // Ist die Point of View-Taste 3 aus der Ruhestellung gedrückt? 
	bool POV4Pressed(); // Ist die Point of View-Taste 4 aus der Ruhestellung gedrückt? 
	float GetAnglePOV1(); // Gibt die Orientierung der Point of View-Taste 1 im Bogenmaß an (die meisten Joysticks/Gamepads haben nur diese eine POV-Taste)
	float GetAnglePOV2(); // Gibt die Orientierung der Point of View-Taste 2 im Bogenmaß an
	float GetAnglePOV3(); // Gibt die Orientierung der Point of View-Taste 3 im Bogenmaß an
	float GetAnglePOV4(); // Gibt die Orientierung der Point of View-Taste 4 im Bogenmaß an
	void SetJoyRange(int iJoyRange); // Setzt den Wertebereich der Steuerung bzw. des Steuerknüppels.
	bool ButtonPressed(unsigned int uButton); // true, falls Taste uButton (Tastennummer gemäß DirectX) gedrückt wurde, ansonsten false

2015-06-28 TB:
- Neue Ansteuermethoden in CGameController: 
	float GetRelativeRX(void); // gibt die X-Richtung des R-Knüppels an. (-1.0 bis +1.0, Ruhestelluzng = 0.0f) 
	float GetRelativeRY(void); // gibt die Y-Richtung des R-Knüppels an. (-1.0 bis +1.0, Ruhestelluzng = 0.0f) 
	float GetRelativeRZ(void); // gibt die Z-Richtung des R-Knüppels an. (-1.0 bis +1.0, Ruhestelluzng = 0.0f) 
Letzte Reste der Lichterklasse von FS gelöscht und durch eigene ersetzt
Lichter scheinen jetzt nicht mehr in andere Szenen hinein!
Lichtübergabe leicht beschleunigt (wird aber durch die Überprüfung, ob Lichter in Szene drin sind mehr als kompensiert)
AABB ist jetzt auch Testbed für Lichtertestung
Lichter funktiieren jetzt auch im Monolight-Shader
 
2015-07-03 TB:
- Shader für BasicRenderer überarbeitet und aufgeräumt
- Interface für shaders_Own homogenisiert
- shaders_ShaderBasic heiß jetzt shaders_Monolight (Name war missverständlich)
- shaders heiß jetzt shaders_Standard (Name war missverständlich)


2015-07-06 TB:
- Neue Klasse für Szenegraph-Load/Save-Files hinzugefügt, mit folgenden Methoden:
	BOOL UMCheckFloat(float * f, float fMin, float fMax, float fDefault, char * szVariable, char * szUnit);
	BOOL UMCheckInt(int * i, int iMin, int iMax, int   iDefault, char * szVariable, char * szUnit);
	BOOL UMCheckLong(unsigned long * l, unsigned long  lMin, unsigned long lMax, unsigned long lDefault, char * szVariable, char * szUnit);
	BOOL UFLoadBool(BOOL  * pb, char * szKey, char * szSection, char * szIni);
	void UFLoadTrint(int  * pit, char * szKey, char * szSection, char * szIni);
	void UFLoadInt(int * pi, int   iMin, int   iMax, int   iDefault, char * szKey, char * szUnit, char * szSection, char * szIni);
	void UFLoadInt(int * pi, int   iMin, int   iMax, char * szKey, char * szSection, char * szIni);
	void UFLoadLong(unsigned long * pl, unsigned long  lMin, unsigned long   lMax, unsigned long   lDefault, char * szKey, char * szUnit, char * szSection, char * szIni);
	void UFLoadEnum(int * pe, int iDefault, char * szSelection, char * szKey, char * szSection, char *szIni);
	void UFLoad3Enum(int * pe, int iDefault, char * szSelection, char * szKey, char * szSection, char *szIni);
	void UFLoadXEnum(int * pe, int iDefault, char * szSelection, char * szKey, char * szSection, char *szIni);
	void UFLoadFloat(float * pf, float fMin, float fMax, float fDefault, char * szKey, char * szUnit, char * szSection, char * szIni);
	void UFLoadFloat(float * pf, float fMin, float fMax, char * szKey, char * szSection, char * szIni);
	void UFLoadString(char * sz, char * szKey, char * szSection, char * szIni);
	void UFLoadAngle(float * pfa, char * szKey, char * szSection, char * szIni);
	void UFLoadFract(float * pfr, char * szKey, char * szSection, char * szIni, BOOL bLimitMax = TRUE);
	void URLoadVector(CHVector *pv, char * szKey, char * szSection, char * szIni);
	void URLoadColor(CColor * color, char * szKey, char * szSection, char *szIni);
	int UFLoadSectionCount(char * szPrefix, char * szIni);
	BOOL UFLoadSectionInit(char * szPrefix, char * szIni);
	BOOL UFLoadSectionNext(char * szSection, char * szSuffix1, char * szSuffix2);
	BOOL UFLoadSectionNext(char * szSection);
	void UFLoadSectionFini();
	BOOL UFSaveBool(BOOL b, char * szKey, char * szSection, char * szIni);
	void UFSaveTrint(int it, char * szKey, char * szSection, char * szIni);
	void UFSaveInt(int i, char * szKey, char * szSection, char * szIni);
	void UFSaveLong(unsigned long l, char * szKey, char * szSection, char * szIni);
	void UFSaveEnum(int e, char * szSelection, char * szKey, char * szSection, char * szIni);
	void UFSaveFloat(float f, char * szKey, char * szSection, char * szIni);
	void UFSaveString(char * sz, char * szKey, char * szSection, char * szIni);
	void UFSaveAngle(float fa, char * szKey, char * szSection, char * szIni);
	void UFSaveFract(float fr, char * szKey, char * szSection, char * szIni);
	void URSaveVector(CHVector *pv, char * szKey, char * szSection, char * szIni);
	void URSaveColor(CColor * color, char * szKey, char * szSection, char *szIni);

2015-07-07 TB:
- CFileVektoria-Klasse ist von der Parameterübergabe efizienter geworden
- Globale Variablen wurden in Membervariablen umgeändert.
- Neue Methoden in CFileVekoria:
		void SetFile(char * acFile);
		void SetSection(char * acSection, int id);
		void SetSection(char * acSection);
		void LoadChararray(char * ac, char * acKey);
		void LoadMat(CHMat & m, char * acKey);
		void SaveMat(CHMat & m, char * acKey);
- Images und Textures können gesaved und geladen werden (Andere Knotenobjekte werden folgen)
- CImage wird jetzt von CNode abgeleitet

2015-07-12 TB:
- Einige Bugfixes in CFileVektoria
- Materialien können jetzt fast vollständig gespeichert und wieder geladen werden (TODO: Noch einigige kleinere Bugs)

2015-07-12 TB:
- Materialien können jetzt vollständig gespeichert und wieder geladen werden => Einheitliche Materialbibliotheken möglich
- Neue Methoden in CFileVektoria:
	void LoadVertex(CVertex & vertex, char * acKey);
	void SaveVertex(CVertex & vertex, char * acKey);
- Neue Methoden in CGeo und CVertexs:
	void Load(CFileVektoria & filevekoria);
	void Save(CFileVektoria & filevekoria);
- Neue Methoden in CGeo:
	bool Intersects(CRay & r, CHVector & vIntersection, float & fDistanceSquare, int & iMatGlobal); // berechnet, ob Strahl r ein Dreieck der Geometrie mit der Instanz iMatGlobal trifft, vIntersection ist dann der Schnittpunkt
	CHitPoint * Intersects(CRay & r, int iMaxVertices = INT_MAX); // berechnet, ob Strahl r ein Dreieck der Geometrie trifft, CHitpoint ist dann der Schnittpunkt
	bool Intersects(CRay & r, int iMaxVertices = INT_MAX); // berechnet, ob Strahl r ein Dreieck der Geometrie trifft, gibt true aus, wenn ja

2015-07-16 TB:
- Vektoria Materialfiles (.vem) fertig und weitestgehend getestet
- VektoriaFile::SetFile kann jetzt auch mit relativen Pfaden umgehen
- Neue Methode in CMaterial:
		void LoadPreset(char * acName); // Lädt vorgefertigtes Material mit dem Namen acName mit allen Parametern, Texturen, etc.
- Zwei Beispiel-Preset-Materialien erzeugt: "Water" und "LeatherBlack" 

2015-07-18 TB:
- Folgende Preset-Materialien erzeugt:
	- Concrete
	- BricksClinker
- Eingige Bugfixes bezüglich CFileVektoria::SaveVertex
- Geometrien können jetzt korrekt gespeichert werden
- Insersect-Methoden in CGeo jetzt virtuell
- Folgende neue Methoden in CGeo:
	- LoadPreset(filevektoria); 

2015-07-19 TB:
- Auch TriangleStrips werden korrekt gespeichert
- Geometrien können jetzt nicht nur gespeichert, sondern auch vollständig gfeladen werden

2015-07-21 TB:
- Preset Geometrie "EggBrown" erzeugt
- Preset Material "EggshellBrown" erzeugt

2015-07-21 TB:
- Redundanzverringerung und Vereinheitlichung von CGeoTriangleStrip und CGeoTriangleList
- Draw-Methode läuft jetzt auch für Geos ohne Strip- oder List-Instanz

2015-07-25 TB:
- Bugfix: CFileVektoria::LoadVertex ludt Bitangente nicht korrekt
- Neue Methode zum Laden von vorgefertigten Geometrien funktioniert jetzt und ist getestet
		CGeo::LoadPreset()

2015-07-26 TB:
- BricksKlinker verbessert
- Color-shift Matrix eigebaut => Verschiedene Farb-Varianten ein- und desselben Materials möglich
- VUMeter-Beispiel 

2015-07-26 TB:
- Zwei neue Methoden in CHMat: RotateHue und RotateHueDelta
- Alle Shader des Basic-Shaders können jetzt Colorshift 
- void CViewport::StyleRotateHue(float faHue) von den Farbwerten verbessert
- Neue Methode in CViewport::StyleRotateHueDelta(float faHue) 

2015-07-30 TB:
 - Bugfix: Shader verfälschte Rotkanal bei negativen Werten

2015-08-08 TB:
 - TCP- und UDP-Network-Klassen geschrieben, getestet
 - Broadcast und Calls funktionieren 

2015-08-09 TB:
- Ähnliche TCP- und UDP-Network-Klassen von KE zugemailt bekommen
- Network-Klassen von KE getestet, funktionieren nur für TCP

2015-08-11 TB:
- Network-Klassen von mir und KE miteinander verschmolzen, überarbeitet, getestet
- Network-Klassen an Vektoria angepasst, 
- Überflüssige und schädliche Includes entfernt
- Network-Klassen in Vektoria integriert 

2015-09-03 TB:
- Neue Methoden in CNetworkUDPServer:
		void SendBroadcast(bool & b);
		void SendBroadcast(int & i);
		void SendBroadcast(unsigned int & i);
		void SendBroadcast(float & f);
		void SendBroadcast(CHMat & m);
		void SendBroadcast(CColor & color);
- Angefangen, die Übermittlungsdaten in RenderDistributed zu senden
- Manual überarbeited
- in Schnittstellen Aufgeräumt
- CNetworkUDPClient: Allgemeine IP-Adressen möglich 

2015-09-09 TB:
- Broadcasts jetzt möglich und getestet

2015-09-12 TB:
- Optimierung der Client-Broadcasts

2015-09-20 TB:
- Das neue Programm "VektoriaClient" Erzeugt

2015-09-23 TB:
- Bugfix: Semicoli in defines von CMaterial gelöscht
- Init-Methode sendet nun die korrekten Daten (getestet)

2015-09-23 TB:
- Tick und Fini-Methoden senden nun die korrekten Daten (getestet)


2015-10-01 TB:
- Neue Methoden in NetworkUDPClient:
		bool RecvBroadcastB(); // Wandelt erhalteten Broadcast in einen Bool um
		int RecvBroadcastI(); // Wandelt erhalteten Broadcast in einen Integer um
		float RecvBroadcastF(); // Wandelt erhalteten Broadcast in einen Float um
		CHMat RecvBroadcastM(); // Wandelt erhalteten Broadcast in einen CHMat um

2015-10-04 TB:
- Init, Tick und Fini erhalten jetzt die Broadcast-Daten (TODO: Testing)

2015-10-08 TB:
- Neue Methode in CViewports:
	CViewport * GetByID(unsigned int id); // Gibt einen Pointer auf denjenigen Viewport mit der entsprechenden ID zurück, falls nicht in der Liste vorhanden, wird Nullptr ausgegeben.	
- Namenskonsistenz in ApiRender verbessert, z.B. m_matprojection in m_mProjection umgetauft
- Projektabhängigkeiten in VektoriaClient korrekt gesetzt
- VektoriaClient ruft jetzt wahlweise BasicRenderer oder FP-Renderer auf.
- Bugfix: CHMat RecvBroadcastM(); übermittelte falsche Werte
- Neue Methoden in CColor:
	void InitWhite();		// Initalisiert eine 100% weiße Farbe
	void InitBlack();		// Initalisiert eine 100% schwarze Farbe
	void InitRed();			// Initalisiert eine 100% rote Farbe
	void InitBlue();		// Initalisiert eine 100% blaue Farbe
	void InitGreen();		// Initalisiert eine 100% grüne Farbe
	void InitYellow();		// Initalisiert eine 100% gelbe Farbe
	void InitCyan();		// Initalisiert eine 100% türkise Farbe
	void InitMagenta();		// Initalisiert eine 100% magentafarbene Farbe 
	void InitGrey();		// Initalisiert eine graue Farbe mit 50% Weißanteil 
- Neue Methode in CNetworkUDPClient:		
	CColor RecvBroadcastC(); // Wandelt erhalteten Broadcast in einen CColor um

2015-10-11 TB:
- Fünf weitere API-Routinen vom  Renderclient erhalten Werte
- Mehrere Viewports im Renderclient jetzt möglich
- RenderClient beschleunigt durch direkte Recv-Methoden


2015-10-14 TB:
- Fünf weitere API-Routinen vom  Renderclient erhalten Werte, u.a.: 
	CreateLight
	DestroyLight
	CreateMaterial
	UpdateMaterial
	DestroyMaterial
- Neue längst Überfällige Methode in CTexture:
	void SetImage(CImage * pimage);
- Neue Methode in NetworkUDPServer:
	void SendBroadcast(CHVector & v);
- Neue Methode in NetworkUDPClient:
	CHVector RecvBroadcastV(); // Wandelt erhalteten Broadcast in einen CHVector um
- Neue Methode in CMaterials:
	CMaterial * Get(unsigned int id); // Gibt Materialpointer desjenigen Materials mit der entsprechenden ID aus, falls nicht existent, wird ein nullptr ausgegeben
- Neue Methode in CTextures:
	CTexture * Get(unsigned int id);
- Neue Methode in CImages:
	CImage * Get(unsigned int id);
- Neue Methode in CGeoTriangleStrips:
	CGeoTriangleStrip * Get(unsigned int id);
- Neue Methode in CGeoTriangleLists:
	CGeoTriangleList * Get(unsigned int id);

2015-10-16 TB
- Veraltetes m_avertices in CGeo gelöscht
- CGeo braucht nun weniger Speicherplatz
- Folgende neue Methode in NetworkUDPServer:
		int RecvI(); // Holt eine Message vom Client und interpretiert sie als Integer
- Folgende neue Methode in NetworkUDPClient:
		void SendToMaster(int i); // Sendet eine Integer-Zahl zum Master zurück

2015-10-18 TB
- Handles werden bei Create-Routinen nun an Master zurückgesendet
- Meherere Bugfixes in RenderDistributed 

2015-10-19 TB
- Handshake-Modifikationen
- Testen und Optimieren der UDP-Geschwindigkeit
- Neue Methode in CCameras:
	CCamera * Get(unsigned int id); // Gibt den Pointer derjenigen Kamera mit der Identifikationsnummer id aus, falls nicht vorhanden, wird ein Nullpointer ausgegeben

2015-10-20a TB (Rev.800)
- Neues, kleineres Testbed
- Senden und Receiven der Kameradaten
- Bugfix: Falsche Viewport-ID übermittelt
- Bugfix: Falsche Matrizen bei Viewport übermittelt

2015-10-20b TB 
- Broadcast-Receive-Methoden leicht beschleunigt
- Bugfix: RecvBroadcastM scannte fasche Werte
- Bugfix: RecvBroadcastV scannte fasche Werte
- Bugfix: RecvBroadcastC scannte fasche Werte
- Bugfix: AddViewport wurde im Client nicht aufgerufen

2015-10-23 TB 
- Lichter-Interface komplett überarbeitet, alle drei Lichttypen werden nun sauber übermittelt! 
- erste Remote-Bilder :-)

2015-10-26 TB: 
- Bugfix: eKind in CNode wurde von CTexture fälschlicherweise überladen => Umbenennung in eKindTexture
- Bugfix: Glow-Texturen wurden in Preset-Materialien nicht richtig geladen
- Bugfix: Preset-Materialien-Files waren veraltet  
- Beschleunigung des Copy-Operators von Integer
- SetColor jetzt für alle drei Lichtarten möglich

2015-10-29 TB:
- Erste Schritte zur zukünftigen DLL-Umwandlung in der Rendermodule:
	- Lichter-API-Methoden sind nun unabhänging von Core-Klassen
	- ID der Lichter wird nun downwards zu den Rendermodulen übermittelt und nicht umgekehrt
- Bugfix: Beim Distributed Rendering: Lichter-IDs wurden nicht erkannt
	 
2015-11-03 TB:
- Bugfix: Beim Distributed Rendering: Spot-Lights wurden nicht richtig übermittelt
- Bugfix: Beim Distributed Rendering: Animierte Farben wurden nicht richtig übermittelt
- Beschleunigung der übermittelung beim Distributed Rendering

2015-11-04 TB:
- Alle Materialienparameter für den FP-Shader werden nun übermittelt
- Neue Errormelungen fürs Logfile in CApiDirectX 

2015-11-05 TB:
- Bugfix: Das Verteilte Renderingmodul stürzte bei zu langen Initialisierungen ab.

2015-11-06 TB:
- Folgende neuen Methode in CNetworkUDPClient
		void SendHandshake(); // Sendet ein Handshake zum Master zurück
- Folgende neuen Methode in CNetworkUDPServer
		void RecvHandshake(); // Wartet auf ein Handshake von irgeneinem Client
- Folgende neuen Methode in CNetworkUDPClient
- Handshakes nach jedem Befehl eingeführt
- Beschleunigung der Rückübertragung

2015-11-07 TB:
- Bugfix: Resizing funkioniert jetzt

2015-11-08 TB:
Neue Methoden in CViewport:
		void InitHalfLeft(CCamera * pcamera); // Initialisiert Viewport, so dass er die linke Hälfte des Frames ausfüllt
		void InitHalfRight(CCamera * pcamera); // Initialisiert Viewport, so dass er die rechte Hälfte des Frames ausfüllt
		void InitHalfUpper(CCamera * pcamera); // Initialisiert Viewport, so dass er die obere Hälfte des Frames ausfüllt
		void InitHalfLower(CCamera * pcamera); // Initialisiert Viewport, so dass er die untere Hälfte des Frames ausfüllt
- FFlushs vor jedem Send- und nach jedem Receive-Befehl eingesetzt

2015-11-10 TB:
- Beschleunigung der Übertragung beim Verteilten Rendering
- Log-File-Error-Meldungen in DirectX11-Klasse eingefügt

2015-11-12 TB:
- Verteiltes Rendering im Release-Mode (auf einem Rechner) ausgiebig getestet
- Handshake bei Draw-Methode wieder herausgenommen (scheint nicht notwenidig)

2015-11-14 TB:
- Komplettumbau der Render-Api angefangen (für die freie Konfiguration beim Verteilten Rendering und für die spätere DLL-Modularisierung)
- Upward-RenderHandles durch Downward-IDs ersetzt
- Render-Api-Schnittstellenroutinen aufgeräumt und übersichtlicher gestaltet
- Neue Klassen, welche die alte Buffermap ersetzen sollen (waren notwendig geworden, wegen Wegfall der Handles):
	- CDXBuffer
	- CDXBuffers

2015-11-16 TB:
- Neue Api-Routinen funktionieren jetzt (aber Lichter sind noch korrupt)

2015-11-18 TB:
- Neue Api-Routinen funktioniert jetzt auch mit Lichtern
- Neue übersichtliche Api-Schnittstellen-Funktionen fertig:
	virtual void CreateEmitter(unsigned int & idEmitter, CEmitter * pemitter) = 0;
	virtual void UpdateEmitter(unsigned int & idEmitter, CEmitter * pemitter) = 0;
	virtual void DeleteEmitter(unsigned int & idEmitter) = 0;
	virtual void CreateGeoTriangleList(unsigned int & idGeo, CGeoTriangleList *ptrianglelist) = 0;
	virtual void CreateGeoTriangleStrip(unsigned int & idGeo, CGeoTriangleStrip *ptrianglestrip) = 0;
	virtual void UpdateGeoTriangleList(unsigned int & idGeo, CGeoTriangleList *ptrianglelist) = 0;
	virtual void UpdateGeoTriangleStrip(unsigned int & idGeo, CGeoTriangleStrip *ptrianglestrip) = 0;
	virtual void DeleteGeo(unsigned int & idGeo) = 0;
	virtual void CreateLightParallel(unsigned int & idLight, CViewports & viewportsAnchestor, CColor & color, CHVector & vDirection) = 0;
	virtual void CreateLightSpot(unsigned int & idLight, CViewports & viewportsAnchestor, CColor & color, CHMat & mProjection, bool & bCauseShadow, bool & bSoftShadow, bool & bCascatedShadow, int & ixShadowMap, int & iyShadowMap, float & fAttenuationConstant, float & fAttenuationLinear, float & fAttenuationQuadratic, float & fOuterCosAngle, float & fInnerCosAngle, float & fRadius) = 0;
	virtual void CreateLightRadial(unsigned int & idLight, CViewports & viewportsAnchestor, CColor & color, float & fAttenuationConstant, float & fAttenuationLinear, float & fAttenuationQuadratic) = 0;
	virtual void UpdateLightPos(unsigned int & idLight, CHMat & m) = 0;
	virtual void UpdateLightColor(unsigned int & idLight, CColor & color) = 0;
	virtual void UpdateLightDir(unsigned int & idLight, CHVector & vDirection) = 0;
	virtual void DeleteLight(unsigned int & idLight) = 0;
	virtual void CreateViewport(unsigned int & idViewport, CViewport *pviewport) = 0;
	virtual void UpdateViewport(unsigned int & idViewport, CViewport *pviewport) = 0;
	virtual void DeleteViewport(unsigned int & idViewport) = 0;
- CDirectX11Basic aufgeräumt
- Netzwerk-Klassen aufgeräumt

2015-11-25 TB:
- Beschleunigung der Methodenübertragung
- Überflüssige Initialisierungen in NetworkUDPServer und NetworkUDPClient entfernt

2015-11-26 TB:
- Testbed zur Suche nach Remote-Übertragungsfehler

2015-11-29 TB:
- Bugfix: Remote-Übertragung stürtzte ab und zu ab
- Bugfix: Spotlight-Matrix wurde nicht richtig übertragen

2015-12-01 TB:
- Komplette Überarbeitung der Viewport- und Geo-Render-Aufruf-Reihgenfolge (Notwendig, zur Beschleunigung und zum Verteilten Rendering) zur Vermeidung von Redundanzen
- Api-Routinen noch übersichtlicher und vopr allem flexibler aufgebaut, dafür folgende zusätzliche Api-Routinen
	virtual void RenderGeo(unsigned int & idGeo, int & idTexture, float & fDistanceToCameraSquare, int iKind, CHMat & mGlobal, unsigned int aidLightsAffect[4], unsigned int iLightsAffectCount) = 0;
	virtual void RenderScene() = 0;

2015-12-03 TB:
- Ein 3D Sound kann jetzt auch mehrere Instanzen in zusammenlaufenden Hierarchien haben
- Logfile-Einträge bei Fehlern in DirectSound-Api
- DirectSound-Klasse etwas aufgeräumt

2015-12-04 TB:
- Verschiedene Untertestbeds in Testbed-General zum Testen der neuen Render-Schnittstelle eingefügt 

2015-12-05 TB:
- Bugfix: Intellisense spielte bei den Netzwerk-Klassen verrückt
- Zwei neue Methoden in NetworkBase:
		void GetOwnIP(char * acIPAddress);
		void GetOwnName(char * acHost);
- Ein 3D Sound kann auch an mehere Szenen angehängt werden

2015-12-15 TB:
- Verteiltes Rendering mit mehreren Clients möglich.

2015-12-22 TB:
- Beschleunigung der Übertragung durch größere UDP-Datenpakete (sammeln der Daten), dafür folgende Methoden in CNetwoktUDPServer:
		void CollectMethod(char * ac);
		void Collect(char * ac); // Sammelt den string für einen späteren Broadcast 
		void Collect(bool & b); // Sammelt den boolschen Wert b für einen späteren Broadcast 
		void Collect(int & i); // Sammelt die ganze Zahl i für einen späteren Broadcast  
		void Collect(unsigned int & u); // Sammelt den unsigned int u für einen späteren Broadcast  
		void Collect(float & f); // Sammelt dei Gleitkommazahl f für einen späteren Broadcast 
		void Collect(CHMat & m); // Sammelt die Matrix m für einen späteren Broadcast 
		void Collect(CHVector & v); // Sammelt den Vektor v für einen späteren Broadcast 
		void Collect(CColor & color); // Sammelt die Farbe color für einen späteren Broadcast 
		void SendBroadcastCollection(); // Sendet per Broadcast alle gesammelten Werte mit einem einzigen UDP-Paket, löscht danach die Sammlung
- ... und folgende Methoden in CNetwoktUDPClient:
		void RecvSelection(); // Wandelt erhaltetes UDP-Paket in eine Selection um
		void SelectS(char * ac); // Extrahiert eine Zeichenkette aus der Selection 
		bool SelectB(); // Extrahiert einen Bool aus der Selection 
		int SelectI(); // Extrahiert einen Integer aus der Selection 
		float SelectF(); // Extrahiert einen Float aus der Selection 
		CHMat SelectM(); // Extrahiert einen CHMat aus der Selection 
		CHVector SelectV(); // Extrahiert einen CHVector aus der Selection 
		CColor SelectC(); // Extrahiert eine CColor aus der Selection 

2015-12-30 TB:
- Bugfix: UpdateMaterial funktionierte im Verteilten Rendering nicht

2016-01-01 TB:
- Umbenennung von folgenden Knoten, zur Vereinheitlichung der Vektoria-Notation:
	CPointLight(s) in CLightRadial(s)
	CSpotLight(s) in CLightSpot(s)
	CParallelLight(s) in CLightParallel(s)
- Umbenennung der entsprechenden Add- und Sub-Methoden

2016-01-02 TB:
- Neue Api-Routine:
	UpdateLightSwitch(bool bOn);
- POM kann jetzt mit einem Parameter skaliert werden: m_fHeightStrength
- Dafür folgende neue Methode in CMaterial:
	void SetHeightStrength(float fHeight);
	
2016-01-03 TB:
- Fresnel-Faktor kann jetzt die Spiegelung und/oder das Highlight beeinflusssen, dafür folgende neue Methode in CMaterial:
	void SetFresnel(float frFresnel);
- Brechungsindex kann jetzt eingegeben werden, dafür folgende Methode in CMaterial:
	void 
- Monolight-Shader POM-Fähig gemacht.
- POM in Monolight-Shader leicht überarbeitet

2016-01-05 TB:
- Veraltete EZ-Logger-Klassen entfernt
Neue Methode in CMaterial:
- SavePreset 

2016-01-06 TB:
Material-Lib erstellt mit folgenden Preset-Materialien:
- Water
- BricksClinker
- BricksClinkerColored
- Concrete
- MetalRusty 

2016-01-07 TB:
Folgende neue Materialien für Material-Lib
- Vanish
- MirrorPure
- LeatherBlack 
- RockMossy

2016-01-08 TB:
Font-Lib erstellt mit folgenden Preset-Fonts:
- Tannenberg
- Earthquake
- Arial

2016-01-09 TB:
- Folgende praktische Methoden in CDeviceKeyboard implementiert:
	bool KeyDown(int iKey); // einmal true, falls Taste iKey (Tastaturnummer gemäß DirectX) gerade im letzten Tick nach unten gedrückt wurde, ansonsten false
	bool KeyUp(int iKey); // einmal true, falls Taste iKey (Tastaturnummer gemäß DirectX) gerade im letzten Tick losgelassen wurde, ansonsten false
- Folgende Methoden in CDeviceKeybopard verschoben, aufgeräumt und beschleunigt:
	void SetWASDLevelMin(float fyLevelMin); // Erzeugt Kameraminimalhöhenlevel für die Erdsteuerung, die Kamera kann nie unter fyLevelMin untertauchen
	void SetWASDLevelMax(float fyLevelMax); // Erzeugt Kameramaximalhöhenlevel für die Erdsteuerung, die Kamera kann nie über fyLevelMax steigen
	float GetWASDLevelMin(); // Holt Kameraminmalhöhenlevel für die Erdsteuerung, die Kamera kann nie  über fyLevelMax drübersteigen
	float GetWASDLevelMax();// Erzeugt Kameramaximalhöhenlevel für die Erdsteuerung, die Kamera kann nie unter fyLevelMin untertauchen
	virtual void SetWASDTranslationSensitivity(float fTranslationSensitivity); // Setzt die Verschiebungsempfindlichkeit (Geschwindigkeit) bei den WASD-Tasten in Einheiten / Sekunde für PlaceWASD und PlaceWASDPan
	virtual void SetWASDRotationSensitivity(float fRotationSensitivity); // Setzt die Drehempfindlichkeit (Rotationsgeschwindigkeit) bei den Pfeil-Tasten in Bogenmaß / Sekunde für PlaceWASDP und PlaceWASDPan
	virtual float GetWASDTranslationSensitivity(); // Holt den Parameter für die Verschiebungsempfindlichkeit (Geschwindigkeit) in Einheiten / Sekunde für PlaceWASDP und PlaceWASDPan
	virtual float GetWASDRotationSensitivity(); // Holt den Parameter für die Drehempfindlichkeit (Rotationsgeschwindigkeit) bei den Pfeil-Tasten in Bogenmaß / Sekunde für die PlaceWASD und PlaceWASDPan
	virtual void SetWASDAltitude(float fa); // Setzt den Anfangswinkel bei einer WASD-PAN-Steuerung
	virtual void SetWASDPanRadius(float fRadius); // Setzt den Radius bei einer WASD-PAN-Steuerung
	virtual bool PlaceWASD(CPlacement & placementCamera, float & fTimeDelta, bool bEarth = false); // WASD Steuerung,  true, falls Space Taste gedrückt wurde
	virtual bool PlaceWASDPan(CPlacement & placementCamera, CPlacement & placementCenter, float & fTimeDelta, bool bRot = false); // WASD Steuerung um ein Zentrum, true, falls Space Taste gedrückt wurde
	virtual void GetMove(int &riAD, int &riSW, int &riFR, int &riLeftRight, int &riUpDown, int &riPageUpDown, bool &rbSpace); // Hilfsroutine für eigene WASD-Steuerungen


2016-01-10 TB:
- Code aufgeräumt und neue Komentare erstellt

2016-01-11 TB & KE:
- Verteiltes Rendering mit drei Rechern getestet, funktioniert! :-)

2016-01-12 TB:
-InputApi komplett überarbeitet, für die spätere Umwandlung in DLLs 

2016-01-13 TB:
- PlaceWASD und PlaceWASDPan, komplett überarbeiet und beschleunigt
- Auch für PlaceWASDPan kann jetzt eine maximale und minimale Höhe eingegeben werden
- PlaceWASDPan kann jetzt durch einen dritten Parameter auch nach links oder rechts schwenken

2016-01-15 TB:
Materialdemo total überarbeitet, aufgefrischt

2016-01-16 TB:
Folgende neue Methoden in CAudio:
	float GetAmplitudeCurrent(int iAudio = 0); // Gibt die aktuelle Amplitude des Sounds in einer Skala zwischen -1 und +1 aus (Achtung alpha, noch ungetestet!)
	float GetAmplitudeAverage(int iSamples, int iAudio = 0); // Gibt die aktuelle Amplitude des Sounds in einer Skala zwischen -1 und +1 aus (Achtung alpha, noch ungetestet!)
	float GetAmplitudeMax(int iSamples, int iAudio = 0); // Gibt die maximale Amplitude des Sounds der letzten i Samples in einer Skala zwischen -1 und +1 aus (Achtung alpha, noch ungetestet!)

2016-01-17 TB:
- Monolight-Shader kann jetzt auch Subsurface-Scattering

2016-01-18 TB:
- Monolight-Shader beschleunigt und aufgeräumt
- Subsurface-Scattering kann jetzt parametrisiert werden, dafür folgende 

2016-01-19 TB:
Folgende neue Materialien:
- RockMossy
- TilesDirty
- Suede

2016-01-20 TB:
- Monolight-Shader kann jetzt auch weiche Silhouetten, dafür folgende neue Methode in CMaterial: 
		void SetTransparencyEdge(float frTransparancyEdge); // Setzt die Durchsichtigkeit der Sihouette, funktioniert nur vernünftig bei konvexen Objekten (Kugeln, Ellipsoide, Stanford bunnies, etc.)
- Colorshift kann jetzt mit Alphakanal der Specularmap maskiert werden

2016-01-21 TB:
Font-Lib erweitert uind vereinheitlicht mit folgenden neue Fonts:
- CreatorWhite (jeweils in Weiß, Schwarz und Farbig)
- LucidaConsole (jeweils in Weiß, Schwarz und Farbig)
- OCRAExtended (jeweils in Weiß, Schwarz und Frabig)
- SimSun 
- Rod
- PrestigeElite
- WritingFonts auf folgende Default-Werte umgestellt, um kompatibel mit der Font-Lib zu sein 
	m_ixPics = 16;
	m_iyPics = 14;
	m_iTableStartASCII = 32;

2016-01-22 TB:
- Writings können jetzt auch Farbe wechseln

2016-01-23 TB:
- Folgende neue Materialien in Material-Lib:
- Glass
- Blood
- Quicksilver
- TilesMarbleWhite

2016-01-24 TB:
- Übergabe bei shaders_Own, shaders_Reduced und shaders_Standard vereinheitlicht
- Vereinheitlichte und sinnvolle Kommentare in Material.h

2016-01-26 TB:
Neue Methode in CMaterial für spätere Partikeleffekte:
		void SetTransparencyEdge(float frTransparancyEdge); // Setzt die Durchsichtigkeit der Sihouette, funktioniert nur vernünftig bei konvexen Objekten (Kugeln, Ellipsoide, Stanford bunnies, etc.)

2016-01-27 TB:
- ShaderStandard runderneuert 
Bugfix: LightID wurde beim zweiten Licht nicht gefunden 

2016-01-28 TB:
- Übertragung der neuen Materialparameter auch im Distributed Rendering

2016-02-01 TB:
- Beliebig viele Lichter im Basic-Renderer möglich
- Leichte Beschleunigung der Lichtersuche im Basic-Renderer 

2016-02-02 TB:
- Logfile beschleunigt & intelligenter (gibt im Release-Mode nur Error und Debug-Meldungen aus)

2016-02-03 TB:
- Es gibt nun aussagekräftige Kommentare zu jeder Methode in CMaterial
- Jeder Knoten kann nun benannt werden

2016-02-03 TB:
Folgende neue Materialien in Material-Lib:
- WoodPlanksBankirai
- WoodPlanksSpaced
- PanoPlate
- Suede

2016-02-05 TB
- Möglichkeit, auch im Release-Modus ins LOG-File zu schreiben
Bugfix: Release-64-Modus funktionierte nicht

2016-02-06 TB
- Lagging im Verteilten Rendering entscheidend reduziert

2016-02-07 TB
Progress-Bar verbessert (zählt jetzt auch die Geometrien in der Szene)
Bugfix: Progress-Bar wurde bei verteiltem Rendering doppelt so lang

2016-02-08 TB:
Beschleunigung des Shaders
Angefangen mit der Konfig-File-Programmierung
Folgende neue Fonts in Font-Lib:
- TannenbergBoldBlack
- TannenbergBoldWhite
- TannenbergBoldRed
- TannenbergBoldOutlined

2016-02-09 TB:
Folgende neue Materialien in Material-Lib:
- CobblestoneMarble
- CounterDigital
- RubberBlack
- MetalAlu
- MetalCromeCircuit
- WallFachwerk
Folgende Materialien optisch verbessert: 
- Glass
- Water
- WoodPlanksBankirai

2016-02-10 TB:
- BricksClinker Colored für die Color-Rotation maskiert
- Material-Demoversion verbessert
Übersichtliche Sprite-Methoden:
		void SetViewport(CViewport * pviewport); in protected Zone, friend-classes erzeugt1


2016-02-12 TB:
Folgende neue Methode zum Checken der korrekten Grundkonfigiration, mit Log-File Einträgen: 
		bool CheckHierarchy();
- Umbau der Tick-Methode, dahingehend, dass vorher die Hierarchie überprüft wird, dann bei Erfolg die Hierarchie realisiert und dann erst die Draw-Calls (für Anwender sicherer)

2016-02-13 TB:
Bugfix: Placement::Copy funktionierte nicht richtig
Root::Tick beschleunigt 

2016-02-14 TB:
Folgende neue Load und Save-Methoden:
- CPlacement::Load
- CPlacement::Save
- CCamera::Load
- CCamera::Save
- CFrame::Load
- CFrame::Save
- CHardware::Load
- CHardware::Save
- CViewport::Load
- CViewport::Save
- CSprite::Load
- CSprite::Save
- COverlay::Load
- COverlay::Save
- CBackground::Load
- CBackground::Save

2016-02-16 TB:
Folgende neue Methoden in CRoot zum Laden bzw. abspeichern von Hardwarekonfigurationen
- void LoadRealHierachy(HWND hwnd, void(*procOS)(HWND hwnd, unsigned int uWndFlags), CFileVektoria & filevektoria, CFrame & frameMain, CPlacement & placementCamerasSingle);
- void LoadRealHierachy(HWND hwnd, void(*procOS)(HWND hwnd, unsigned int uWndFlags), CFileVektoria & filevektoria, CFrame & frameMain, CPlacements & placementsCameras);
- void SaveRealHierachy(CFileVektoria & filevektoria, CPlacements & placementsCameras);

2016-02-17 TB:
- Einige Header aufgeräumt (Aussagekräftige Komentare zu allen Methoden, Membervariablen in korrekte Zonen und an das Ende)

2016-02-18 TB:
- Kubisches EnvironmentMapping realisiert.
- VektoriaRealHierarchy-File für das Kubische Environment-Mapping

2016-02-19 TB:
- Testumgebung für kubisches Env-Mapping

2016-02-22 TB:
PointClouds möglich, dafür folgende neue Klassen: 
- CGeoPointList
- CGeoPointLists
Pixelgenaue Linien mögglich, dafür folgende neue Klassen:
- CGeoLineList
- CGeoLineLists
Verbesserung des Aussehen des Kubischen Env-Mappings (pixelgenau an Rändern des Teilbildes, bikubisch interpoliert in den Mitten)

2016-02-23 TB:
TriangleTables möglich, dafür folgende neue Klassen: 
- CGeoTriangleTable
- CGeoTriangleTables

2016-02-24 TB:
Bezier-Patches möglich, dafür folgende neue Klassen: 
- CGeoBezierTable
- CGeoBezierTables

2016-02-25 TB:
Neue Geometrieklasse: 
- CGeoUtahTeapot (erzeugt Utah Teapot)

2016-02-26 TB:
Neuer verbesserter Wavefront-Importer 
Neue Mapping-Funktionen in CGeo:
	void MapCubic(int iUVRepeat = 1); //  Echtes kubisches UV-Mapping mit gleichem Bild pro Seite
	void MapCubicPlanar(); // Vereinfachtes kubisches UV-Mapping
	void MapCubicVektorian(); // Echtes kubisches UV-Mapping mit verschiedenen Bildern pro Seite
Bugfix: CGeoUtahTeapot wurde am Knauf falsch UV-gemappt
Neue Funktion zum Zentrieren einer Geomertie:

2016-03-05 TB:
Bugfix: Utah Teapot hatte falsche Bitangenten am Sockel

2016-03-10 TB:
Neues Manual für V14 fertig gestellt

2016-03-15 TB:
Neue Mapping-Fuznktionen in CGeo:
	void MapCubic(int iUVRepeat = 1); //  Echtes kubisches UV-Mapping mit gleichem Bild pro Seite
	void MapCubicByDirection(int iUVRepeat = 1); //  Echtes kubisches UV-Mapping mit gleichem Bild pro Seite, hier wird der Normalenvektor als Grundlage genommen
	void MapCubicPlanar(); // Vereinfachtes kubisches UV-Mapping
	void MapCubicVektorian(); // Echtes kubisches UV-Mapping mit verschiedenen Bildern pro Seite
	void MapCubicVektorianByDirection(); // Echtes kubisches UV-Mapping mit verschiedenen Bildern pro Seite, hiere wird der Normalenvektor als Grundlage genommen

2016-03-16 TB:
Materialdemo verbessert
Umfangreiche Tests


2016-03-17 TB:
 - Vektoria V14 Alpha erstellt

2016-03-20 TB
 - Vektoria V14 Alpha für VS 2015 erstellt

____________________________________________________
Vektoria V14 Alpha
___________________________________________________

2016-03-23 TB:
CGeoUtahCup-Klasse hinzugefügt

2016-03-25 TB:
GeoUtahCup-Teile können jetzt getrennt erzeugt werden.
GGeoUtahCup hat kein Loch mehr, wie im Original  

2016-03-29 TB:
Bugfix: Transparente Sprites und Objekte wurden in der Alpha-Version nicht richtig z-sortiert => Artefakte bei Partikelsystemen etc.

2016-03-30 TB:
Bugfix: TriangleTables wurden im Verteilten Rendering nicht übermittelt.

2016-04-01 TB:
Neue praktische Funktionen in CDeviceMouse:
	bool ButtonDown(int iButton); // einmal true, falls Taste iButton (Tastennummer gemäß DirectX) gedrückt wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonDownLeft(); // einmal true, falls linke Maustaste gedrückt wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonDownMid(); // einmal true, falls mittlere Maustaste gedrückt wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonDownRight(); // einmal true, falls rechte Maustaste gedrückt wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonUp(int iButton); // einmal true, falls Taste iButton (Tastennummer gemäß DirectX) losgelassen wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonUpLeft(); // einmal true, falls linke Maustaste losgelassen wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonUpMid(); // einmal true, falls mittlere Maustaste losgelassen wurde, ansonsten false (synchrone Mausklickabfragemethode)
	bool ButtonUpRight(); // einmal true, falls rechte Maustaste losgelassen wurde, ansonsten false (synchrone Mausklickabfragemethode)
Neue praktische Funktionen in CDeciceGameController:
	bool ButtonDown(unsigned int uButton); // einmal true, falls Taste uButton (Tastennummer gemäß DirectX) gedrückt wurde, ansonsten false
	bool ButtonUp(unsigned int uButton); // einmal true, falls Taste uButton (Tastennummer gemäß DirectX) losgelassen wurde, ansonsten false
Neue praktische Funktionen in CDeviceCursor:
	bool ButtonDown(int iButton); // einmal true, falls Taste iButton gedrückt wurde, ansonsten false
	bool ButtonUp(int iButton); // einmal true, falls Taste iButton gedrückt wurde, ansonsten false
	bool ButtonDownLeft(); // einmal true, falls linke Maustaste gedrückt wird, ansonsten false
	bool ButtonDownRight(); // einmal true, falls rechte Maustaste gedrückt wird, ansonsten false
	bool ButtonDownMid(); // einmal true, falls mittlere Maustaste gedrückt wird, ansonsten false
	bool ButtonUpLeft(); // einmal true, falls linke Maustaste losgelassen wurde, ansonsten false
	bool ButtonUpRight(); // einmal true, falls rechte Maustaste losgelassen wurde, ansonsten false
	bool ButtonUpMid(); // einmal true, falls mittlere Maustaste losgelassen wurde, ansonsten false
CDevice-Header mit Kommentaren versehen und aufgeräumt

2016-04-02 SB:
- Material TilesMarbleWhite erzeugt

2016-04-02 TB:
Bugfix: Overlays und Backgrounds wurden in verschiedenen Viewports teilweise doppelt angezeigt
Bugfix: Manche Materialien von Sprites wurden nicht automatisch bei der Root  angemeldet

____________________________________________________
Vektoria V14 Beta
___________________________________________________

2016-04-04 TB:
- Die Teile des UtahTeapots können nun bei der Initialisierung genau spezifiert werden, auch wurde das Aussehen am Rand des Deckels verbessert, indem ein Innenmaterial angegeben werden kann, die  Init-Funktion: 
	void Init(float fHeight, CMaterial * pmaterial, int iVerticesPerPatchEdge = 8, bool bGroundZero = false, bool bMain = true, bool bTop = true, bool bBottom = true, bool bGrip = true, bool bMouth = true, bool bInside = false, CMaterial  * pmaterialInside = nullptr); // Initialisiert einen Utah Teapot

2016-04-05 TB:
- Bugfix: Transparente Materialien wurden nicht z-Buffer-sortiert, falls die Initialisierung der Geometrie nach dem Adding an das übergeordnete Placement erfolgte.
- Bugfix: Die Funktion CGeo::Center() zentrierte nicht die angehängten Untergeometrien mit.
- Bugfix: Der neue Wavefront-Importer (OBJ) hatte Probleme mit dem korrekten Import der UV-Koordinaten.

2016-04-08 TB:
- Bugfix: System stürzte bei manchen (seltenen) Kobinationen von SwitchOff / SwitchOn und zusammenlaufenden Hierarchien ab.

2016-04-10 TB:
- Bugfix: Position des sekundären Viewports wurde nicht richtig beim verteilten Rendering übertragen.

2016-04-12 TB:
- Einfügung von einfachen Intellisense-Meldungen bei allen Methoden in Material.h.

2016-04-13 TB:
- Bugfix: Subsurface-Scattering und Thickness-Texturen wurden beim verteilten Rendering nicht übertragen.
- Bugfix: CMaterial::SetTextureThickness() funktionierte nicht richtig. 
- Bugfix: Externe Bibliotheken, welche die "windows.h"-Bibliothek inkludieren, konnten nicht bzw. nur über Umwegen parallel zu Vektoria benutzt werden.

2016-04-14 TB:
- Bugfix: System konnte bei (seltenen) Konstellationen von mehreren Viewports in kombination mit zusammenlaufenden Hierarchien abstürzen. 
- Bugfix: Billboards wurden bei mehreren Viewports, welche verscheidenen Sichten, ein- und derselben Kameraposition zeigten, nicht korrekt ausgerichtet. 

2016-04-15 TB:
- Methode "CNode::GetCount()" in "CNode::GetNrOfChildren()"umbenannt, da Name missverständlich war
- Neue Methode in CNode: int GetNrOfParents(void); 	// Gibt die Anzahl an Elternknoten zurück.
- Material CounterLiteral in die Materialbibliothek hinzugefügt
- Methoden SubChild und SubParent geben jetzt boolschen Return-Wert aus, ob das Abhängen geklappt hat.

2016-04-16 TB:
- Bugfix: CNode::IsGeo gab fälschlicherweise false aus, wenn es sich um eine Punkt- oder Linelist handelte
- CNode::IsGeo beschleunigt.

2016-04-17 TB:
- Einfache Intellisense-Kommentare in CNode hinzugefügt
- Einfache Intellisense-Kommentare in CNode3D hinzugefügt
- Einfache Intellisense-Kommentare in CSprite hinzugefügt

2016-04-18 TB:
- Einfache Intellisense-Kommentare in CGeo hinzugefügt
- Einfache Intellisense-Kommentare in CTimer hinzugefügt
- Veraltete Klasse CLibString gelöscht. 

2016-04-21 TB:
- Einfache Intellisense-Kommentare in CPlacement inzugefügt
- CPlacement::HierarchyToTriangleList in HierarchyToGeoTriangleList umbenannt
- CPlacement::HierarchyToTriangleList in HierarchyToGeoTriangleList umbenannt
- Bugfix: HierarchyToGeoTriangleList hatte danach immer noch die TriangleStrips in der Hierarchie, ohne sie abzuhängen

2016-04-22 TB:
- CLightParallel, CLightSpot, CLightRadial, CLight:: Kopieroperator- und Methode jeweils in Call-of-Reference umgewandelt 
- Einfache Intellisense-Kommentare in CLight hinzugefügt
- Einfache Intellisense-Kommentare in CLightParallel hinzugefügt
- Einfache Intellisense-Kommentare in CLightRadial hinzugefügt
- Einfache Intellisense-Kommentare in CLightSpot hinzugefügt
- Parameter in CLight-Klassen konform zur Vektoria-Notation gemacht. 
- Einige ehemalige  private-Membervariablen nach Diskussionen mit Anwendern public oder protected gemacht. 

2016-04-23 TB:
- Intellisense-Kommentare in CRoot hinzugefügt

2016-04-24 JB:
- Komplexe Intellisense-Kommentare in CNode3D hinzugefügt
- Komplexe Intellisense-Kommentare in CPlacement hinzugefügt

2016-04-24 SB:
- Einfache Intellisense-Kommentare in CCamera hinzugefügt

2016-04-24 TB:
- Einige komplexe Intellisense-Kommentare in CCamera hinzugefügt
- Einfache Intellisense-Kommentare in CViewport hinzugefügt
- Einfache Intellisense-Kommentare in CVertex hinzugefügt
- Einfache Intellisense-Kommentare in CFrame hinzugefügt
- Einfache Intellisense-Kommentare in CBackground hinzugefügt
- Einfache Intellisense-Kommentare in CScene hinzugefügt
- Einfache Intellisense-Kommentare in CWribel hinzugefügt
- CCamera aufgeräumt
- Neue Initialisierungsroutinen in CCamera:
		void InitOrtho(float fOrthoScalingHorizontal = 100.0F, float fNearClipping = 0.1F, float fFarClipping = 3000.0F);  // Initalisiert eine orthogonale Kamera (Kamera mit Parallelprojektion).
		void InitRatioFixed(float faFovHorizontal = HALFPI, float faFovVertical = HALFPI, float fNearClipping = 0.1F, float fFarClipping = 3000.0F); // Initalisiert eine Kamera mit dedizierter Angabe von horizontalem und vertikalem Kameraöffnungswinkel.

2016-04-25 TB:
- Komplexe Intellisense-Kommentare in CGeoBezierTable hinzugefügt
- Komplexe Intellisense-Kommentare in CWriting hinzugefügt
- Komplexe Intellisense-Kommentare in CWritingChar hinzugefügt
- Einfache Intellisense-Kommentare in CDeviceCursor hinzugefügt
- Einfache Intellisense-Kommentare in CDeviceMouse hinzugefügt
- Einfache Intellisense-Kommentare in CDevicekeyboard hinzugefügt
- Aus rechtlichen Gründen allerletzte Code-Reste von MS und MR gelöscht (TODO: Mit Ausnahme vom Blender-Importer).
- Auf Wunsch der Studierenden einige private-Methoden zu protected gemacht. Tick- und Draw-Methoden wurden dagegen von public zu protected.
- Kopieroperator und -methode in CFace CallByReference gemacht
- Neuer Konstruktor in CFace, der gleich die richtigen Vertices setzt
- Beschleunigtung der Tick-Routinen von CGeoTriangleStrip, CGeoTriangleList und CGeoTriangleTable
- Neue Methoden in CSplash:
	DeactivateProgressBar(); // Versteckt den Fortschrittsanzeiger für immer
	AktiviertProgressBar(); // Aktiviert den Fortschrittsanzeiger (default)
- Bugfix (serious): CGeoWings wurden in V14 gar nicht mehr angezeigt
- Bugfix: ProgressBar erschien wieder, wenn nach Init eine Geometrie initialisiert wurde  

2016-04-26 TB:
- Komplexe Intellisense-Kommentare in CGeoQuad hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoArrow hinzugefügt
- Einfache Intellisense-Kommentare in CFace hinzugefügt
- Einfache Intellisense-Kommentare in CHardware hinzugefügt
- Komplexe Intellisense-Kommentare für Methoden in CFrame hinzugefügt
- Komplexe Intellisense-Kommentare für Methoden in CCamera hinzugefügt

2016-04-27 TB:
- Bugfix: Der Aufruf der Update-Methode bei Geometrien vor dem ersten Tick führte zum Absturz 

2016-04-28 TB:
- Bugfix: Der OBJ-Importer lud bei manchen Formaten falsche Normalen- und Texturkoordinaten  
- Neue Funktionen in CTriangleTable:
	void ReduceRedundancy(bool bCheckNormals, bool bCheckTangents, bool bCheckBitangents, bool bCheckUVs, float fPosThresholdRadius, float faThreshold, float fUVThresholdRadius);
- Neue Funktionen in CVertexs:
	void KillMarked();	// Löscht alle markierten Vertices (Vertices, deren Flag m_bMarked = true ist). 
- Neue Funktionen in CVertex:
	bool Equal(CVertex & vertex, bool bCheckNormal, bool bCheckTangent, bool bCheckBitangent, bool bCheckUV); 		// Vergleicht den Vertex mit dem Vertex v, gibt true aus wenn die beiden Vertices identisch sind.
	bool Similar(CVertex & vertex, bool bCheckNormal, bool bCheckTangent, bool bCheckBitangent, bool bCheckUV, float fPosThresholdRadius, float faThreshold, float fUVThresholdRadius);
- Kopieroperator in CVertexs beschleunigt

2016-04-29 TB:
- Komplexe Intellisense-Kommentare für Methoden in CLightSpot hinzugefügt
- Einfache Intellisense-Kommentare in CColor hinzugefügt
- Einfache Intellisense-Kommentare in CFloatRect hinzugefügt
- Einfache Intellisense-Kommentare in CFrustum hinzugefügt
- Komplexe Intellisense-Kommentare für Methoden in CGeoCube hinzugefügt

2016-05-01 TB:
- Einfache Intellisense-Kommentare in CHMat hinzugefügt
- Einfache Intellisense-Kommentare in CHVector hinzugefügt
- Einfache Intellisense-Kommentare in CPlane hinzugefügt
- Einfache Intellisense-Kommentare in CRay hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoCylinder hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoLineList hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoPointList hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoTriangleStrip hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoTriangleList hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoTriangleTable hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoEllipsoid hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoEllipsoidTiled hinzugefügt
- Tick-Methoden in CGeoLineList und CGeoPointList gelöscht, da sie sowieso nur den Tick der Basisklasse aufruften.
- Kopiermethoden in CQuaternion und CRay jeweils in Call by Reference umgewandelt 
- Draw-Methoden in von CGeo abgeleiteten Klassen protected gemacht

___________________________________________________
2016-05-01 TB: Vektoria V14 für VS 2013 erzeugt
___________________________________________________

___________________________________________________
2016-05-03 TB: Vektoria V14 für VS 2015 erzeugt
___________________________________________________

2016-05-03 TB:
- Komplexe Intellisense-Kommentare in CGeoSweep hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoCone hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoFrustum hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoTriangle hinzugefügt
- Komplexe Intellisense-Kommentare in CFace hinzugefügt
- Viele bisherige Intellisense-Kommentare nach inhaltlichen Inkonsistenzen und Rechtschreibfehlern überprüft. (ca. 30 Korrekturen)

2016-05-04 TB:
- Zwei neue Methoden in CNode, praktisch um haptische Szenen zu beschreiben:
	void SetDrawingOn();   // Schaltet Knoten mitsamt seiner Unterhierarchie zum Zeichnen ein.
	void SetDrawingOff();  // Schaltet Knoten mitsamt seiner Unterhierarchie zum Zeichnen aus.

2016-05-05 TB:
- Komplexe Intellisense-Kommentare in CGeoTetrahedron hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoIcosahedron hinzugefügt
- Komplexe Intellisense-Kommentare in CGeoTube hinzugefügt
Bugfix: Point- und Linelists wurden beim Verteilten Rendering nicht übertragen.

___________________________________________________________
2016-05-03 TB: Vektoria V14 mit Patch 1 für VS 2013 erzeugt
___________________________________________________________

2016-05-09 TB: 
- Postprocessing in Basic Renderer einprogrammiert

2016-05-11 TB: 
- Glow/Bloom-Effekt nun auch im Basic Renderer möglich

2016-05-12 TB: 
- Glow-Textur kann nun zu Bloom-Glow getoggelt werden, dafür folgende neue Methode in CMatarial:
		void SetGlowStrength(float fGlowStrength); 		// Setzt die Stärke des Glows, Default = 1.0f, über 1 gibt es einen Bloom-Effekt, auch negative Werte sind erlaubt und ergeben "schwarze Lichter",  die der Umgebung Licht nehmen.   
- TestbedFix verändert mit Point-Clouds und Glow-Texturen

2016-05-18 TB: 
- Methode SubAll() in CPlacement einprogrammiert (auf Wunsch einer DV-Projektgruppe).
- Pluralklassen CLightsRadials und CLightSpots von der Varaiablenbenennung her konsistent gemacht
- Bugfix in den Pluralklassen CGeos, CPlacements, CEmitters, CAudios, CLightRadials, CLightSpots, CWribels (Verursachten bei unsachgemäßem Gebrauch Memory Leaks)

2016-05-20 TB: 
- Glow kann jetzt an- und ausgeschaltet werden mit SetGlowOn/Off.

2016-05-23 TB: 
- Bugfix: GeoQuads von Sprites wurden nicht bei der Root angemeldet.
- Komplexe Intellisense-Kommentare in den Methoden von CSprite hinzugefügt
- Neue Methoden zum Setzen der UV-Koordinaten in CGeoQuads und CSprite (Praktisch für Minimaps): 
	void CGeoQuad::SetUVRect(CFloatRect floatrect); 
	void CSprite::SetUVRect(CFloatRect floatrect);

2016-05-24 TB: 
- Bugfix: Overlays und Backgrounds konnten bei manchen Add-Konstellationen nicht während der Laufzeit verändert werden. 
- Bugfix: MemoryLeaks beim Finalisieren. 
- Bugfix: Bei einigen Lichtkonstellationen konnten Lichter nicht während dert Laufzeit ihre Farbe ändern.
- Bugfix: Spotlights hatten bei einigen Konstellationen negatives Licht (Sie nahmen Licht von der Oberfläche weg).
- Reduced-Shader

2016-05-24 TB: 
Neue Methoden in CMaterial: 
 - SetGlowSharpness()
 - SetGlowEverywhere()

2016-05-26 TB: 
Bugfix: Quaternionen Gleichheits- und Ungleichsoperator funktionierten nicht richtig 
Bugfix: Bloom erzeugte bei hellen Lichtern farbige Ränder  
Starke Beschleunigung des Blooms durch vorgefertigtes Array (Dazu Extraprogramm geschrieben)

2016-06-02 TB: 
Parameter in GetRotation umgedreht (statt Yaw-Pitch-Roll, Pitch-Yaw-Roll, wie es in der Computergrafik üblich ist)

2016-06-03 JB: 
- Komplexe Intellisense-Kommentare in den Methoden von CHMat hinzugefügt
- Komplexe Intellisense-Kommentare in den Methoden von CHVector hinzugefügt
- Komplexe Intellisense-Kommentare in den Methoden von CRay hinzugefügt
- Komplexe Intellisense-Kommentare in den Methoden von CFrustum hinzugefügt
- Komplexe Intellisense-Kommentare in den Methoden von CPlane hinzugefügt
- Komplexe Intellisense-Kommentare in den Methoden von CFloatRect hinzugefügt

2016-06-03 TB: 
- Intellisense-Kommentare von JB überarbeitet.
- Bloom-Effekt beschleunigt 
___________________________________________________________
2016-06-06 TB: Vektoria V14 mit Patch 2 für VS 2013 erzeugt
___________________________________________________________

2016-06-07 TB:
- CIntersectable gelöscht
- Bugfix: Die Parameter spezieller Overlay-Texturen konnten nicht während der Laufzeit verändert werden.
- Konstruktoren von CRay auf CallByValue geändert
Neue Methode in CHMat:
- GetDirection() 
Neue Methoden in CPlacment:
- GetPos()
- GetDirection()

2016-06-09 TB:
- Bugfix: Overlays und Writings reagierten nicht auf RotateHue und andere Farbmodifikatuonsmethoden
- Bugfix: In Klasse CAABB: bool Intersects(CRay & r); funktionierte nicht richtig
- Bugfix: In Klasse CWriting: LoadPreset griff auf falschen Pfad zu
- Bugfix: Kopieroperator von CMaterial kopierte nicht die Parameter für das Subsurface-Scattering
- In Klasse CAABB und CNode3D: Veraltete Intersects-Methoden gelöscht, dafür neue eingefügt. 
- AABB-Intersection beschleunigt.
- Diverse Intellisense-Komentar-Korrekturen in CNode3D
Neue Methoden in CWriting zum Verändern der Schriftfarbe:
	void RotateHue(float fa);
	void RotateHue(float fa, iCharFron, iCharTo);
Neue Methoden in CWritingChar zum Verändern der Schriftfarbe:
	void RotateHue(float fa);

2016-06-10 TB:
- Bloom-Effekt verbessert (kann jetzt auch farbige Licher gloomen)
- Material-Library von den Parametern her aktualisiert

___________________________________________________________
2016-06-13 TB: Vektoria V14 mit Patch 3 für VS 2013 erzeugt
___________________________________________________________

2013-06-14 TB:
- Bugfix: RotateHue wirkte sich nicht bei Chroma-Key-Materialien aus

2013-06-16 TB:
- Warnings in CGeoUtahCup eliminiert
- Veraltete Methoden SetBehindOn und SetBehindOff in COverlay gelöscht
- CCWritingChars, Writings und COverlays aufgeräumt, insbesondere veraltete, überflüssige Pareameteraufrufe in Tick gelöscht
- Komplexe Intellisense-Kommentare in COverlay hinzugefügt

2013-06-17 TB:
- Testprogramm zum Updating von TriangleLists geschrieben, 3h auf Herz und Nieren getestet, entgegen der Meldungen funktioniert Updating einwandfrei

2013-06-18 TB:
- Bugfix: Sub-Overlays/-Writing an Overlays funktionierten nach Patch 3 plötzlich nicht mehr

2013-06-19 TB:
- Antialiasing verbessert, funktioniert jetzt bei allen Grafikkarten, 
- Zwei neue Shader mit 4*Antialiasing-Features: MonolightAA und StandardAA
- Testprogramm zum Updating von Laden von Sounds geschrieben, 3h auf Herz und Nieren getestet, entgegen der Meldungen funktioniert Soundladen einwandfrei

2013-06-20 TB:
- Bugfix: Viewports wurden bei Auschalten von Postprocessingeffekten immer in die linke obere Ecke gesetzt
- Eigenen Postprocessing-Shader für Anwender erzeugt, der bei eApiRender_DirectX11_Shadermodell50_Own mitgeladen wird

___________________________________________________________
2016-06-21 TB: Vektoria V14 mit Patch 4 für VS 2013 erzeugt
___________________________________________________________

2013-06-22 TB:
- Bugfix: TriangleTables wurden nicht gepickt
- Bugfix: TriangleTables kollidierten nicht
- Bugfix: TriangleTables funktionierten nicht mit FrustumCulling
- Beschleunigung der Methode CGeo::IsGeo() 
- Alle Projekteigenschaften so eingestellt, dass eine beschleunigte Compilierung mit meheren Prozessoren möglich ist 

2013-06-23 TB:
- Bugfix: Mehrere Viewports wurden bei Auschalten von Postprocessingeffekten überschrieben
- RenderViewport leicht beschleunigt (ca. 3%) durch Ausmisten von unnötigen Befehlen  

___________________________________________________________
2016-06-23 TB: Vektoria V14 mit Patch 5 für VS 2015 erzeugt
___________________________________________________________


2016-07-03 TB:
- Koplettumbau zu Mulitpass-System mit mehreren Passes

2016-09-07 TB: 
- Postprocessing-Testumgebung erstellt

2016-07-18 TB:
- Zwei Pathes für Tiefenberechnung, 

2016-07-20 TB: 
- Neue Setter-Methode in CCamera: 
		void SetFocalDistance(float fFocalDistance);
 
2016-08-20 TB:
- Komplette Überarbeitung des Bloom-Effektes, ist jetzt etwas schneller und sieht besser aus.
- Bloom-Effekt kann jetzt Entfernungsabhängig parametrisiert werden, dafür folgende neue Methoden in CViewport:
		void SetBloomOn();
		void SetBloomOff();
		void SetBloomDepthDecay(float frBloomDepthDecay);
		void SetBloomWidth(float frBloomWidth);
		void SetBloomStrengthNear(float frBloomStrengthNear);
		void SetBloomStrengthFar(float frBloomStrengthFar);

2016-08-25 TB:
- Blur-Effekt-Postprocessingfilter programmiert, dafür folgende Methoden in CViewport:
		void SetBlurOn();
		void SetBlurOff();
		void SetBlurStrength(float frBlurStrength);

2016-08-25 TB:
- Depth-Blur-Postprocessingfilter	programmiert, dafür folgende Methoden in CViewport:
		void SetDepthBlurOn();
		void SetDepthBlurOff();
 		void SetDepthBlurStrength(float frDepthBlurStrength);
		void SetDepthBlurSharpness(float fDepthBlurSharpness);

2016-08-29 TB:
-Tiefenumrandungs-Postprocessingfilter programmiert, dafür folgende Methoden in CViewport:
		void SetOutliningOn();
		void SetOutliningOff();

2016-09-10 TB: 
- Komplexe Intellisense-Kommentare in CViewport hinzugefügt
- Komplexe Intellisense-Kommentare in CNode hinzugefügt

2016-09-11 TB: 
- Bugfix: Root wurde bei bestimmten Initialisierungsreihenfolgen im WritingChars nicht gesetzt. 
- Galaxie-Demo-erstellt

2016-09-12 TB: 
- Neue Blur- und Bloom-Parameter werden nun auch im verteilten Rendering übermittelt

2016-09-13 TB: 
- Projekteinstellungen Windows10-Kompatibel gemacht (vorher musste man noch Anpassungen vornehmen)

2016-09-18 TB: 
- Neue Sicherheitsabstandsfunktion für das Postprocessing: 
		void SetPostprocessingBorder(float frPostprocessingBorder); // Setzt einen Sicherheitsabstand an den Rändern des Viewports für die Postprocessing-Aktionen. 

__________________________________________________________
2016-09-19 TB: Vektoria V14 mit Patch 6 für VS 2015 erzeugt
___________________________________________________________

2016-09-20 TB: 
- Experimente mit Heat Haze Shadern

2016-09-21 TB: 
- Load- und Save-Methoden in CVektoria aktualisiert

2016-09-22 TB: 
- Variablen in CLightParallel, CLightRadial und CLightSpot Vektoria-Notationskonform gemacht
- Load- und Save-Methoden in CScene hinzugefügt
- Load- und Save-Methoden in CLight hinzugefügt
- Load- und Save-Methoden in CLightParallel hinzugefügt
- Load- und Save-Methoden in CLightRadial hinzugefügt
- Load- und Save-Methoden in CLightSpot hinzugefügt

2016-10-10 TB: 
- Bugfix: Im Fullscreen-Mode gab es bei verschiedenen Security-Border-Werten (frPostprocessingBorder) einen blauen Rand.
- Neue Lade- und Speichermethoden in der Root: 
	void LoadVirtualHierarchy(CFileVektoria & filevektoria, int id); // Lädt alle Szenenbeschreibungen aus einem Vektoria-Rootfile.
	void SaveVirtualHierarchy(CFileVektoria & filevektoria, bool bWithID = false); // Speichert alle Szenenbeschreibungen in ein Vektoria-Rootfile.

2016-10-12 TB: 
- Drei neue Funktionen in CDeviceCursor, um "virtuelle Cursors" zu erzeugen: 
	void SetVirtualFractional(float frx, float fry);
	void SetVirtualAbsolute(int ix, int iy);
	void SetVirtualOff();
- Komplexe Intellisense-Kommentare in CDeviceCursor hinzugefügt

2016-10-13 TB: 
- Komplexe Intellisense-Kommentare in CDeviceMouse hinzugefügt
- Komplexe Intellisense-Kommentare in CDeviceGameController hinzugefügt
- Komplexe Intellisense-Kommentare in CDeviceKeyboard hinzugefügt

2016-10-15 TB: 
- Komplexe Intellisense-Kommentare in CRoot hinzugefügt
- Komplexe Intellisense-Kommentare in CPlacement verbessert und korrigiert

2016-10-16 TB: 
- Veraltete Klassen CTerrain, CLog, CDrawable, CDrawables CMaterialPreset und CTestbedShader gelöscht und verbliebene Files angepasst.
- IsValidIdentifier zu Methode von CTokenString gemacht 

2016-10-17 TB:
- Komplexe Intellisense-Kommentare in CLight hinzugefügt

2016-10-18 TB:
- Komplexe Intellisense-Kommentare in CGeo hinzugefügt
- Komplexe Intellisense-Komentare in CFrame vervollständigt
- Postprocessing kann jetzt pro Textur an und ausgeschaltet werden, dafür folgende Methoden in CMaterial: 
	-SetPostprocessingOn();
	-SetPostprocessingOff();
- Neue praktische Methode in CMaterial für Billboards und Wribels:
	- CImage * MakeTextureBillboard(char * acPath);
- Verbesserung des Outlinings
- Leichte Beschleunigung des Postprocessing-Shaders 
- Bugfix: Antialiasing hatte nicht zusammen mit Postprocessing funktioniert
- Bugfix: Standard-Shader funktionierte nicht zusammen mit Postprocessing

2016-10-23 TB:
- Bugfix: Wings mit Flachdächern wurden in seltenen Fällen im Release-Modus nicht richtig aufgebaut.
- Drittes Testgebäude in Testbed Town hinzugefügt

2016-10-24 TB:
- Haze-Effekt in Postprocessor hinzugefügt
- Komplexe Intellisense-Kommentare in CMaterial hinzugefügt
- Bloom und Blur-Effekt leicht beschleunigt

2016-10-25 TB:
- Haze-Effekt kann nun mit Hilfe der Heightmap des Materials gesteuert werden, dafür folgende neue Methoden in CMaterial:
	- void SetHazeStrength(float fHazeStrength);
	- void SetHazeOn();
- Komplexe Intellisense-Kommentare in CScene hinzugefügt
- Komplexe Intellisense-Kommentare in CTexture hinzugefügt
- Komplexe Intellisense-Kommentare in CImage hinzugefügt
- Komplexe Intellisense-Kommentare in CVertex hinzugefügt

2016-10-26 TB:
- Komplettüberarbeitung der Shader:
	- Gemeinsame Parameter der redundanzvermeidung halber jeweils in gemeinsam benutzte Include-Dateien geseteckt.
	- Parameter der Viewports ausgemistet
	- Leichte Beschleunigung des Viewportshaders
	- Color-Modification in den Postprocessing-Shader verschoben
- Outlining kann nun in allen beliebigen Farben sein, dazu folgende neue Methode in CViewport:
	- void SetColorOutline(CColor colorOutline);
- ColorModification kann nun  auch für einzelne Objekte ausgeschaltet werden. 
- StylePurpleHaze verbessert
- Unbenutzte Parameterübergaben zum Shader gelöscht unt sortiert => leichte Beschleunigung

2016-10-29 TB:
- Neue praktische Methode in CAABB:: SetToInfinity()
- PlaceWASD-Settings in CPlacement verschoben

2016-10-30 TB:
- Bugfix in CGeo:Intersects: Untergeometrien wurden nicht mit berücksichtigt  

2016-10-01 TB:
- Neue Methoden in CGeos:
	void AddPlacementGeos(CPlacement * pplacement);
	bool Intersects(CRay & r, CHVector & vIntersection, float & fDistanceSquare);
	bool Intersects(CRay & r, CHitPoint & hitpoint);

2016-11-02 TB:
- Neue Methoden  in CPlacement zur Bewegungssteuerung:
		void SetMoveRange(CAABB aabbMove);
		void SetTranslationSensitivity(float fTranslationSensitivity);
		void SetRotationSensitivity(float fRotationSensitivity);
		float GetTranslationSensitivity();
		float GetRotationSensitivity();
		void SetPanAzimuth(float faPanAzimuth);
		void SetPanAltitude(float faPanAltitude);
		void SetPanRadius(float fPanRadius);
		void Move(float & fTimeDelta, bool bEarth, int & iAD, int & iSW, int & iFR, int & iLR, int & iUD);
		bool MoveWithCollisionDetection(float & fTimeDelta, bool bEarth, int & iAD, int & iSW, int & iFR, int & iLR, int & iUD, CGeos & zgs);
		bool MovePan(float & fTimeDelta, CPlacement & zpCenter, int & iAD, int & iSW, int & iFR, int & iLR, int & iUD, bool bRot);
- Neue Methoden  in CDeviceKeyboard zur Bewegungssteuerung:
		virtual bool PlaceWASDWithCollisionDetection(CPlacement & placementCamera, CGeos & zgsCollisionItems, float & fTimeDelta, bool bEarth = false);
- Unbenutzte Parameterübergaben zumShader gelöscht unt sortiert => leichte Beschleunigung
	
2016-11-04 TB:
- Bugfix: Bei CGeoGrid wurden die Bitangenten falsch berechnet	
- Erzeugung einer Testumgebung für die Burg
- Alle IsIntersecting-Methoden in "Intersects" umbenannt (zur Namensvereinheitlichung)
- Komplexe Intellisense-Kommentare in CHitPoint hinzugefügt

2016-11-06 TB:
- Konstruktor des Strahles Normiert automatisch die Richtung
- Bugfix in CGeo::Collides, CGeoTriangleList::Collides, CGeoTriangleStrip::Collides: Kollidierte nicht am Rand
- Neue Methode in CAABB: 
		bool IntersectsOrIsInside(CRay & r);
- Beschleunigung der Methode CAABB::Intersects
- Komplexe Intellisense-Kommentare in CAABB hinzugefügt

2016-11-07 TB:
- Bugfix: Beim FrustumCulling wurde die Positionsveränderung der Spot- und Punktlichter manchmal zu früh gecullt.
- 4 neue Klassen zur Erstellung Platonischer Körper: 
	CGeoDodecahedron
	CGeoOctahedron
	CGeoTetrahedron
	CGeoIcosahedron
- Die alte Klasse "CGeoTetraeder" wurde gelöscht.
__________________________________________________________
2016-11-08 TB: Vektoria V14 mit Patch 7 für VS 2015 erzeugt
__________________________________________________________

2016-11-09 - 2016-11-12 TB:
- Neue Klassen zur Erstellung von Platonischen Drahtgitternetzen: 
	CGeoDodecahedronWire
	CGeoOctahedronWire
	CGeoTetrahedronWire
	CGeoIcosahedronWire
	CGeoCubeWire

2016-11-13 - 2016-11-16 TB:
- Neue Klassen zur Erstellung von Platonischen Gewerken: 
	CGeoDodecahedronWerk
	CGeoOctahedronWerk
	CGeoTetrahedronWerk
	CGeoIcosahedronWerk
	CGeoCubeWerk

2016-11-17 TB:
- Anpassen der Größen der platonischen Körperkugeln
- Erweiterung einiger Intellisense-Nachrichten
- Verschönerung der Preset-Textur "CobblestoneMarble"
- Testumgebung für platonische Körperkugeln in TestbedBurg eingebaut

2016-11-18 TB:
Bugfix: Ausschalten des Postprocessings für Materialien führte zu weißem Material 
Bugfix: Postprocessing wurde nicht immer automatisch zurückgeschaltet, wenn nicht mehr benötigt
- Komplexe Intellisense-Kommentare in CTimer hinzugefügt
_________________________________________________________
2016-11-19 TB: Vektoria V14 mit Patch 8 für VS 2015 erzeugt
__________________________________________________________

2016-11-20 TB:
- CFileVektoria Windows-unabhängig gemacht und die langsamen Ini-Routinen durch eigene ausgetauscht

2016-11-21 TB:
- Alle Library-Materialien feinjustiert

2016-11-22 TB:
- Bugfix: In CMaterial::Load(...) Transparenz wurde nicht mitgeladen
- Testbed Materials verbessert und überarbeitet

2016-11-23 TB:
- Lade und Speichermethoden in CFileVecktoria extrem beschleunigt
- CFileVektoria Windows-Unabhängig gemacht (für eventuellen späteren Port auf Linux) 

2016-11-24 TB:
- fr-Parameter der Platonischen Körper sind nun geeicht und sinnfälliger (0= kein Gewerk, 1=volles Gewerk)

2016-11-26 TB:
- Methode Demark() in CNode hinzugefügt. 

2016-11-29 TB:
-Bugfix: Virtueller Cursor liferte falsche Werte für verschobene Frames
-Bugfix: Move-Methoden in CPalcement starteten nicht an initialisierter Position

2016-11-30 TB:
- Klasse Viewport aufgeräumt
- Bugfix: StyleMonochrome wurde von anderen Stilmethoden steltsam beeinflusst
- SetColorOutline ind SetOutliningColor umbenannt (zur Kompabilität mit den anderen Methoden)
- Toon-Stufen-Postprocessing-Filter
- Neue Viewport-Stile: 
		StyleRadar
		StyleToon
- Vorhandene Viewport-Farbmodifikationsmethoden: 
		void SetContrastDelta(CColor c);
		void SetLightness(float fr);
		void SetLightnessDelta(float fr);
		void SetLightness(CColor c);
		void SetLightnessDelta(CColor c);
		void SetBrightnessDelta(float fr);
		void SetBrightness(CColor c);
		void SetBrightnessDelta(CColor c);
- Town-Stil-Testumgebung erzeigt

2016-12-01 TB:
- Material WallFachwerk erzeugt
- Material WindowGothicStained & MetalRustyFlaking verbessert

_________________________________________________________
2016-12-01 TB: Vektoria V14 mit Patch 9 für VS 2015 erzeugt
__________________________________________________________

2016-12-03 TB:
- StyleToon verbessert
- Bugfix: CGeo::Save() speicherte Indices x-mal ab

2016-12-06 TB:
- Load- und Save-Methoden in CMaterial, CTexture, CImage und CGeo fähig gemacht, zusammenlaufende Hierarchien zu berücksichtigen. 
- Load- und Save-Methoden stark beschleunigt (ca. Faktor 20)

2016-12-07 TB:
- Nebel kann nun auch farbig sein, auch negativer Nebel (für Rauch, Chemiewolken, blauer Dunst, etc ) ist möglich, dazu folgende neue Methode in CViewport:
		void SetFogColor(CColor color);
- Town-Stil-Testumgebung verbessert (Engelstatur hinzugefügt, Stile werden angezeigt)

2016-12-08 TB:
Neue Methoden in CNode:
	bool HasParent(CNode* pnodeParent);
	bool HasChild(CNode* pnodeParent);
	void SetChild(CNode* pnodeChild);
	void Load(CFileVektoria & filevektoria);
	void Save(CFileVektoria & filevektoria);
Neue Methoden in CNodes:
	bool Has(CNode* pnode);

2016-12-09 TB:
- Bugfix in CPlacement::Load: Laden war nur möglich, wenn keine GeoTriangleStrips oder - tables in der Szene vorhanden waren
- Placements laden und speiechern auch Punkt- und Spotlights  

2016-12-10 TB:
- Laden und Speichern von Audios möglich, dafür folgende neue Methoden in CAudio:
	void Load(char * acPath);
	void Save(char * acPath);
	void Load(CFileVektoria & filevektoria, int id);
	void Save(CFileVektoria & filevektoria, bool bWithID = false);
- Placements und Szenen laden und speichern nun auch Audios

2016-12-10 TB:
- Komplexe Intellisense-Komentare in CAudio
- Neue praktische Methoden jeweils in CAudio, CScene, CPlacement, CGeo und CMaterial:
		void Load(char * acPath);
		void Save(char * acPath);

2016-12-11 TB:
- Ladeprozess bei allen Load-Methoden beschleunigt 
- 32 falsche Intellisense-Nachrichten korrigiert

2016-12-12 TB:
- Ausschalten des Speicherns von einzelnen Objekten möglich, dafür folgende Methode in CNode (und damit allen Knoten):
	void SetSavingOn();
	void SetSavingOff();

2016-12-13 TB:
- Bugfix: SetAmbient funktionierte nicht für Materialien, bei denen die GlowStrength Null war

2016-12-14 TB:
- Load- und Save-Methoden nun für alle Knoten (außer Wribels und Emitter) verfügbar. (Kurz getetestet)
- SavePreset-Methode in CGeo eingefügt

2016-12-15 TB:
- Bugfix: Wribels zeigten Weiß an, wenn das Material nicht an die Root geadded wurde
- Bugfix: Wurde ein Material nach dem Init hinzugefügt, dann konnte es sein, dass das Default-Material überschrieben wurde.
- Load- und Save-Methoden auch für Wribels verfügbar. (Kurz getetestet)
- Wribels aufgeräumt und Error-Messages hinzugefügt
- Bei Initialisierung werden Ok-Messages an wichtigen Stellen ins Log-File geschrieben.

2016-12-16 TB:
- SavePreset-Methode in CGeo eingefügt
- Einheitliche FileVektoria-Suffixe
- Klasse CPlacementPhysical eingefügt
- Testbed für Physik erstellt

2016-12-18 TB:
- Materialien in Lib in neues Format überführt, teilweise Parameter angepasst 

2016-12-19 TB:
- Jetzt einfach zu verstehende Load- und Save-Methoden zu den komplexen für alle realen Knoten hinzugefügt, 
- Knoten können jetzt auch per Namen gesucht werden (Praktisch, um mit abgespeicherten und wieder geladenen Knoten weiterzuarbeiten), dafür folgende neue Methode in CNode:
	CNode* SearchName(char acName);

2016-12-20 TB:
- Bugfix: SetLibPath() funktionierte nicht für CMaterial::LoadPreset()
- Hintergrundfarbe des Frames kann nun variabel gesetzt werden, dafür folgende Methode in CFrame: 
	void SetColorBackground(CColor color);
_________________________________________________________
2016-12-20 TB: Vektoria V14 mit Patch 10 für VS 2015 erzeugt
__________________________________________________________

2016-12-21 TB:
- Große Umstrukturierung begonnen, um erweiterte Physik und Partikelsysteme einzufügen.
- Recherche  

2016-12-22 TB:
- Klassen CPlacementPhysics und CScenePhysics eingefügt

2016-12-23 TB:
- Vorarbeiten, um Basic-Shader auch auf Forward-Plus-Shading umzustellen

2016-12-25 TB:
- Komplette Erneuerung aller Lichterklassen

2016-12-31 TB:
- Bugfix: Multiple Lichter und ambientes Licht zusammen führte zu uneinheitlichen Schatten 
- Shader komplett überarbeitet, können jetzt bis zu 16 Lichter auf ein Objekt anzeigen, getestet
- Shader Standard beschleunigt, durch Zusammenfassung redundanter Codeteile (ca. 20% Beschleunigung)
- Lichter für alle Shader in Lightconstants.hlsl zusammengefasst und veraltete Datenstrukturen herausgeworfen

2017-01-02 TB:
Zwei neue Methoden in CHVector: 
- 	CHVector InterpolLinear(CHVector & vA, CHVector & vB, float fr);
-	CHVector InterpolAngular(CHVector & vA, CHVector & vB, float fra);
- Alle Draw und Tick-Methoden protected gemacht (Anwender werden nur verwirrt durch diese Methoden)
- Ballistische Physik einprogrammiert

2017-01-04 TB:
- Neue Methoden in allen Geometrieklassen:
	- bool GetFace(int iFace, CFace & face);
	- void CalcRandomVertex(CVertex & vertexInterpolated);
- Viele Korrekturen in der Intellisense

2017-01-05 TB:
- Emitterkonzept überarbeitet
- Emitterklasse überarbeitet
- Emittertestbed erstellt

2017-01-06 TB:
- Emitter können nun wahlweise an Placments, Geos oder Materials gehangen werde

2017-01-07 TB
- Klasse CEmitterParticles erstellt
- Emitter können nun mehrfach referenziert werden
- Emitter können nun Unteremitter haben

2017-01-08 TB
- Kopieroperatoren in CPlacement, CGeo und CMaterial komplett überarbeitet. Es gibt nun verschiendene Kopieroperatoren für verschiedene Zwecke: 
	- CopyParameters kopiert nur die Parameter, aber nicht die hierarchie
	- Copy kopiert Parameter und die Pointer auf die Hierarchie
	- CopyHierarchy kopiert 
 
2017-01-17 TB
- Preset-Emitter "Drops" erstellt
- Überarbeitung des Haze-Postprocessings (Beschleunigung und genauere Eingrenzung an den Rändern)

2017-01-18 TB
- Preset-Emitter "Fog" erstellt
- Frame-Rate-Ranges für Emitter eingeführt

2017-01-19 TB
- Bugfix: Bei Billboards wurde manchmal die falsche Instanz genommen
- Billboard-System komplett überarbeitet, damit es bei Partikelsystemen nicht zu Artefakten durch Billboard-Überlagerungen kommt, dafür folgende neue Methode in CPlacment: 
	- SetBillboardForEmitters

2017-01-19 TB
- Neues flexibleres Sky- und Billboard-System: An Billboards und Sky-Placments lassen sich nun auch Unterplacements hängen, die sich sinnfällig mitbewegen
  	= Dies macht das ehemalige Konzept der Appendages vollkommen überflüssig.

2017-01-21 TB
´- Preset-Emitter "Smoke" und "Sparks" erstellt

2017-01-22 TB
´- Preset-Emitter "Fire" erstellt

2017-01-23 TB
- Preset-Emitter "Rain" erstellt
- Neue Matheklasse für Rauschfunktionen CGraphNoise erstellt und getestet

2017-01-23 TB
- Emitter können nun Placements anhängen und damit auch z.B. Sounds und Lichter 
- Wetterbedingungen in CScene eingebaut (Windrichtung, Windstärke, Windvolatilität, Temperatur, etc.) 
- Emitter bewegen sich sinnfällig mit

2017-01-24 TB
´- Neue Toggle-Methoden, damit Emitter nun die untergeordneten Sounds und Lichter auch sinnfällig steuern können

2017-01-26 TB
- Sounds haben nun ein neues logischers Statussystem
- Es könenn nun auch ambiente Stereo-Wav-Files und Wav-Files mit unterschiedlich langem Header geladen werden (Behebt damit das Problem, dass Wav-Files, die in Audiacity bearbeitet wurden, nicht für Vektoria geeignet waren) 
- Bugfix in Load und Save der Klasse CAudio: Geloopte Sounds starteten nach Laden nicht automatisch

2017-01-27 TB
- Preset-Emitter haben nun auch sinnfällige Lichter und Sounds
- Sound für Regen und Feuer erstellt, Presets überarbeitet
- Preset Emittermaterial "AshesGlowing" und "Showerhead" erstellt

2017-01-30 TB
- Bugfix bei Picking in orthografischen Kameras: Near- und Far-Clipping-Plane wurde manchmal nicht richtig berechnet, so dass Picking versagte
- Neuer Materialstatus für kopletttransparenete Materialien: Sinnvoll für zukünftige Wettermaschine

2017-02-01 TB:
- Klasse CNodeInstance erstellt, Instanzensystem komplett erneuert und beschleunigt

2017-02-02 TB:
- Lichter werden nun auch bei zusammenlaufenden Hierarchien mehrfach korrekt instanziiert
- Lichter beschleunigt
- Toggeling-System bei Emittern hinzugefügt (Emitter können nun die Position und die Stärke vopn Lichtern und Sounds steuern)

2017-02-03 TB:
- Klasse CSceneWeather hinzugefügt
- Lichter beschleunigt

2017-02-03 TB:
- Klasse CEmitterParticles hinzugefügt und eingebunden, Emitter können nun ebenfalls in zusammenlaufenden Hierarchien verwendet werden.
- Drei neue Preset-Materialien:
	SkyEvening, SkyNight und SkySummerCloudy

2017-02-04 TB:
- Vektoria-Header in die Vektoriafiles eingeführt 
- Versionsnummer eingeführt
- Laden und Speichern von CScene, CPlacement, CMaterial, CLightRadial, CLightParallel, CLightSpot, CEmitter, CGeo, CAudio, CRoot und CWribel kann nun aufwärtskompatibel gestaltet werden.
- Alle Preset-Materialien und -Emitter in das neue Format konvertiert 
 
2017-02-05 TB:
- Wetter-Engine nun mit genauer Sonnenstandsberechnung für jeden Ort und jede Zeit auf der Erde

2017-02-06 TB:
- Nebel, Schnee- und Regen in der Wetter-Engine hinzugefügt
- Bugfix: Die Partikellebensdauer bei Emittern wurden falsch abgespeichert
- Komplexe Intellisense-Messages für CScenePhysics, CSceneWeather, CEmitter, CEmitterParticles

___________________________________
2017-02-07 TB: Vektoria V15 erzeugt
___________________________________

2017-02-18 TB:
- Bugfix: Schatten funktionierten nicht mehr bei Objekten, die sehr weit vom Ursprung des Szenensystems entfernt waren
- Bugfix: Punkt- und Spot-Lichter wurden bezüglich der Y-Richtung falsch berechnet

2017-02-20 TB:
- Bugfix: CGeoTriangleList::Subdivide-Methoden erzeugten Memory-Leak

2017-02-20 TB:
- Bugfix: CGeoCube wurde falsch geflipt, wenn entsprechendes Flag gesetzt war

2017-02-21 TB:
- Wetterengine beschleunigt und Aussehen verbessert (TODO: Regen sieht noch etwas merkwürdig aus, alles andere ist OK)
- Skys erstellt und in die Lib eingebunden

2017-02-23 TB:
- Shader beschleunigt

2017-02-25 bis 2017-03-14 TB:
- Fünf größere Demos erstellt (Universum-Demo, Town-Demo, Wetterengine-Demo, erweiterte Material-Demo mit Emitter-Demo, Picking-Demo). 
- Dabei systematisch Fehler gesucht, Code auf Anwendbarkeit evaluiert. 

_____________________________________
2017-03-14 TB: Vektoria V15.1 erzeugt
_____________________________________

2017-03-16 bis 2017-03-28 TB:
- Komplettumbau der Sound-API: Modularisierung in DLLs zum zukünftigen flexiblen Arbeits-Outsourcing  
- Erzeugung der DLLSoundDirectSound
- Erzeugung der DLLSoundNull
- Saubere Sound-Api-Schnittstelle mit intellisense-Nachrichten erzeugt
- Viele kleinere Intellisense-Bugfixes. 

2017-04-07 bis 2017-04-10 TB:
- Komplettumbau der DirectX-API: Modularisierung in DLLs zum zukünftigen flexiblen Arbeits-Outsourcing  
- Erzeugung der DLLGraficsDirectX
- Erzeugung der DLLGraficsNull

2017-04-11 bis 2017-04-20 TB:
- Komplettumbau der DirectInput-API: Modularisierung in DLLs zum zukünftigen flexiblen Arbeits-Outsourcing  
- Erzeugung der DLLInputDirectInput08
- Erzeugung der DLLInputNull

2017-04-22 TB:
- Bugfix: Verteites Rendering zeigte ab und zu blauen Bildschirm in den Clients an.

2017-04-24 TB:
- Bugfix: Highlight funktionierte ab 15.1 nicht richtig bei Parallellichtern
- Bugfix: Einige Intellisense-Nachrichten in Viewport funktionierten nicht richtig   

2017-04-27 TB:
- Bugfix: CQuaternion hatte linkshändige Rotation.
- Bugfix: StyleBlackWhite funktionierte nicht mit anderen Farb-Styles

2017-05-03 TB:
- Bugfix: In der Hierarchitekturmodellieung wurde die linke Dachlatte bei InitRactSaddle nicht generiert, falls das Haus größer 2 Meter war.
- Apps auf VS 2015 umgestellt
Automatisches Kopier-Batch zur beschleunigten Versionserstellung generiert
Warnmeldungen in den Aps ausgeschaltet

2017-05-04 TB:
Ausgiebige Testung der neuen Version
_____________________________________
2017-05-05 TB: Vektoria V16 erzeugt
_____________________________________

2017-05-07 TB:
- Bugfix: Viele veraltete Property-Einstellungen gelöscht.

2017-05-09 TB:
- Bugfix: AppHalloWelt konnte nicht kompilieren.
Erweiterte Struktur von CFace mit Topologiedaten
Erweiterte Struktur von CVertex mit Topologiedaten

2017-05-12 TB:
- Bugfix: CGeoWall erzeugte ab und zu zufällig seltsame Wände in Debug64.
- Bugfix: CGeoWall räumte Datenmüll im Destruktor nicht richtig auf. => Hypothetischer MemoryLeak gefixt

2017-05-14 TB:
Neue Methoden zur Geometriebehandlung: 
- CVertex::Smooth()
- CFace::Flatten()

2017-05-15 TB:
Intellisense-Nachrichten für CFaces
Neue Funktionen in CFaces:
- Log()
- Clear()
- ClearTopology()
Löschung von unnötigen Init & Fini in CFaces
- Bugfix in CFaces: Dekonstruktor hinterlies Memory-Leak

2017-05-16 TB:
Neue Funktionen in CVertices:
- ClearTopology()
- Log()
Neue Funktionen in CVertex:
- ClearTopology()
- Log()

2017-05-18 TB:
Neue Funktionen in CAABB:
- Log()
- Clear();
- Bugfix in CGeo::UpdateAABB Methode funktionierte erst im Tick

2017-05-21 TB:
Octree fertiggestellt
Funktion Estimate TangentsAndBitangents stark verbesssert

_____________________________________
2017-05-23 TB: Vektoria V16.01 erzeugt
_____________________________________

2017-05-22 TB:
- Metainformationen für Geometrien erzeugt
- Importer Verbessert
_____________________________________
2017-06-13 TB: Vektoria V16.02 erzeugt
_____________________________________

2017-05-22 TB:
- EstimateTangentsAndBitangents2
_____________________________________
2017-06-23 TB: Vektoria V16.03 erzeugt
_____________________________________

2017-05-22 TB:
- Bugfix: Emitterlight wurde bei weiten Entfernungen zum Ursprung hin verschoben
- Komplexe Intellisense-Nachrichten für CGeos
_____________________________________
2017-06-26 TB: Vektoria V16.04 erzeugt
_____________________________________

